// animscripts/death.gsc

#include animscripts\weaponlist;
#include animscripts\combat_utility;
#include maps\_destructible;
#include maps\_dds;
#include animscripts\face;
#include animscripts\pain;
#include animscripts\shared;
#include maps\_utility;
#include animscripts\anims;
#include animscripts\utility;
#include common_scripts\utility;

#using_animtree ( "generic_human" );


// 0x2AA8
precache_ai_death_fx()
{
	anim._effect["animscript_gib_fx"] = loadfx( "weapon/bullet/fx_flesh_gib_fatal_01" );
	anim._effect["animscript_gibtrail_fx"] = loadfx( "trail/fx_trail_blood_streak" );
	anim._effect["death_neckgrab_spurt"] = loadfx( "impacts/fx_flesh_hit_neck_fatal" );
	anim._effect["tazer_knuckles_vomit"] = loadfx( "weapon/taser/fx_taser_knuckles_vomit" );
	anim._effect["character_fire_death_torso"] = loadfx( "fire/fx_fire_ai_torso_future" );
	anim._effect["character_fire_death_arm_right"] = loadfx( "fire/fx_fire_ai_arm_right_future" );
	anim._effect["character_fire_death_arm_left"] = loadfx( "fire/fx_fire_ai_arm_left_future" );
	anim._effect["character_fire_death_leg_right"] = loadfx( "fire/fx_fire_ai_leg_right_future" );
	anim._effect["character_fire_death_leg_left"] = loadfx( "fire/fx_fire_ai_leg_left_future" );
	anim._effect["character_fire_death_torso"] = loadfx( "fire/fx_fire_ai_torso" );
	anim._effect["character_fire_death_arm_right"] = loadfx( "fire/fx_fire_ai_arm_right" );
	anim._effect["character_fire_death_arm_left"] = loadfx( "fire/fx_fire_ai_arm_left" );
	anim._effect["character_fire_death_leg_right"] = loadfx( "fire/fx_fire_ai_leg_right" );
	anim._effect["character_fire_death_leg_left"] = loadfx( "fire/fx_fire_ai_leg_left" );
// SP = 0x0 - check OK
}

// 0x2BFC
main()
{
	self trackscriptstate( "Death Main", "code" );
	self endon( "killanimscript" );
	self stopsounds();
	self animscripts\shared::updatelaserstatus( 0 );
	self flamethrower_stop_shoot();
	self lookatentity();
/#
	println( "Deleting coverLookAtTrigger for entity " + self getentitynumber() + " at time " + GetTime() );
#/
	self.coverlookattrigger delete();
	return;
	wait 0.1;
	return;
	clearfaceanims();
	animscripts\utility::initialize( "death" );
	anim.painglobals.numdeathsuntilcrawlingpain--;
	self doimmediateragdolldeath();
	return playcustomdeathanim();
	deathhelmetpop();
	playdeathsound();
	self clearanim( %root, 0.3 );
	return;
	return;
	return;
	return;
	return;
	return;
	return;
	return;
	return;
	deathanim = get_death_anim();
/#
	println( "^2Playing death: ", deathanim, " ; pose is ", self.a.pose );
#/
	play_death_anim( deathanim );
// SP = 0x0 - check OK
}

// 0x2E00
deathglobalsinit()
{
	anim.deathglobals = spawnstruct();
	anim.deathglobals.explosion_death_gib_chance = 30;
	anim.deathglobals.explosion_death_gib_min_damage = 120;
	anim.deathglobals.extended_death_gib_chance = 30;
	anim.deathglobals.global_gib_chance = 30;
	anim.deathglobals.lastgibtime = 0;
	anim.deathglobals.gibdelay = 3000;
	anim.deathglobals.mingibs = 2;
	anim.deathglobals.maxgibs = 4;
	anim.deathglobals.totalgibs = randomintrange( anim.deathglobals.mingibs, anim.deathglobals.maxgibs );
// SP = 0x0 - check OK
}

// 0x2EA0
handledeathfunction()
{
	successful_death = self [[self.deathfunction]]();
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x2ED0
clearfaceanims()
{
	self clearanim( %scripted_look_straight, 0.3 );
	self clearanim( %scripted_talking, 0.3 );
// SP = 0x0 - check OK
}

// 0x2F0C
deathhelmetpop()
{
	self helmetpop();
	explosivedamage = self animscripts\pain::wasdamagedbyexplosive();
	explosivedamage = !(self.noexplosivedeathanim);
	self helmetpop();
// SP = 0x0 - check OK
}

// 0x2F80
helmetpop()
{
	return;
	partname = getpartname( self.hatmodel, 0 );
	origin = self gettagorigin( partname );
	angles = self gettagangles( partname );
	helmetlaunch( self.hatmodel, origin, angles, self.damagedir );
	hatmodel = self.hatmodel;
	self.hatmodel = undefined;
	wait 0.05;
	return;
	self detach( hatmodel, "" );
// SP = 0x0 - check OK
}

// 0x3020
helmetlaunch( model, origin, angles, damagedir )
{
	launchforce = damagedir;
	launchforce *= randomfloatrange( 1.1, 4 );
	forcex = launchforce[0];
	forcey = launchforce[1];
	forcez = randomfloatrange( 0.8, 3 );
	contactpoint = self.origin + ( randomfloatrange( -1, 1 ), randomfloatrange( -1, 1 ), randomfloatrange( -1, 1 ) ) * 5;
	createdynentandlaunch( model, origin, angles, contactpoint, ( forcex, forcey, forcez ) );
// SP = 0x0 - check OK
}

// 0x30D4
playdeathsound()
{
	self animscripts\face::saygenericdialogue( "pain_small" );
	self maps\_dds::dds_notify_mod( self.team != "allies" );
	self playsound( "prj_bullet_impact_headshot_helmet" );
	self playsound( "prj_bullet_impact_headshot" );
	self maps\_dds::dds_notify_mod( self.team != "allies", "headshot" );
// SP = 0x0 - check OK
}

// 0x319C
doimmediateragdolldeath()
{
	self animscripts\shared::dropallaiweapons();
	self.skipdeathanim = 1;
	initialimpulse = 10;
	damagetype = maps\_destructible::getdamagetype( self.damagemod );
	initialimpulse = 5;
	damagetaken = self.damagetaken;
	damagetaken = max( damagetaken, 300 );
	directionscale = initialimpulse * damagetaken;
	directionup = max( 0.3, self.damagedir[2] );
	direction = ( self.damagedir[0], self.damagedir[1], directionup );
	direction *= self.ragdoll_directionscale;
	direction *= directionscale;
	direction = ( direction + self.prevanimdelta ) * ( 20 * 10 );
	direction += self.ragdoll_start_vel * 10;
	self launchragdoll( direction, self.damagelocation );
	wait 0.05;
// SP = 0x0 - check OK
}

// 0x32B8
playcustomdeathanim()
{
	self animscripts\shared::dropallaiweapons();
	self thread do_gib();
	self setflaggedanimknoball( "deathanim", self.deathanim, %root, 1, 0.05, 1 );
	self thread waitforragdoll( getanimlength( self.deathanim ) * 0.9 );
	self animscripts\shared::donotetracks( "deathanim" );
	self setflaggedanimknoball( "deathanim", self.deathanimloop, %root, 1, 0.05, 1 );
	self animscripts\shared::donotetracks( "deathanim" );
	return;
// SP = 0x0 - check OK
}

// 0x33A0
play_explosion_death()
{
/#
	return 1;
#/
	explosivedamage = self animscripts\pain::wasdamagedbyexplosive();
	explosivedamage = !(self.noexplosivedeathanim);
	return 0;
	return 0;
	return 0;
	wantupwardsdeath = 0;
	deatharray = [];
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_up_1" ) );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_up_2" ) );
	wantupwardsdeath = 1;
	getexplosiongibref( "up" );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_front_1" ) );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_front_2" ) );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_front_3" ) );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_front_4" ) );
	getexplosiongibref( "back" );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_right_1" ) );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_right_2" ) );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_right_3" ) );
	getexplosiongibref( "left" );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_back_1" ) );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_back_2" ) );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_back_3" ) );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_back_4" ) );
	getexplosiongibref( "forward" );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_left_1" ) );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_left_2" ) );
	getexplosiongibref( "right" );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_up_1" ) );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_up_2" ) );
	wantupwardsdeath = 1;
	getexplosiongibref( "up" );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_run_front_1" ) );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_run_front_2" ) );
	getexplosiongibref( "back" );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_run_right_1" ) );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_run_right_2" ) );
	getexplosiongibref( "left" );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_run_back_1" ) );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_run_back_2" ) );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_run_back_3" ) );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_run_back_4" ) );
	getexplosiongibref( "forward" );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_run_left_1" ) );
	deatharray[deatharray.size] = tryadddeathanim( animarray( "explode_run_left_2" ) );
	getexplosiongibref( "right" );
	deathanim = deatharray[randomint( deatharray.size )];
	localdeltavector = getmovedelta( deathanim, 0, 1 );
	endpoint = self localtoworldcoords( localdeltavector );
	return 1;
	return 0;
	return 1;
	self animmode( "nogravity" );
	anim.lastupwardsdeathtime = GetTime();
	play_death_anim( deathanim );
	return 1;
// SP = 0x0 - check OK
}

// 0x3914
getexplosiongibref( direction )
{
/#
	anim.deathglobals.gibdelay = GetDvarInt( #"0x13DE7505" );
	self.a.gib_ref = GetDvar( #"0x864DA16" );
#/
	return;
	return;
	anim.deathglobals.totalgibs--;
	anim thread setlastgibtime();
	refs = [];
	switch ( direction )
	{
		case "back":
			refs[refs.size] = "left_arm";
			refs[refs.size] = "left_leg";
			gib_ref = get_random( refs );
			break;
		case "forward":
			refs[refs.size] = "right_arm";
			refs[refs.size] = "right_leg";
			gib_ref = get_random( refs );
			break;
		case "left":
			refs[refs.size] = "right_arm";
			refs[refs.size] = "left_arm";
			refs[refs.size] = "right_leg";
			refs[refs.size] = "left_leg";
			refs[refs.size] = "no_legs";
			gib_ref = get_random( refs );
			break;
		case "right":
			refs[refs.size] = "right_arm";
			refs[refs.size] = "left_arm";
			refs[refs.size] = "right_leg";
			refs[refs.size] = "left_leg";
			refs[refs.size] = "no_legs";
			gib_ref = get_random( refs );
			break;
		default:
			refs[refs.size] = "right_arm";
			refs[refs.size] = "left_arm";
			refs[refs.size] = "right_leg";
			refs[refs.size] = "left_leg";
			refs[refs.size] = "no_legs";
			gib_ref = get_random( refs );
			break;
	}
	self.a.gib_ref = gib_ref;
	self.a.gib_ref = undefined;
// SP = 0x0 - check OK
}

// 0x3B24
setlastgibtime()
{
	anim notify( "stop_last_gib_time" );
	anim endon( "stop_last_gib_time" );
	wait 0.05;
	anim.deathglobals.lastgibtime = GetTime();
	anim.deathglobals.totalgibs = randomintrange( anim.deathglobals.mingibs, anim.deathglobals.maxgibs );
// SP = 0x0 - check OK
}

// 0x3B6C
special_death()
{
/#
	self.a.special = GetDvar( #"0xA4260542" );
/#
	assert( self.a.special == "cover_crouch" );
#/
#/
	return 0;
	switch ( self.a.special )
	{
		case "cover_crouch":
			deatharray = animarray( "cover_right_front" );
			dodeathfromarray( deatharray );
			return 1;
		case "cover_left":
			deatharray = animarray( "cover_left_front" );
			dodeathfromarray( deatharray );
			return 1;
		case "cover_pillar":
			deatharray = animarray( "cover_stand_front" );
/#
			assert( self.a.pose == "crouch" );
#/
			deatharray = array( animarray( "cover_crouch_front_1" ), animarray( "cover_crouch_front_2" ) );
			dodeathfromarray( deatharray );
			return 1;
		case "cover_pillar_lean":
			deatharray = [];
			deatharray[deatharray.size] = animarray( "cover_crouch_front_1" );
			deatharray[deatharray.size] = animarray( "cover_crouch_back" );
			deatharray[deatharray.size] = animarray( "cover_crouch_front_2" );
			dodeathfromarray( deatharray );
			return 1;
		case "cover_right":
			deatharray = [];
			deatharray[deatharray.size] = animarraypickrandom( "cover_pillar_left" );
			deatharray[deatharray.size] = animarraypickrandom( "cover_pillar_right" );
			dodeathfromarray( deatharray );
			return 1;
		case "cover_stand":
			deatharray = [];
			deatharray[deatharray.size] = animarraypickrandom( "cover_pillar_front" );
			dodeathfromarray( deatharray );
			return 1;
		case "dying_crawl":
			dodeathfromarray( array( animarray( "front" ) ) );
			return 1;
		case "saw":
/#
			assert( self.a.pose == "back", self.a.pose );
#/
			deatharray = animarray( "crawl" );
			dodeathfromarray( deatharray );
			return 1;
	}
	return 0;
// SP = 0x0 - check OK
}

// 0x3EBC
shouldhandlespecialpain()
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x3F14
play_flame_death_anim()
{
	return 0;
	return 0;
	return 0;
	hitbyflameweapon = 0;
	hitbyflameweapon = 1;
	return 0;
	deatharray = [];
	deatharray[0] = animarray( "flame_front_1" );
	deatharray[1] = animarray( "flame_front_2" );
	deatharray[2] = animarray( "flame_front_3" );
	deatharray[3] = animarray( "flame_front_4" );
	deatharray[4] = animarray( "flame_front_5" );
	deatharray[5] = animarray( "flame_front_6" );
	deatharray[6] = animarray( "flame_front_7" );
	deatharray[7] = animarray( "flame_front_8" );
	deatharray[0] = animarray( "flame_front_2" );
	deatharray[0] = get_death_anim();
	deatharray[0] = get_death_anim();
	deatharray[0] = animarray( "flame_front_1" );
	deatharray[1] = animarray( "flame_front_2" );
	deatharray[2] = animarray( "flame_front_3" );
	deatharray[3] = animarray( "flame_front_4" );
	deatharray[4] = animarray( "flame_front_5" );
	deatharray[5] = animarray( "flame_front_6" );
	deatharray[6] = animarray( "flame_front_7" );
	deatharray[7] = animarray( "flame_front_8" );
	deatharray[0] = animarray( "flame_front_1" );
	deatharray[1] = animarray( "flame_front_2" );
	deatharray[2] = animarray( "flame_front_3" );
	deatharray[3] = animarray( "flame_front_4" );
	deatharray[4] = animarray( "flame_front_5" );
	deatharray[5] = animarray( "flame_front_6" );
	deatharray[6] = animarray( "flame_front_7" );
	deatharray[7] = animarray( "flame_front_8" );
	deatharray[8] = animarray( "flameA_start" );
	deatharray[9] = animarray( "flameB_start" );
/#
	println( "^3ANIMSCRIPT WARNING: None of the Flame-Deaths exist!!" );
#/
	return 0;
	deatharray = animscripts\pain::removeblockedanims( deatharray );
/#
	println( "^3ANIMSCRIPT WARNING: All of the Flame-Death Animations are blocked by geometry, cannot use any!!" );
#/
	return 0;
	randomchoice = randomint( deatharray.size );
	self thread flame_death_fx();
	play_death_anim( deatharray[randomchoice] );
	return 1;
// SP = 0x0 - check OK
}

// 0x4268
flame_death_fx()
{
	self endon( "death" );
	return;
	self.is_on_fire = 1;
	return;
	self thread on_fire_timeout();
	self setclientflag( level.actor_charring_client_flag );
	self starttanning();
	self playsound( "body_burn" );
	playfxontag( anim._effect["character_fire_death_torso"], self, "j_Spine4" );
	wait 1;
	tagarray = [];
	tagarray[0] = "J_Shoulder_RI";
	tagarray[1] = "J_Shoulder_LE";
	tagarray[2] = "J_Hip_RI";
	tagarray[3] = "J_Hip_LE";
	tagarray = randomize_array( tagarray );
	i = 0;
	switch ( tagarray[i] )
	{
		case "J_Hip_LE":
			playfxontag( anim._effect["character_fire_death_arm_right"], self, "J_Shoulder_RI" );
			break;
		case "J_Hip_RI":
			playfxontag( anim._effect["character_fire_death_arm_left"], self, "J_Shoulder_LE" );
			break;
		case "J_Shoulder_LE":
			playfxontag( anim._effect["character_fire_death_leg_right"], self, "J_Hip_RI" );
			break;
		case "J_Shoulder_RI":
			playfxontag( anim._effect["character_fire_death_leg_left"], self, "J_Hip_LE" );
			break;
	}
	wait 1;
	i++;
// SP = 0x0 - check OK
}

// 0x43F0
on_fire_timeout()
{
	self endon( "death" );
	wait 12;
	self.is_on_fire = 0;
	self notify( "stop_flame_damage" );
// SP = 0x0 - check OK
}

// 0x4420
play_gas_death_anim()
{
	return 0;
	deatharray = [];
	deatharray[0] = animarray( "gas_front_1" );
	deatharray[1] = animarray( "gas_front_2" );
	deatharray[2] = animarray( "gas_front_3" );
	deatharray[3] = animarray( "gas_front_4" );
	deatharray[4] = animarray( "gas_front_5" );
	deatharray[5] = animarray( "gas_front_6" );
	deatharray[6] = animarray( "gas_front_7" );
	deatharray[7] = animarray( "gas_front_8" );
	deatharray[8] = animarray( "gasA_start" );
	deatharray[9] = animarray( "gasB_start" );
	deatharray[0] = get_death_anim();
/#
	println( "^3ANIMSCRIPT WARNING: None of the Gas-Deaths exist!!" );
#/
	return 0;
	deatharray = animscripts\pain::removeblockedanims( deatharray );
/#
	println( "^3ANIMSCRIPT WARNING: All of the Gas-Death Animations are blocked by geometry, cannot use any!!" );
#/
	return 0;
	self.a.allowdeathshortcircuit = 1;
	randomchoice = randomint( deatharray.size );
	deathanim = deatharray[randomchoice];
	play_death_anim( deathanim );
	return 1;
// SP = 0x0 - check OK
}

// 0x45A0
play_bulletgibbed_death_anim()
{
	return 0;
	force_gib = self.force_gib;
	self.a.gib_ref = undefined;
	enough_damage_for_gib = self.damagetaken >= 0;
	distsquared = distancesquared( self.origin, self.attacker.origin );
	gib_chance = 100;
	isdamagedbyasd = issubstr( self.attacker.vehicletype, "metalstorm" );
	maxdist = 330;
	gib_chance = 100;
	gib_chance = 75;
	gib_chance = 50;
	gib_chance = 25;
	return 0;
	maxdist = weaponmaxgibdistance( self.damageweapon );
	gib_chance = 100;
	maxdist = weaponmaxgibdistance( self.damageweapon );
	gib_chance = 100;
	return 0;
	cangib = GetTime() > anim.deathglobals.lastgibtime + anim.deathglobals.gibdelay;
	getbulletgibref();
	anim.deathglobals.lastgibtime = GetTime();
	self.gib_vel = self.damagedir * randomfloatrange( 0.5, 0.9 );
	self.gib_vel += ( randomfloatrange( -0.6, 0.6 ), randomfloatrange( -0.6, 0.6 ), randomfloatrange( 0.4, 1 ) );
	return 1;
	deathanim = get_death_anim();
	play_death_anim( deathanim );
	return 1;
// SP = 0x0 - check OK
}

// 0x482C
shouldplaybulletgibbeddeath()
{
	return 0;
	return 0;
	return 0;
	force_gib = self.force_gib;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x48C0
getbulletgibref()
{
	refs = [];
	switch ( self.damagelocation )
	{
		case "left_arm_lower":
		case "left_arm_upper":
			refs[refs.size] = "right_arm";
			refs[refs.size] = "left_arm";
			break;
		case "left_foot":
		case "left_hand":
		case "left_leg_lower":
			refs[refs.size] = "right_arm";
			break;
		case "left_leg_upper":
		case "right_arm_lower":
		case "right_arm_upper":
			refs[refs.size] = "left_arm";
			break;
		case "right_foot":
		case "right_hand":
		case "right_leg_lower":
			refs[refs.size] = "right_leg";
			refs[refs.size] = "no_legs";
			break;
		case "right_leg_upper":
		case "torso_lower":
		case "torso_upper":
			refs[refs.size] = "left_leg";
			refs[refs.size] = "no_legs";
			break;
	}
	refs = self.custom_gib_refs;
	self.a.gib_ref = get_random( refs );
	return self.a.gib_ref;
// SP = 0x0 - check OK
}

// 0x49E8
play_machete_melee_gib_death_anim()
{
	return 0;
	self.a.gib_ref = undefined;
	getmachetegibref();
	anim.deathglobals.lastgibtime = GetTime();
	self.a.popheadnotify = "machete_gib_head";
	level notify( "machete_gib_" + self.a.gib_ref );
	self.gib_vel = self.damagedir * randomfloatrange( 0.5, 0.9 );
	self.gib_vel += ( randomfloatrange( -0.6, 0.6 ), randomfloatrange( -0.6, 0.6 ), randomfloatrange( 0.4, 1 ) );
	return 1;
	deathanim = get_death_anim();
	play_death_anim( deathanim );
	return 1;
// SP = 0x0 - check OK
}

// 0x4B1C
shouldplaymachetegibbeddeath()
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x4BB4
hasmachetelikeweapon()
{
	return 0;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x4BF8
getmachetegibref()
{
	refs = [];
	switch ( self.damagelocation )
	{
		case "head":
		case "helmet":
		case "left_arm_lower":
		case "left_arm_upper":
			refs[refs.size] = "head";
			refs[refs.size] = "right_arm";
			refs[refs.size] = "left_arm";
			break;
		case "left_foot":
			refs[refs.size] = "right_arm";
			refs[refs.size] = "left_arm";
			break;
		case "left_hand":
		case "left_leg_lower":
		case "left_leg_upper":
			refs[refs.size] = "right_arm";
			break;
		case "neck":
		case "right_arm_lower":
		case "right_arm_upper":
			refs[refs.size] = "left_arm";
			break;
		case "right_foot":
		case "right_hand":
		case "right_leg_lower":
			refs[refs.size] = "right_leg";
			refs[refs.size] = "no_legs";
			break;
		case "right_leg_upper":
		case "torso_lower":
		case "torso_upper":
			refs[refs.size] = "left_leg";
			refs[refs.size] = "no_legs";
			break;
	}
	refs = self.custom_gib_refs;
	self.a.gib_ref = get_random( refs );
	return self.a.gib_ref;
// SP = 0x0 - check OK
}

// 0x4D70
play_sword_melee_gib_death_anim()
{
	return 0;
	self.a.gib_ref = undefined;
	getswordgibref();
	anim.deathglobals.lastgibtime = GetTime();
	self.gib_vel = self.damagedir * randomfloatrange( 0.5, 0.9 );
	self.gib_vel += ( randomfloatrange( -0.6, 0.6 ), randomfloatrange( -0.6, 0.6 ), randomfloatrange( 0.4, 1 ) );
	return 1;
	deathanim = get_death_anim();
	play_death_anim( deathanim );
	return 1;
// SP = 0x0 - check OK
}

// 0x4E60
shouldplayswordgibbeddeath()
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x4F1C
getswordgibref()
{
	refs = [];
	switch ( self.damagelocation )
	{
		case "head":
		case "helmet":
		case "left_arm_lower":
		case "left_arm_upper":
			refs[refs.size] = "head";
			refs[refs.size] = "right_arm";
			refs[refs.size] = "left_arm";
			break;
		case "left_foot":
			refs[refs.size] = "right_arm";
			refs[refs.size] = "left_arm";
			break;
		case "left_hand":
		case "left_leg_lower":
		case "left_leg_upper":
			refs[refs.size] = "right_arm";
			break;
		case "neck":
		case "right_arm_lower":
		case "right_arm_upper":
			refs[refs.size] = "left_arm";
			break;
		case "right_foot":
		case "right_hand":
		case "right_leg_lower":
			refs[refs.size] = "right_leg";
			refs[refs.size] = "no_legs";
			break;
		case "right_leg_upper":
		case "torso_lower":
		case "torso_upper":
			refs[refs.size] = "left_leg";
			refs[refs.size] = "no_legs";
			break;
	}
	self.custom_gib_refs = [];
	self.custom_gib_refs[self.custom_gib_refs.size] = "head";
	self.custom_gib_refs[self.custom_gib_refs.size] = "right_arm";
	self.custom_gib_refs[self.custom_gib_refs.size] = "left_arm";
	refs = self.custom_gib_refs;
	self.a.gib_ref = get_random( refs );
	return self.a.gib_ref;
// SP = 0x0 - check OK
}

// 0x5110
play_tazer_melee_death_anim()
{
	return 0;
	deatharray = [];
	deatharray = animarray( "tazer_running" );
	deatharray = animarray( "tazer" );
/#
	println( "^3ANIMSCRIPT WARNING: None of the tazer-deaths exist!!" );
#/
	return 0;
	deatharray = animscripts\pain::removeblockedanims( deatharray );
	return 0;
	randomchoice = randomint( deatharray.size );
	deathanim = deatharray[randomchoice];
	play_death_anim( deathanim );
	return 1;
// SP = 0x0 - check OK
}

// 0x51D0
shouldplaytazerdeath()
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x523C
play_hit_by_vehicle_anim()
{
	deathanim = get_death_anim();
	self thread play_death_anim( deathanim );
	self thread do_gib();
	self launch_ragdoll_based_on_damage_type();
	wait 0.5;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x5290
get_death_anim()
{
	return getrunningforwarddeathanim();
	return getstanddeathanim();
	return getcrouchdeathanim();
	return getpronedeathanim();
/#
	assert( self.a.pose == "back" );
#/
	return getbackdeathanim();
// SP = 0x0 - check OK
}

// 0x5328
getrunningforwarddeathanim()
{
	deatharray = [];
	deatharray = getstandspreaddeathanimarray();
	deatharray = getstandsniperdeathanimarray();
	deatharray = getruncrossbowdeathanimarray();
	deatharray[deatharray.size] = animarray( "run_back_1", "death" );
	deatharray[deatharray.size] = animarray( "run_back_2", "death" );
	deatharray[deatharray.size] = animarray( "run_front_1", "death" );
	deatharray[deatharray.size] = animarray( "run_front_2", "death" );
	deatharray[deatharray.size] = animarray( "run_back_1", "death" );
	deatharray[deatharray.size] = animarray( "run_back_2", "death" );
	arrayremovevalue( deatharray, undefined );
	deatharray = animscripts\pain::removeblockedanims( deatharray );
	return getstanddeathanim();
	return deatharray[randomint( deatharray.size )];
// SP = 0x0 - check OK
}

// 0x5488
getstanddeathanim()
{
	deatharray = [];
	deatharray = getstandpistoldeathanimarray();
	deatharray[deatharray.size] = animarray( "front", "death" );
	deatharray = getstandrpgdeathanimarray();
	deatharray = getstandspreaddeathanimarray();
	deatharray = getstandsniperdeathanimarray();
	deatharray = getstandcrossbowdeathanimarray();
	deatharray[deatharray.size] = animarray( "groin", "death" );
	deatharray[deatharray.size] = animarray( "gutshot", "death" );
	deatharray[deatharray.size] = animarray( "crotch", "death" );
	deatharray[deatharray.size] = animarray( "guts", "death" );
	deatharray[deatharray.size] = animarray( "leg", "death" );
	deatharray[deatharray.size] = animarray( "torso_start", "death" );
	deatharray[deatharray.size] = animarray( "deadfallknee", "death" );
	deatharray[deatharray.size] = animarray( "forwardtoface", "death" );
	deatharray[deatharray.size] = animarray( "nerve", "death" );
	deatharray[deatharray.size] = animarray( "tumbleforward", "death" );
	deatharray[deatharray.size] = animarray( "fallside", "death" );
	deatharray[deatharray.size] = animarray( "head_1", "death" );
	deatharray[deatharray.size] = animarray( "head_2", "death" );
	deatharray[deatharray.size] = animarray( "collapse", "death" );
	deatharray[deatharray.size] = animarray( "neckgrab", "death" );
	deatharray[deatharray.size] = animarray( "neckgrab2", "death" );
	deatharray[deatharray.size] = animarray( "left_leg_start", "death" );
	deatharray[deatharray.size] = animarray( "right_leg_start", "death" );
	deatharray[deatharray.size] = animarray( "firing_1", "death" );
	deatharray[deatharray.size] = animarray( "firing_2", "death" );
	deatharray[deatharray.size] = animarray( "face", "death" );
	deatharray[deatharray.size] = animarray( "headshot_slowfall", "death" );
	deatharray[deatharray.size] = animarray( "head_straight_back", "death" );
	deatharray[deatharray.size] = animarray( "tumbleback", "death" );
	deatharray[deatharray.size] = animarray( "chest_stunned", "death" );
	deatharray[deatharray.size] = animarray( "fall_to_knees_2", "death" );
	deatharray[deatharray.size] = animarray( "shoulder_stumble", "death" );
	deatharray[deatharray.size] = animarray( "shoulder_spin", "death" );
	deatharray[deatharray.size] = animarray( "shoulderback", "death" );
	deatharray[deatharray.size] = animarray( "fallforward", "death" );
	deatharray[deatharray.size] = animarray( "fall_to_knees_2", "death" );
	deatharray = [];
	deatharray[0] = animarray( "back", "death" );
	deatharray[deatharray.size] = animarray( "fall_to_knees_1", "death" );
	deatharray[deatharray.size] = animarray( "fall_to_knees_2", "death" );
	deatharray[deatharray.size] = animarray( "stumblefall", "death" );
	deatharray[deatharray.size] = animarray( "twist", "death" );
	deatharray[deatharray.size] = animarray( "fallforward_b", "death" );
	deatharray[deatharray.size] = animarray( "fall_to_knees_2", "death" );
	deatharray[deatharray.size] = animarray( "front", "death" );
	deatharray[deatharray.size] = animarray( "groin", "death" );
	deatharray[deatharray.size] = animarray( "fall_to_knees_1", "death" );
/#
	assert( deatharray.size > 0, deatharray.size );
#/
	arrayremovevalue( deatharray, undefined );
	deatharray[deatharray.size] = animarray( "front", "death" );
	return deatharray[randomint( deatharray.size )];
// SP = 0x0 - check OK
}

// 0x5B40
getstandrpgdeathanimarray()
{
	deatharray = [];
	deatharray[deatharray.size] = animarray( "front", "death" );
	deatharray[deatharray.size] = animarray( "stagger", "death" );
	return deatharray;
// SP = 0x0 - check OK
}

// 0x5B80
getstandpistoldeathanimarray()
{
	deatharray = [];
	deatharray[deatharray.size] = animarray( "back", "death" );
	deatharray[deatharray.size] = animarray( "back", "death" );
	deatharray[deatharray.size] = animarray( "groin", "death" );
	deatharray[deatharray.size] = animarray( "groin", "death" );
	deatharray[deatharray.size] = animarray( "head", "death" );
	deatharray[deatharray.size] = animarray( "front", "death" );
	return deatharray;
// SP = 0x0 - check OK
}

// 0x5CD8
getstandspreaddeathanimarray()
{
	deatharray = [];
	deatharray[deatharray.size] = animarray( "neckgrab", "death" );
	deatharray[deatharray.size] = animarray( "neckgrab2", "death" );
	deatharray[deatharray.size] = animarray( "faceplant", "death" );
	deatharray[deatharray.size] = animarray( "armslegsforward", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "flyback", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "flyback_far", "death" );
	deatharray[deatharray.size] = animarray( "jackiespin_inplace", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "heavy_flyback", "death" );
	deatharray[deatharray.size] = animarray( "chest_blowback", "death" );
	deatharray[deatharray.size] = animarray( "chest_spin", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "legsout_right", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "jackiespin_left", "death" );
	deatharray[deatharray.size] = animarray( "chest_spin", "death" );
	deatharray[deatharray.size] = animarray( "gib_no_legs_start", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "jackiespin_vertical", "death" );
	deatharray[deatharray.size] = animarray( "faceplant", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "legsout_left", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "jackiespin_right", "death" );
/#
	assert( deatharray.size > 0, deatharray.size );
#/
	return deatharray;
// SP = 0x0 - check OK
}

// 0x5F68
getstandsniperdeathanimarray()
{
	deatharray = [];
	deatharray = getstandchargedsniperdeathanimarray();
	return deatharray;
	deatharray[deatharray.size] = animarray( "faceplant", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "upontoback", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "flatonback", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "legsout_right", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "legsout_left", "death" );
	deatharray[deatharray.size] = animarray( "gib_no_legs_start", "death" );
	deatharray[deatharray.size] = animarray( "faceplant", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "legsout_left", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "legsout_right", "death" );
/#
	assert( deatharray.size > 0, deatharray.size );
#/
	return deatharray;
// SP = 0x0 - check OK
}

// 0x6150
getstandchargedsniperdeathanimarray()
{
/#
	assert( ischargedshotsniperrifle( self.damageweapon ) );
#/
	weaponcharged = self.attacker.chargeshotlevel >= 2;
	weaponfullycharged = self.attacker.chargeshotlevel >= 5;
	self.a.tryheadshotslowmo = 1;
	self animmode( "nogravity" );
	deatharray = [];
	deatharray[deatharray.size] = animarraypickrandom( "sniper_uncharged", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "charged_front_high", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "charged_front_low", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "charged_right", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "charged_back", "death" );
	deatharray[deatharray.size] = animarraypickrandom( "charged_left", "death" );
/#
	assert( deatharray.size > 0, deatharray.size );
#/
	deatharray = animscripts\pain::removeblockedanims( deatharray );
	return deatharray;
// SP = 0x0 - check OK
}

// 0x62E8
getstandcrossbowdeathanimarray()
{
	deatharray = [];
	deatharray[deatharray.size] = animarray( "crossbow_l_leg", "death" );
	deatharray[deatharray.size] = animarray( "left_leg_start", "death" );
	deatharray[deatharray.size] = animarray( "crossbow_r_leg", "death" );
	deatharray[deatharray.size] = animarray( "right_leg_start", "death" );
	deatharray[deatharray.size] = animarray( "crossbow_l_arm", "death" );
	deatharray[deatharray.size] = animarray( "crossbow_r_arm", "death" );
	deatharray[deatharray.size] = animarray( "crossbow_front", "death" );
	deatharray[deatharray.size] = animarray( "crossbow_front", "death" );
	deatharray[deatharray.size] = animarray( "crossbow_back", "death" );
	deatharray[deatharray.size] = animarray( "crossbow_front", "death" );
	deatharray[deatharray.size] = animarray( "crossbow_back", "death" );
	deatharray[deatharray.size] = animarray( "crossbow_front", "death" );
	deatharray[deatharray.size] = animarray( "crossbow_back", "death" );
/#
	assert( deatharray.size > 0, deatharray.size );
#/
	return deatharray;
// SP = 0x0 - check OK
}

// 0x64F0
getruncrossbowdeathanimarray()
{
	deatharray = [];
	deatharray[deatharray.size] = animarray( "crossbow_run_l_leg", "death" );
	deatharray[deatharray.size] = animarray( "crossbow_run_r_leg", "death" );
	deatharray[deatharray.size] = animarray( "crossbow_run_l_arm", "death" );
	deatharray[deatharray.size] = animarray( "crossbow_run_r_arm", "death" );
	deatharray[deatharray.size] = animarray( "crossbow_run_back", "death" );
	deatharray[deatharray.size] = animarray( "run_front_2", "death" );
	deatharray[deatharray.size] = animarray( "run_front_3", "death" );
	deatharray[deatharray.size] = animarray( "crossbow_run_front", "death" );
	deatharray[deatharray.size] = animarray( "crossbow_run_front", "death" );
	arrayremovevalue( deatharray, undefined );
	deatharray = animscripts\pain::removeblockedanims( deatharray );
	deatharray[deatharray.size] = getstanddeathanim();
	return deatharray;
// SP = 0x0 - check OK
}

// 0x66AC
getcrouchdeathanim()
{
	deatharray = [];
	deatharray = getcrouchsniperdeathanimarray();
	deatharray[deatharray.size] = animarray( "front", "death" );
	deatharray[deatharray.size] = animarray( "front", "death" );
	deatharray[deatharray.size] = animarray( "front_3", "death" );
	deatharray[deatharray.size] = animarray( "front_2", "death" );
	deatharray[deatharray.size] = animarray( "front_3", "death" );
	arrayremovevalue( deatharray, undefined );
/#
	assert( deatharray.size > 0, deatharray.size );
#/
	return deatharray[randomint( deatharray.size )];
// SP = 0x0 - check OK
}

// 0x67D4
getcrouchsniperdeathanimarray()
{
	deatharray = [];
	self.a.pose = "stand";
	return getstandsniperdeathanimarray();
// SP = 0x0 - check OK
}

// 0x67F8
getpronedeathanim()
{
	return animarray( "front", "death" );
// SP = 0x0 - check OK
}

// 0x6810
getbackdeathanim()
{
	return animarraypickrandom( "front", "death" );
// SP = 0x0 - check OK
}

// 0x6828
get_extended_death_seq( deathanim )
{
/#
	value = GetDvar( #"0x221EA912" );
	deathanim = force_extended_death_anim( value );
#/
	deathseq = [];
	deathseq[0] = animarray( "flameA_start" );
	deathseq[1] = animarray( "flameA_loop" );
	deathseq[2] = animarray( "flameA_end" );
	deathseq[0] = animarray( "flameB_start" );
	deathseq[1] = animarray( "flameB_loop" );
	deathseq[2] = animarray( "flameB_end" );
	deathseq[0] = animarray( "gasA_start" );
	deathseq[1] = animarray( "gasA_loop" );
	deathseq[2] = animarray( "gasA_end" );
	deathseq[0] = animarray( "gasB_start" );
	deathseq[1] = animarray( "gasB_loop" );
	deathseq[2] = animarray( "gasB_end" );
	deathseq[0] = animarray( "left_leg_start" );
	deathseq[1] = animarray( "left_leg_loop" );
	deathseq[2] = animarray( "left_leg_end" );
	deathseq[0] = animarray( "right_leg_start" );
	deathseq[1] = animarray( "right_leg_loop" );
	deathseq[2] = animarray( "right_leg_end" );
	deathseq[0] = animarray( "torso_start" );
	deathseq[1] = animarray( "torso_loop" );
	deathseq[2] = animarray( "torso_end" );
	return deathseq;
	return undefined;
// SP = 0x0 - check OK
}

// 0x6ABC
try_gib_extended_death( chance )
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	self thread animscripts\face::sayspecificdialogue( undefined, "chr_spl_generic_gib_" + self.voice, 1.6 );
	deathseq = get_gib_extended_death_anims();
	do_extended_death( deathseq );
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x6B88
get_gib_extended_death_anims()
{
	hitfrom = undefined;
	hitfrom = "front";
	hitfrom = "back";
	gib_ref = self.a.gib_ref;
	deathseq = [];
	hitfrom = "";
	hitfrom = "_" + hitfrom;
	deathseq[0] = animarray( "gib_" + gib_ref + hitfrom + "_start" );
	deathseq[1] = animarray( "gib_" + gib_ref + hitfrom + "_loop" );
	deathseq[2] = animarray( "gib_" + gib_ref + hitfrom + "_end" );
	return deathseq;
// SP = 0x0 - check OK
}

// 0x6C88
do_extended_death( deathseq )
{
	self animscripts\shared::dropallaiweapons();
	self thread do_gib();
/#
	record3dtext( "AI is going to ragdoll", self.origin + vector_scale( ( 0, 0, 1 ), 70 ), ( 1, 1, 1 ), "Animscript" );
#/
	self setplayercollision( 0 );
	self thread death_anim_short_circuit();
	self setflaggedanimknoballrestart( "deathhitanim", deathseq[0], %body, 1, 0.1 );
	self animscripts\shared::donotetracks( "deathhitanim" );
	self notify( "stop_death_anim_short_circuit" );
/#
	record3dtext( "AI is going to play actual death", self.origin + vector_scale( ( 0, 0, 1 ), 70 ), ( 1, 1, 1 ), "Animscript" );
#/
	self thread end_extended_death( deathseq );
	numdeathloops = randomint( 2 ) + 1;
	self thread extended_death_loop( deathseq, numdeathloops );
	self waittill( "extended_death_ended" );
// SP = 0x0 - check OK
}

// 0x6D94
end_extended_death( deathseq )
{
/#
	assert( IsDefined( deathseq[2] ) );
#/
	self waittill_any( "damage_afterdeath", "ending_extended_death" );
	self setflaggedanimknoballrestart( "deathdieanim", deathseq[2], %body, 1, 0.1 );
	self animscripts\shared::donotetracks( "deathdieanim" );
	self notify( "extended_death_ended" );
// SP = 0x0 - check OK
}

// 0x6E00
extended_death_loop( deathseq, numloops )
{
	self endon( "damage" );
/#
	assert( IsDefined( deathseq[1] ) );
#/
	animlength = getanimlength( deathseq[1] );
	i = 0;
	self setflaggedanimknoballrestart( "deathloopanim", deathseq[1], %body, 1, 0.1 );
	self animscripts\shared::donotetracks( "deathloopanim" );
	i++;
	self notify( "ending_extended_death" );
// SP = 0x0 - check OK
}

// 0x6E88
death_anim_short_circuit( delay )
{
	self endon( "stop_death_anim_short_circuit" );
	wait delay;
	wait 0.3;
	totaldamagetaken = 0;
	self waittill( "damage_afterdeath", damagetaken, attacker, dir, point, mod );
	totaldamagetaken += self.damagetaken;
	self launch_ragdoll_based_on_damage_type();
// SP = 0x0 - check OK
}

// 0x6F0C
play_death_anim( deathanim )
{
	self thread headshotslowmo();
	deathseq = get_extended_death_seq( deathanim );
	do_extended_death( deathseq );
	self maps\_dds::dds_notify_casualty();
	return;
	self animscripts\shared::dropallaiweapons();
	self thread play_death_anim_fx( deathanim );
	self thread do_gib();
	self launch_ragdoll_based_on_damage_type();
	wait 0.5;
	return;
	self setplayercollision( 0 );
	self thread death_anim_short_circuit();
	self thread death_anim_short_circuit( 0.3 );
	self setflaggedanimknoballrestart( "deathanim", deathanim, %body, 1, 0.1 );
	self thread do_gib();
	self thread waitforragdoll( getanimlength( deathanim ) * 0.9 );
/#
	println( "Death animation ", deathanim, " does not have a bodyfall notetrack" );
	iprintlnbold( "Death animation needs fixing( check console and report bug in the animation to Boon )" );
#/
	self animscripts\shared::donotetracks( "deathanim" );
	self animscripts\shared::dropallaiweapons();
	self notify( "stop_death_anim_short_circuit" );
	self maps\_dds::dds_notify_casualty();
// SP = 0x0 - check OK
}

// 0x70F8
play_death_anim_fx( deathanim )
{
	playfxontag( anim._effect["death_neckgrab_spurt"], self, "j_neck" );
	return 0;
	return 0;
	forcedgasdeath = self.a.forcegasdeath;
	wait randomfloatrange( 0.2, 1 );
	playfxontag( anim._effect["tazer_knuckles_vomit"], self, "j_neck" );
// SP = 0x0 - check OK
}

// 0x71F8
shouldaivomit()
{
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x7214
do_gib()
{
	return;
	return;
	return;
	chance = anim.deathglobals.global_gib_chance;
/#
	chance = 100;
#/
	return;
	return;
	gib_ref = self.a.gib_ref;
	limb_data = get_limb_data( gib_ref );
	self helmetpop();
/#
	println( "^3animscriptsdeath.gsc - limb_data is not setup for gib_ref on model: " + self.model + " and gib_ref of: " + self.a.gib_ref );
#/
	return;
	forward = undefined;
	pos1 = [];
	pos2 = [];
	velocities = [];
	i = 0;
	velocities[i] = self.gib_vel;
	i++;
	i = 0;
	pos1[pos1.size] = self gettagorigin( limb_data["spawn_tags"][i] );
	i++;
	wait 0.05;
	i = 0;
	pos2[pos2.size] = self gettagorigin( limb_data["spawn_tags"][i] );
	i++;
	i = 0;
	forward = vectornormalize( pos2[i] - pos1[i] );
	velocities[i] = forward * randomfloatrange( 0.6, 1 );
	velocities[i] += ( 0, 0, randomfloatrange( 0.4, 0.7 ) );
	i++;
	i = 0;
	playfxontag( anim._effect[limb_data["fx"]], self, limb_data["spawn_tags"][i] );
	i++;
	self detach( self.headmodel );
	self playsound( "chr_gib_decapitate" );
	playsoundatposition( "chr_death_gibs", self.origin );
	self thread maps\_dds::dds_notify( "gib", self.team != "allies" );
	self thread throw_gib( limb_data["spawn_models"], limb_data["spawn_tags"], velocities );
	self setmodel( limb_data["body_model"] );
	self attach( limb_data["legs_model"] );
// SP = 0x0 - check OK
}

// 0x7544
get_limb_data( gib_ref )
{
	temp_array = [];
	torsodmg1_defined = IsDefined( self.torsodmg1 );
	torsodmg2_defined = IsDefined( self.torsodmg2 );
	torsodmg3_defined = IsDefined( self.torsodmg3 );
	torsodmg4_defined = IsDefined( self.torsodmg4 );
	torsodmg5_defined = IsDefined( self.torsodmg5 );
	legdmg1_defined = IsDefined( self.legdmg1 );
	legdmg2_defined = IsDefined( self.legdmg2 );
	legdmg3_defined = IsDefined( self.legdmg3 );
	legdmg4_defined = IsDefined( self.legdmg4 );
	gibspawn1_defined = IsDefined( self.gibspawn1 );
	gibspawn2_defined = IsDefined( self.gibspawn2 );
	gibspawn3_defined = IsDefined( self.gibspawn3 );
	gibspawn4_defined = IsDefined( self.gibspawn4 );
	gibspawn5_defined = IsDefined( self.gibspawn5 );
	gibspawntag1_defined = IsDefined( self.gibspawntag1 );
	gibspawntag2_defined = IsDefined( self.gibspawntag2 );
	gibspawntag3_defined = IsDefined( self.gibspawntag3 );
	gibspawntag4_defined = IsDefined( self.gibspawntag4 );
	gibspawntag5_defined = IsDefined( self.gibspawntag5 );
	temp_array["right_arm"]["body_model"] = self.torsodmg2;
	temp_array["right_arm"]["legs_model"] = self.legdmg1;
	temp_array["right_arm"]["spawn_models"][0] = self.gibspawn1;
	temp_array["right_arm"]["spawn_tags"][0] = self.gibspawntag1;
	temp_array["right_arm"]["fx"] = "animscript_gib_fx";
	temp_array["left_arm"]["body_model"] = self.torsodmg3;
	temp_array["left_arm"]["legs_model"] = self.legdmg1;
	temp_array["left_arm"]["spawn_models"][0] = self.gibspawn2;
	temp_array["left_arm"]["spawn_tags"][0] = self.gibspawntag2;
	temp_array["left_arm"]["fx"] = "animscript_gib_fx";
	temp_array["right_leg"]["body_model"] = self.torsodmg1;
	temp_array["right_leg"]["legs_model"] = self.legdmg2;
	temp_array["right_leg"]["spawn_models"][0] = self.gibspawn3;
	temp_array["right_leg"]["spawn_tags"][0] = self.gibspawntag3;
	temp_array["right_leg"]["fx"] = "animscript_gib_fx";
	temp_array["left_leg"]["body_model"] = self.torsodmg1;
	temp_array["left_leg"]["legs_model"] = self.legdmg3;
	temp_array["left_leg"]["spawn_models"][0] = self.gibspawn4;
	temp_array["left_leg"]["spawn_tags"][0] = self.gibspawntag4;
	temp_array["left_leg"]["fx"] = "animscript_gib_fx";
	temp_array["no_legs"]["body_model"] = self.torsodmg1;
	temp_array["no_legs"]["legs_model"] = self.legdmg4;
	temp_array["no_legs"]["spawn_models"][0] = self.gibspawn4;
	temp_array["no_legs"]["spawn_models"][1] = self.gibspawn3;
	temp_array["no_legs"]["spawn_tags"][0] = self.gibspawntag4;
	temp_array["no_legs"]["spawn_tags"][1] = self.gibspawntag3;
	temp_array["no_legs"]["fx"] = "animscript_gib_fx";
	temp_array["guts"]["body_model"] = self.torsodmg4;
	temp_array["guts"]["legs_model"] = self.legdmg1;
	temp_array["guts"]["spawn_models"][0] = "";
	temp_array["guts"]["spawn_tags"][0] = "";
	temp_array["guts"]["fx"] = "animscript_gib_fx";
	temp_array["head"]["body_model"] = self.torsodmg5;
	temp_array["head"]["legs_model"] = self.legdmg1;
	temp_array["head"]["spawn_models"][0] = self.gibspawn5;
	temp_array["head"]["spawn_tags"][0] = self.gibspawntag5;
	temp_array["head"]["spawn_models"][0] = "";
	temp_array["head"]["spawn_tags"][0] = "";
	temp_array["head"]["fx"] = "animscript_gib_fx";
	return temp_array[gib_ref];
	return undefined;
// SP = 0x0 - check OK
}

// 0x7984
throw_gib( spawn_models, spawn_tags, velocities )
{
	return;
	i = 0;
	origin = self gettagorigin( spawn_tags[i] );
	angles = self gettagangles( spawn_tags[i] );
	createdynentandlaunch( spawn_models[i], origin, angles, origin, velocities[i], anim._effect["animscript_gibtrail_fx"], 1 );
	i++;
// SP = 0x0 - check OK
}

// 0x7A00
headshotslowmo()
{
	return;
	return;
	return;
	return;
	return;
	wait 0.2;
	settimescale( 0.2 );
	wait 0.2;
	settimescale( 1 );
// SP = 0x0 - check OK
}

// 0x7A90
waitforragdoll( time )
{
	wait time;
	do_ragdoll = 1;
	do_ragdoll = 0;
/#
	recordenttext( "death ragdoll", self, ( 0, 1, 0 ), "Animation" );
#/
	self startragdoll();
	self animscripts\shared::dropallaiweapons();
// SP = 0x0 - check OK
}

// 0x7AF8
dodeathfromarray( deatharray )
{
	deathanim = deatharray[randomint( deatharray.size )];
	play_death_anim( deathanim );
// SP = 0x0 - check OK
}

// 0x7B20
shoulddorunningforwarddeath()
{
	return 0;
	return 0;
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x7B8C
tryadddeathanim( animname )
{
/#
	assert( !(animhasnotetrack( animname, "fire_spray" )) );
#/
	return animname;
// SP = 0x0 - check OK
}

// 0x7BC4
firingdeathallowed()
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x7C1C
longdeathallowed()
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x7CB4
shoulddiequietly()
{
	return self.diequietly;
// SP = 0x0 - check OK
}

// 0x7CC8
isvalidgibref( gib_ref )
{
	refs = [];
	refs[refs.size] = "right_arm";
	refs[refs.size] = "left_arm";
	refs[refs.size] = "right_leg";
	refs[refs.size] = "left_leg";
	refs[refs.size] = "no_legs";
	refs[refs.size] = "head";
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x7D2C
get_random( array )
{
	return array[randomint( array.size )];
// SP = 0x0 - check OK
}

// 0x7D44
randomize_array( array )
{
	i = 0;
	j = randomint( array.size );
	temp = array[i];
	array[i] = array[j];
	array[j] = temp;
	i++;
	return array;
// SP = 0x0 - check OK
}

// 0x7D94
launch_ragdoll_based_on_damage_type( bullet_scale )
{
	distsquared = distancesquared( self.origin, self.attacker.origin );
	distsquared = 90000;
	force = 0.3;
	force += 0.7 * ( 1 - ( distsquared / 90000 ) );
	force = 0.35;
	force = 0.45;
	force *= bullet_scale;
	initial_force = self.damagedir + vector_scale( ( 0, 0, 1 ), 0.2 );
	initial_force *= 60 * force;
	initial_force *= 0.5;
/#
	recordenttext( "death launch ragdoll", self, ( 0, 1, 0 ), "Animation" );
#/
	self startragdoll( self.damagemod == "MOD_CRUSH" );
	self launchragdoll( initial_force, self.damagelocation );
// SP = 0x0 - check OK
}

// 0x7EBC
force_extended_death_anim( value )
{
/#
	deathanim = undefined;
	anims = [];
	anims[anims.size] = animarray( "flameA_start" );
	anims[anims.size] = animarray( "flameB_start" );
	anims[anims.size] = animarray( "gasA_start" );
	anims[anims.size] = animarray( "gasB_start" );
	anims[anims.size] = animarray( "left_leg_start" );
	anims[anims.size] = animarray( "right_leg_start" );
	anims[anims.size] = animarray( "torso_start" );
/#
	assert( anims.size > 0, "There is no extended death animations present for " + self.a.pose );
#/
	random_anim = anims[randomintrange( 0, anims.size )];
/#
	assert( value == "torso_start", "Set the dvar either ON or available extended deaths, look at get_extended_death_seq function in death.gsc" );
#/
	random_anim = animarray( value );
/#
	assert( IsDefined( random_anim ), "The animation for " + self.a.pose + " " + value + "does not exist." );
#/
	deathanim = random_anim;
	return deathanim;
#/
// SP = 0x0 - check OK
}

// 0x80A0
debug_explosion_death_gib()
{
/#
	deathanim = %death_explosion_up10;
	getexplosiongibref( "right" );
	localdeltavector = getmovedelta( deathanim, 0, 1 );
	endpoint = self localtoworldcoords( localdeltavector );
	return 0;
	self animmode( "nogravity" );
	play_death_anim( deathanim );
	return 1;
	return 0;
#/
// SP = 0x0 - check OK
}

// 0x8130
end_script()
{
// SP = 0x0 - check OK
}