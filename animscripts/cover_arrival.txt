// animscripts/cover_arrival.gsc

#include animscripts\cover_arrival;
#include animscripts\cqb;
#include animscripts\run;
#include maps\_dds;
#include animscripts\shared;
#include maps\_utility;
#include common_scripts\utility;
#include animscripts\anims;
#include animscripts\debug;
#include animscripts\utility;
#include animscripts\combat_utility;
#include animscripts\setposemovement;

#using_animtree ( "generic_human" );


// 0x233C
main()
{
/#
	self animscripts\debug::debugpushstate( "Cover Arrival" );
#/
	self endon( "killanimscript" );
/#
	self animscripts\debug::debugpopstate( "Cover Arrival", "Not standing" );
#/
	return;
	newstance = getnewstance();
	return;
/#
	assert( IsDefined( self.approachanim ), "Arrival anim not defined (" + self.animtype + " - exit_" + self.approachtype + " - " + self.approachnumber + ")" );
#/
	self clearanim( %root, 0.3 );
	self setflaggedanimknobrestart( "coverArrival", self.approachanim, 1, 0.3, 1 );
	self animscripts\shared::donotetracks( "coverArrival" );
	self maps\_dds::dds_threat_notify( self.team != "allies" );
	self.a.pose = newstance;
	self.a.movement = "stop";
	self.a.arrivaltype = self.approachtype;
	self clearanim( %root, 0.3 );
/#
	self animscripts\debug::debugpopstate( "Cover Arrival" );
#/
// SP = 0x0 - check OK
}

// 0x2484
setupaapproachnodepreconditions()
{
/#
	debug_arrival( "Not doing approach: path has negotiation start node" );
#/
	return 0;
/#
	debug_arrival( "Not doing approach: self.disableArrivals is true" );
#/
	return 0;
/#
	debug_arrival( "Not doing approach: May not be allowed to stand or crouch while arriving" );
#/
	return 0;
/#
	debug_arrival( "Not doing approach: (ent " + self getentnum() + "): self.a.pose is \"prone\"" );
#/
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x2538
setupapproachnode( firsttime )
{
	self endon( "killanimscript" );
	self.requestarrivalnotify = 1;
	self.a.arrivaltype = undefined;
	self thread dolastminuteexposedapproachwrapper();
	self waittill( "corner_approach", approach_dir );
	return;
	self thread setupapproachnode( 0 );
	approachtype = "exposed";
	approachpoint = self.pathgoalpos;
	approachnodeyaw = vectortoangles( approach_dir )[1];
	approachfinalyaw = approachnodeyaw;
	determinenodeapproachtype( self.node );
	approachtype = self.node.approachtype;
	approachpoint = ( self.node.turretinfo.origin[0], self.node.turretinfo.origin[1], self.node.origin[2] );
	forward = anglestoforward( ( 0, self.node.turretinfo.angles[1], 0 ) );
	right = anglestoright( ( 0, self.node.turretinfo.angles[1], 0 ) );
	approachpoint = approachpoint + vector_scale( forward, -32.545 ) - vector_scale( right, 6.899 );
	approachpoint = ( self.node.turretinfo.origin[0], self.node.turretinfo.origin[1], self.node.origin[2] );
	forward = anglestoforward( ( 0, self.node.turretinfo.angles[1], 0 ) );
	right = anglestoright( ( 0, self.node.turretinfo.angles[1], 0 ) );
	approachpoint = approachpoint + vector_scale( forward, -32.545 ) - vector_scale( right, 6.899 );
	approachpoint = ( self.node.turretinfo.origin[0], self.node.turretinfo.origin[1], self.node.origin[2] );
	forward = anglestoforward( ( 0, self.node.turretinfo.angles[1], 0 ) );
	right = anglestoright( ( 0, self.node.turretinfo.angles[1], 0 ) );
	approachpoint = approachpoint + vector_scale( forward, -37.36 ) - vector_scale( right, 13.279 );
	approachpoint = self.node.origin;
	approachnodeyaw = self.node.angles[1];
	approachfinalyaw = approachnodeyaw + getnodestanceyawoffset( approachtype );
/#
	setupapproachnodedebug( approachtype, approach_dir, approachnodeyaw );
#/
	return;
	startcornerapproach( approachtype, approachpoint, approachnodeyaw, approachfinalyaw, approach_dir );
// SP = 0x0 - check OK
}

// 0x27E0
startcornerapproachpreconditions( approachtype, approach_dir )
{
/#
	assert( IsDefined( self.node ) );
#/
	forwardangle = absangleclamp180( vectortoangles( approach_dir )[1] - self.node.angles[1] + 180 );
/#
	debug_arrival( "approach aborted: approach_dir is too far forward for node type " + self.node.type );
#/
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x2860
startcornerapproachconditions( approachpoint, approachtype, approachnumber, approachfinalyaw )
{
/#
	debug_arrival( "approach aborted at last minute: self.disableArrivals is true" );
#/
	return 0;
/#
	debug_arrival( "approach aborted at last minute: facing enemy instead of current motion angle" );
#/
	return 0;
/#
	debug_arrival( "approach aborted at last minute: not standing and running" );
#/
	return 0;
	requiredyaw = approachfinalyaw - angledeltaarray( "arrive_" + approachtype )[approachnumber];
/#
	debug_arrival( "aborting approach at last minute: don't want to turn back to nearby enemy" );
#/
	return 0;
/#
	debug_arrival( "approach blocked at last minute" );
#/
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x2A2C
approachwaittillclose( node, checkdist )
{
	return;
	self waitforpathgoalpos();
	dist = distance( self.origin, self.pathgoalpos );
	waittime = ( dist - checkdist ) / 250 - 0.1;
	waittime = 0.05;
	wait waittime;
// SP = 0x0 - check OK
}

// 0x2AB0
getapproachent()
{
	return self.node;
	return undefined;
// SP = 0x0 - check OK
}

// 0x2AC8
startcornerapproach( approachtype, approachpoint, approachnodeyaw, approachfinalyaw, approach_dir, forcecqb )
{
	self endon( "killanimscript" );
	self endon( "corner_approach" );
/#
	assert( IsDefined( approachtype ) );
#/
	return;
	result = getmaxdirectionsandexcludedirfromapproachtype( approachtype );
	maxdirections = result.maxdirections;
	excludedir = result.excludedir;
	approachnumber = -1;
	node = getapproachent();
	arrivalfromfront = vectordot( approach_dir, anglestoforward( node.angles ) ) >= 0;
	arrivalfromfront = vectordot( vectornormalize( self.origin - node.origin ), anglestoforward( node.angles ) ) <= 0;
	doingcqbapproach = shoulddocqbtransition( self.node, approachtype, 1, forcecqb );
	approachtype += "_cqb";
	result = self checkarrivalenterpositions( approachpoint, approachfinalyaw, approachtype, approach_dir, maxdirections, excludedir, arrivalfromfront );
/#
	i = 0;
	debug_arrival( result.data[i] );
	i++;
#/
/#
	debug_arrival( "approach aborted: " + result.failure );
#/
/#
	debug_arrival( "attempting cqb approach" );
#/
	return startcornerapproach( approachtype, approachpoint, approachnodeyaw, approachfinalyaw, approach_dir, 1 );
/#
	debug_arrival( "approach aborted: " + result.failure );
#/
	return;
	approachnumber = result.approachnumber;
/#
	debug_arrival( "approach success: dir " + approachnumber );
#/
	self.coverenterpos = result.approachpoint;
	self endon( "goal_changed" );
	self.arrivalstartdist = longestapproachdist( "arrive_" + approachtype );
	approachwaittillclose( node, self.arrivalstartdist + 8 );
	dirtonode = vectornormalize( approachpoint - self.origin );
	excludedir = 7;
	excludedir = 9;
	result = self checkarrivalenterpositions( approachpoint, approachfinalyaw, approachtype, dirtonode, maxdirections, excludedir, arrivalfromfront );
	approachnumber = result.approachnumber;
/#
	self thread watchgoalchangedwhileapproaching();
	thread debug_arrival_line( self.origin, self.coverenterpos, level.color_debug["red"], 5 );
#/
	movedeltaarray = movedeltaarray( "arrive_" + approachtype );
	self.arrivalstartdist = length( movedeltaarray[approachnumber] );
	approachwaittillclose( node, self.arrivalstartdist );
/#
	debug_arrival( "approach blocked at last minute" );
#/
	self.arrivalstartdist = undefined;
	return;
/#
	debug_arrival( "final approach aborted: " + result.failure );
#/
	self.arrivalstartdist = undefined;
	return;
	return;
	return;
/#
	debug_arrival( "final approach success: dir " + approachnumber );
#/
	requiredyaw = approachfinalyaw - angledeltaarray( "arrive_" + approachtype )[approachnumber];
	self setruntopos( self.coverenterpos );
	self waittill( "runto_arrived" );
	requiredyaw = approachfinalyaw - angledeltaarray( "arrive_" + approachtype )[approachnumber];
	return;
	self.approachnumber = approachnumber;
	self.approachtype = approachtype;
	self.approachanim = animarray( "arrive_" + approachtype )[approachnumber];
	self.startcoverarrival = 1;
	self startcoverarrival( self.coverenterpos, requiredyaw );
// SP = 0x0 - check OK
}

// 0x2F00
watchgoalchangedwhileapproaching()
{
/#
	self endon( "killanimscript" );
	self waittill( "goal_changed" );
	self notify( "abort_approach" );
#/
// SP = 0x0 - check OK
}

// 0x2F20
checkarrivalenterpositions( approachpoint, approachyaw, approachtype, approach_dir, maxdirections, excludedir, arrivalfromfront )
{
	angledataobj = spawnstruct();
	calculatenodetransitionangles( angledataobj, approachtype, 1, approachyaw, approach_dir, maxdirections, excludedir );
	sortnodetransitionangles( angledataobj, maxdirections );
	resultobj = spawnstruct();
/#
	resultobj.data = [];
#/
	arrivalpos = ( 0, 0, 0 );
	resultobj.approachnumber = -1;
	resultobj.approachpoint = undefined;
	numattempts = 2;
	numattempts = 1;
	i = 1;
/#
	assert( angledataobj.transindex[i] != excludedir );
#/
	resultobj.approachnumber = angledataobj.transindex[i];
/#
	resultobj.data[resultobj.data.size] = "approach blocked: dir " + resultobj.approachnumber;
#/
	i++;
/#
	resultobj.failure = numattempts + " direction attempts failed";
#/
	resultobj.approachnumber = -1;
	return resultobj;
/#
	disttoapproachpoint = distance( approachpoint, self.origin );
	disttoanimstart = distance( approachpoint, self.coverenterpos );
#/
	disttoapproachpoint = distancesquared( approachpoint, self.origin );
	disttoanimstart = distancesquared( approachpoint, self.coverenterpos );
/#
	recordline( approachpoint, self.coverenterpos, level.color_debug["green"], "Cover", self );
#/
/#
	resultobj.failure = "too close to destination";
#/
	resultobj.approachnumber = -1;
	return resultobj;
	selftoanimstart = vectornormalize( self.coverenterpos - self.origin );
	animstarttonode = vectornormalize( approachpoint - self.coverenterpos );
	cosangle = vectordot( selftoanimstart, animstarttonode );
/#
	resultobj.failure = "angle to start of animation is too great ( angle of " + acos( cosangle ) + " > 45 )";
#/
	resultobj.approachnumber = -1;
	return resultobj;
	return resultobj;
// SP = 0x0 - check OK
}

// 0x3180
checkcoverenterpos( arrivalpoint, arrivalyaw, approachtype, approachnumber, arrivalfromfront )
{
/#
	debug_arrival( "checkCoverEnterPos() checking for arrive_" + approachtype + "_" + approachnumber );
#/
	angle = ( 0, arrivalyaw - angledeltaarray( "arrive_" + approachtype )[approachnumber], 0 );
	forwarddir = anglestoforward( angle );
	rightdir = anglestoright( angle );
	movedeltaarray = movedeltaarray( "arrive_" + approachtype );
	forward = vector_scale( forwarddir, movedeltaarray[approachnumber][0] );
	right = vector_scale( rightdir, movedeltaarray[approachnumber][1] );
	enterpos = arrivalpoint - forward + right;
	self.coverenterpos = enterpos;
/#
	thread debug_arrival_line( enterpos, arrivalpoint, level.color_debug["cyan"], 1.5 );
#/
	return 1;
	return 0;
	return 1;
/#
	assert( approachtype == "pillar_crouch" );
#/
	premovedeltaarray = premovedeltaarray( "arrive_" + approachtype );
	forward = vector_scale( forwarddir, premovedeltaarray[approachnumber][0] );
	right = vector_scale( rightdir, premovedeltaarray[approachnumber][1] );
	originalenterpos = enterpos - forward + right;
	self.coverenterpos = originalenterpos;
/#
	thread debug_arrival_line( originalenterpos, enterpos, level.color_debug["cyan"], 1.5 );
#/
	return self maymovefrompointtopoint( originalenterpos, enterpos );
// SP = 0x0 - check OK
}

// 0x3394
dolastminuteexposedapproachwrapper()
{
	self endon( "killanimscript" );
	self notify( "doing_last_minute_exposed_approach" );
	self endon( "doing_last_minute_exposed_approach" );
	self thread watchgoalchanged();
	dolastminuteexposedapproach();
	self waittill_any( "goal_changed", "goal_changed_previous_frame" );
// SP = 0x0 - check OK
}

// 0x3418
watchgoalchanged()
{
	self endon( "killanimscript" );
	self endon( "doing_last_minute_exposed_approach" );
	self waittill( "goal_changed" );
	wait 0.05;
	self notify( "goal_changed_previous_frame" );
// SP = 0x0 - check OK
}

// 0x344C
dolastminuteexposedapproachpreconditions()
{
	return 0;
/#
	debug_arrival( "Aborting exposed approach because self.disableArrivals is true" );
#/
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x3488
dolastminuteexposedapproachmidconditions()
{
/#
	debug_arrival( "Aborting exposed approach - not standing and running" );
#/
	return 0;
/#
	debug_arrival( "Aborting exposed approach - holding the grenade." );
#/
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x3508
dolastminuteexposedapproachconditions( animdist, allowederror )
{
/#
	debug_arrival( "Aborting exposed approach because I have no path" );
#/
	return 0;
/#
	debug_arrival( "Aborting exposed approach because self.disableArrivals is true" );
#/
	return 0;
/#
	debug_arrival( "Aborting exposed approach because not facing motion and not going to a node" );
#/
	return 0;
/#
	debug_arrival( "approach aborted at last minute: not standing and running" );
#/
	return 0;
	dist = distance( self.origin, self.pathgoalpos );
/#
	debug_arrival( "Aborting exposed approach: maymove check failed, AnimDist = " + animdist + " Dist = " + dist );
#/
	return 0;
/#
	debug_arrival( "Aborting exposed approach because distance difference exceeded allowed error: " + dist + " more than " + allowederror + " from " + animdist );
#/
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x3630
determineexposedapproachtype( node )
{
	type = "exposed";
	stance = node gethighestnodestance();
	stance = "crouch";
	type = "exposed_crouch";
	type = "exposed";
	type += "_cqb";
	return type;
// SP = 0x0 - check OK
}

// 0x369C
faceenemyatendofapproach( node )
{
	return 0;
	return 1;
	return 0;
	return 0;
	return sighttracepassed( self.enemy getshootatpos(), self.pathgoalpos + vector_scale( ( 0, 0, 1 ), 60 ), 0, undefined );
// SP = 0x0 - check OK
}

// 0x3740
dolastminuteexposedapproach()
{
	self endon( "goal_changed" );
	return;
	self exposedapproachwaittillclose();
	return;
	approachtype = "exposed";
	goalmatchesnode = 0;
	goalmatchesnode = distancesquared( self.pathgoalpos, self.node.origin ) < 1;
	approachtype = determineexposedapproachtype( self.node );
	approachdir = vectornormalize( self.pathgoalpos - self.origin );
	desiredfacingyaw = vectortoangles( approachdir )[1];
	desiredfacingyaw = vectortoangles( self.enemy.origin - self.pathgoalpos )[1];
	facenodeangle = goalmatchesnode;
	facenodeangle = !(recentlysawenemy());
	desiredfacingyaw = getnodeforwardyaw( self.node );
	likelyenemydir = self getanglestolikelyenemypath();
	desiredfacingyaw = likelyenemydir[1];
	angledataobj = spawnstruct();
	calculatenodetransitionangles( angledataobj, approachtype, 1, desiredfacingyaw, approachdir, 9, -1 );
	best = 1;
	i = 2;
	best = i;
	i++;
	approachtype += "_cqb";
	self.approachnumber = angledataobj.transindex[best];
	self.approachtype = approachtype;
	self.approachanim = animarray( "arrive_" + approachtype )[self.approachnumber];
	animdist = length( movedeltaarray( "arrive_" + approachtype )[self.approachnumber] );
	requireddistsq = animdist + 8;
	requireddistsq *= requireddistsq;
	wait 0.05;
/#
	debug_arrival( "Aborting exposed approach because cover arrival dist is shorter" );
#/
	return;
	return;
	dist = distance( self.origin, self.pathgoalpos );
	facingyaw = vectortoangles( self.pathgoalpos - self.origin )[1];
	delta = movedeltaarray( "arrive_" + approachtype )[self.approachnumber];
/#
	assert( delta[0] != 0 );
#/
	yawtomakedeltamatchup = atan( delta[1] / delta[0] );
	requiredyaw = facingyaw - yawtomakedeltamatchup;
/#
	debug_arrival( "Aborting exposed approach because angle change was too great" );
#/
	return;
	requiredyaw = self.angles[1];
	closerdist = dist - animdist;
	idealstartpos = self.origin + vector_scale( vectornormalize( self.pathgoalpos - self.origin ), closerdist );
	requiredyaw = self.angles[1];
	idealstartpos = self.origin;
/#
	debug_arrival( "Doing exposed approach in direction " + self.approachnumber );
#/
	self startcoverarrival( idealstartpos, requiredyaw );
// SP = 0x0 - check OK
}

// 0x3B04
exposedapproachwaittillclose()
{
	self waitforpathgoalpos();
	dist = distance( self.origin, self.pathgoalpos );
	waittime = ( dist - longestexposedapproachdist() ) / 200 - 0.1;
	waittime = 0.05;
	wait waittime;
// SP = 0x0 - check OK
}

// 0x3B8C
waitforpathgoalpos()
{
	return;
	wait 1;
// SP = 0x0 - check OK
}

// 0x3BA8
aligntonodeangles()
{
	self endon( "killanimscript" );
	self endon( "goal_changed" );
	self endon( "dont_align_to_node_angles" );
	self endon( "doing_last_minute_exposed_approach" );
	waittillframeend;
	return;
	wait 0.05;
	wait 0.1;
	return;
	startdist = distance( self.origin, self.node.origin );
	return;
	determinenodeapproachtype( self.node );
	startyaw = self.angles[1];
	targetyaw = self.node.angles[1];
	targetyaw += getnodestanceyawoffset( self.node.approachtype );
	targetyaw = startyaw + angleclamp180( targetyaw - startyaw );
	self thread resetorientmodeongoalchange();
	self orientmode( "face default" );
	return;
	dist = distance( self.origin, self.node.origin );
	self orientmode( "face default" );
	return;
	distfrac = 1 - dist / startdist;
	currentyaw = startyaw + distfrac * ( targetyaw - startyaw );
	self orientmode( "face angle", currentyaw );
	wait 0.05;
// SP = 0x0 - check OK
}

// 0x3DB0
resetorientmodeongoalchange()
{
	self endon( "killanimscript" );
	self waittill_any( "goal_changed", "dont_align_to_node_angles" );
	self orientmode( "face default" );
// SP = 0x0 - check OK
}

// 0x3DE0
startmovetransitionpreconditions()
{
/#
	debug_arrival( "not exiting cover (ent " + self getentnum() + "): self.pathGoalPos is undefined" );
#/
	return 0;
/#
	debug_arrival( "not exiting cover (ent " + self getentnum() + "): ShouldFaceMotion is false" );
#/
	return 0;
/#
	debug_arrival( "not exiting cover (ent " + self getentnum() + "): self.a.pose is \"prone\"" );
#/
	return 0;
/#
	debug_arrival( "not exiting cover (ent " + self getentnum() + "): self.disableExits is true" );
#/
	return 0;
/#
	debug_arrival( "not exiting cover (ent " + self getentnum() + "): not allowed to stand" );
#/
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x3EEC
startmovetransitionmidconditions( exitnode, exittype )
{
/#
	debug_arrival( "aborting exit: not supported for node type " + exitnode.type );
#/
	return 0;
/#
	debug_arrival( "exposed exit aborted because anim_pose is not \"stand\" or \"crouch\"" );
#/
	return 0;
/#
	debug_arrival( "exposed exit aborted because anim_movement is not \"stop\"" );
#/
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x3F7C
startmovetransitionfinalconditions( exittype, approachnumber )
{
/#
	debug_arrival( "aborting exit in dir" + approachnumber + ": don't want to turn back to nearby enemy" );
#/
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x401C
startmovetransition()
{
	self endon( "killanimscript" );
	return;
	exitpos = self.origin;
	exityaw = self.angles[1];
	exittype = "exposed";
	exitnode = undefined;
	exitnode = self.node;
	exitnode = self.prevnode;
	determinenodeexittype( exitnode );
	distancesq = distancesquared( exitnode.origin, self.origin );
	anglediff = absangleclamp180( self.angles[1] - exitnode.angles[1] - getnodestanceyawoffset( exitnode.approachtype ) );
	exitpos = exitnode.origin;
	exityaw = exitnode.angles[1];
	exittype = exitnode.approachtype;
/#
	self startmovetransitiondebug( exittype, exityaw );
#/
	return;
	exittype = "exposed_crouch";
	leavedir = ( -1 * self.lookaheaddir[0], -1 * self.lookaheaddir[1], 0 );
	result = getmaxdirectionsandexcludedirfromapproachtype( exittype );
	maxdirections = result.maxdirections;
	excludedir = result.excludedir;
	exityaw += getnodestanceyawoffset( exittype );
	exittype += "_cqb";
	angledataobj = spawnstruct();
	calculatenodetransitionangles( angledataobj, exittype, 0, exityaw, leavedir, maxdirections, excludedir );
	sortnodetransitionangles( angledataobj, maxdirections );
	approachnumber = -1;
	numattempts = 2;
	numattempts = 1;
	i = 1;
/#
	assert( angledataobj.transindex[i] != excludedir );
#/
	approachnumber = angledataobj.transindex[i];
/#
	debug_arrival( "exit blocked: dir " + approachnumber );
#/
	i++;
/#
	debug_arrival( "aborting exit: too many exit directions blocked" );
#/
	return;
	alloweddistsq = distancesquared( self.origin, self.coverexitpos );
	availabledistsq = distancesquared( self.origin, self.pathgoalpos );
/#
	debug_arrival( "exit failed, too close to destination" );
#/
	return;
	return;
/#
	debug_arrival( "exit success: dir " + approachnumber );
#/
	self thread maps\_dds::dds_notify( "thrt_breaking", self.team != "allies" );
	self maps\_dds::dds_notify( "rspns_movement", self.team == "allies" );
	self docoverexitanimation( exittype, approachnumber );
// SP = 0x0 - check OK
}

// 0x4390
checkcoverexitpos( exitpoint, exityaw, exittype, approachnumber, checkwithpath )
{
	angle = ( 0, exityaw, 0 );
	forwarddir = anglestoforward( angle );
	rightdir = anglestoright( angle );
	movedeltaarray = movedeltaarray( "exit_" + exittype );
	forward = vector_scale( forwarddir, movedeltaarray[approachnumber][0] );
	right = vector_scale( rightdir, movedeltaarray[approachnumber][1] );
	exitpos = exitpoint + forward - right;
	self.coverexitpos = exitpos;
	isexposedapproach = exittype == "exposed_crouch";
	isexposedapproach = exittype == "exposed_crouch_cqb";
/#
	thread debug_arrival_line( self.origin, exitpos, level.color_debug["green"], 1.5 );
#/
/#
	debug_arrival( "cover exit " + approachnumber + " path check failed" );
#/
	return 0;
	return 0;
	return 1;
/#
	assert( exittype == "pillar_crouch" );
#/
	postmovedeltaarray = postmovedeltaarray( "exit_" + exittype );
	forward = vector_scale( forwarddir, postmovedeltaarray[approachnumber][0] );
	right = vector_scale( rightdir, postmovedeltaarray[approachnumber][1] );
	finalexitpos = exitpos + forward - right;
	self.coverexitpos = finalexitpos;
/#
	thread debug_arrival_line( exitpos, finalexitpos, level.color_debug["green"], 1.5 );
#/
	return self maymovefrompointtopoint( exitpos, finalexitpos );
// SP = 0x0 - check OK
}

// 0x45B4
docoverexitanimation( exittype, approachnumber )
{
/#
	assert( IsDefined( approachnumber ) );
#/
/#
	assert( approachnumber > 0 );
#/
/#
	assert( IsDefined( exittype ) );
#/
	leaveanim = animarray( "exit_" + exittype )[approachnumber];
/#
	assert( IsDefined( leaveanim ), "Exit anim not found (" + self.animtype + " - exit_" + exittype + " - " + approachnumber + ")" );
#/
	lookaheadangles = vectortoangles( self.lookaheaddir );
/#
	endpos = self.origin + vector_scale( self.lookaheaddir, 100 );
	thread debug_arrival_line( self.origin, endpos, level.color_debug["red"], 1.5 );
#/
	return;
/#
	self animscripts\debug::debugpushstate( "Cover Exit" );
#/
	self animmode( "zonly_physics", 0 );
	self orientmode( "face angle", self.angles[1] );
	self setflaggedanimknoballrestart( "coverexit", leaveanim, %body, 1, 0.2, 1 );
	animstarttime = GetTime();
	hasexitalign = animhasnotetrack( leaveanim, "exit_align" );
/#
	debug_arrival( "^1Animation exit_" + exittype + "[" + approachnumber + "] has no \"exit_align\" notetrack" );
#/
	self thread donotetracksforexit( "coverexit", hasexitalign );
	self waittillmatch( "coverexit" );
	return "exit_align";
	self.a.pose = "stand";
	self.a.movement = "run";
	hascodemovenotetrack = animhasnotetrack( leaveanim, "code_move" );
	curfrac = self getanimtime( leaveanim );
	remainingmovedelta = getmovedelta( leaveanim, curfrac, 1 );
	remainingangledelta = getangledelta( leaveanim, curfrac, 1 );
	faceyaw = lookaheadangles[1] - remainingangledelta;
	forward = anglestoforward( ( 0, faceyaw, 0 ) );
	right = anglestoright( ( 0, faceyaw, 0 ) );
	endpoint = self.origin + vector_scale( forward, remainingmovedelta[0] ) - vector_scale( right, remainingmovedelta[1] );
	self orientmode( "face angle", faceyaw );
	timeleft = getanimlength( leaveanim ) * ( 1 - curfrac ) - 0.15 - 0.05;
	timeleft = 0.4;
	wait timeleft;
	notetrack_times = getnotetracktimes( leaveanim, "code_move" );
	absolute_code_move_time = getanimlength( leaveanim ) * notetrack_times[0];
	curfrac = self getanimtime( leaveanim );
	current_anim_time = getanimlength( leaveanim ) * curfrac;
	wait getanimlength( leaveanim ) - absolute_code_move_time;
	self waittillmatch( "coverexit" );
	return "code_move";
	self orientmode( "face motion" );
	self animmode( "none", 0 );
	totalanimtime = getanimlength( leaveanim ) / 1;
	timepassed = ( GetTime() - animstarttime ) / 1000;
	timeleft = totalanimtime - timepassed - 0.15;
	wait timeleft;
	self clearanim( %root, 0.15 );
	self orientmode( "face default" );
	self animmode( "normal", 0 );
/#
	self animscripts\debug::debugpopstate( "Cover Exit" );
#/
// SP = 0x0 - check OK
}

// 0x49B0
donotetracksforexit( animname, hasexitalign )
{
	self endon( "killanimscript" );
	self animscripts\shared::donotetracks( animname );
	self notify( animname, "exit_align" );
// SP = 0x0 - check OK
}

// 0x49DC
getnewstance()
{
	newstance = undefined;
	switch ( self.approachtype )
	{
		case "crouch":
		case "crouch_saw":
		case "exposed":
		case "exposed_cqb":
		case "exposed_crouch":
		case "exposed_crouch_cqb":
		case "left":
		case "left_cqb":
		case "left_crouch":
			newstance = "stand";
			break;
		case "left_crouch_cqb":
		case "pillar":
		case "pillar_crouch":
		case "prone_saw":
		case "right":
		case "right_cqb":
		case "right_crouch":
		case "right_crouch_cqb":
		case "stand":
			newstance = "crouch";
			break;
		case "stand_saw":
			newstance = "prone";
			break;
		default:
/#
			assertmsg( "bad node approach type: " + self.approachtype );
#/
			return "";
	}
	return newstance;
// SP = 0x0 - check OK
}

// 0x4AD8
getnodestanceyawoffset( approachtype )
{
	return 90;
	return -90;
	return 180;
	return 0;
// SP = 0x0 - check OK
}

// 0x4B40
canusesawapproach( node )
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x4C94
determinenodeapproachtype( node )
{
	node.approachtype = "stand_saw";
	node.approachtype = "crouch_saw";
	node.approachtype = "prone_saw";
/#
	assert( IsDefined( node.approachtype ) );
#/
	return;
	self.disablearrivals = 1;
	self.disablearrivals = 0;
	return;
	nodetype = node.type;
	nodetype = "Cover Right";
	nodetype = "Cover Left";
	stance = !(node has_spawnflag( 8 ));
	node.approachtype = anim.approach_types[nodetype][stance];
// SP = 0x0 - check OK
}

// 0x4DC8
determinenodeexittype( node )
{
	node.approachtype = "stand_saw";
	node.approachtype = "crouch_saw";
	node.approachtype = "prone_saw";
/#
	assert( IsDefined( node.approachtype ) );
#/
	return;
	return;
	nodetype = node.type;
	nodetype = "Cover Right";
	nodetype = "Cover Left";
	node.approachtype = anim.approach_types[nodetype][0];
	node.approachtype = anim.approach_types[nodetype][1];
// SP = 0x0 - check OK
}

// 0x4ED0
getmaxdirectionsandexcludedirfromapproachtype( approachtype )
{
	returnobj = spawnstruct();
	returnobj.maxdirections = 9;
	returnobj.excludedir = 9;
	returnobj.maxdirections = 9;
	returnobj.excludedir = 7;
	returnobj.maxdirections = 6;
	returnobj.excludedir = -1;
	returnobj.maxdirections = 9;
	returnobj.excludedir = -1;
	returnobj.maxdirections = 3;
	returnobj.excludedir = -1;
/#
	assertmsg( "unsupported approach type " + approachtype );
#/
	return returnobj;
// SP = 0x0 - check OK
}

// 0x4FEC
calculatenodetransitionangles( angledataobj, approachtype, isarrival, arrivalyaw, approach_dir, maxdirections, excludedir )
{
	angledataobj.transitions = [];
	angledataobj.transindex = [];
	anglearray = undefined;
	sign = 1;
	offset = 0;
	anglearray = angledeltaarray( "arrive_" + approachtype );
	sign = -1;
	offset = 0;
	anglearray = angledeltaarray( "exit_" + approachtype );
	sign = 1;
	offset = 180;
	i = 1;
	angledataobj.transindex[i] = i;
	angledataobj.transitions[i] = -1.0003;
	angles = ( 0, arrivalyaw + sign * anglearray[i] + offset, 0 );
	dir = vectornormalize( anglestoforward( angles ) );
	angledataobj.transitions[i] = vectordot( approach_dir, dir );
	i++;
// SP = 0x0 - check OK
}

// 0x50F8
sortnodetransitionangles( angledataobj, maxdirections )
{
	i = 2;
	currentvalue = angledataobj.transitions[angledataobj.transindex[i]];
	currentindex = angledataobj.transindex[i];
	j = i - 1;
	angledataobj.transindex[j + 1] = angledataobj.transindex[j];
	j--;
	angledataobj.transindex[j + 1] = currentindex;
	i++;
// SP = 0x0 - check OK
}

// 0x5198
shoulddocqbtransition( node, type, isexit, forcecqb )
{
	return 0;
	return 0;
	return candocqbtransition( node, type, isexit );
// SP = 0x0 - check OK
}

// 0x51F8
candocqbtransition( node, type, isexit )
{
	return 0;
	return 1;
/#
	assert( IsDefined( type ) );
#/
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x52D0
end_script()
{
// SP = 0x0 - check OK
}

// 0x52D8
startmovetransitiondebug( exittype, exityaw )
{
/#
	debug_arrival( "^3exiting cover (ent " + self getentnum() + ", type \"" + exittype + "\"):" );
	debug_arrival( "lookaheaddir = (" + self.lookaheaddir[0] + ", " + self.lookaheaddir[1] + ", " + self.lookaheaddir[2] + ")" );
	angle = angleclamp180( vectortoangles( self.lookaheaddir )[1] - exityaw );
	debug_arrival( "   (Angle of " + ( 0 - angle ) + " right from node forward.)" );
	debug_arrival( "   (Angle of " + angle + " left from node forward.)" );
#/
// SP = 0x0 - check OK
}

// 0x5388
setupapproachnodedebug( approachtype, approach_dir, approachnodeyaw )
{
/#
	debug_arrival( "^5approaching cover (ent " + self getentnum() + ", type \"" + approachtype + "\"):" );
	debug_arrival( "   approach_dir = (" + approach_dir[0] + ", " + approach_dir[1] + ", " + approach_dir[2] + ")" );
	angle = angleclamp180( vectortoangles( approach_dir )[1] - approachnodeyaw + 180 );
	debug_arrival( "   (Angle of " + ( 0 - angle ) + " right from node forward.)" );
	debug_arrival( "   (Angle of " + angle + " left from node forward.)" );
	debug_arrival( "Aborting cover approach: node approach type was " + self.node.approachtype );
	debug_arrival( "Aborting cover approach: node approach type was undefined" );
	debug_arrival( "Aborting cover approach: self.node is undefined" );
	thread drawapproachvec( approach_dir );
#/
// SP = 0x0 - check OK
}

// 0x54A0
drawapproachvec( approach_dir )
{
/#
	self endon( "killanimscript" );
	line( self.node.origin + vector_scale( ( 0, 0, 1 ), 20 ), self.node.origin - vector_scale( approach_dir, 64 ) + vector_scale( ( 0, 0, 1 ), 20 ) );
	recordline( self.node.origin + vector_scale( ( 0, 0, 1 ), 20 ), self.node.origin - vector_scale( approach_dir, 64 ) + vector_scale( ( 0, 0, 1 ), 20 ) );
	wait 0.05;
#/
// SP = 0x0 - check OK
}

// 0x553C
debug_arrivals_on_actor()
{
/#
	dvar = GetDvarInt( #"0x3F886B38" );
	return 0;
	return 1;
	return 1;
	return 0;
#/
// SP = 0x0 - check OK
}

// 0x5588
debug_arrival( msg )
{
/#
	println( msg );
	recordenttext( msg, self, level.color_debug["white"], "Cover" );
#/
// SP = 0x0 - check OK
}

// 0x55C8
debug_arrival_cross( atpoint, radius, color, durationframes )
{
/#
	atpoint_high = atpoint + ( 0, 0, radius );
	atpoint_low = atpoint + ( 0, 0, -1 * radius );
	atpoint_left = atpoint + ( 0, radius, 0 );
	atpoint_right = atpoint + ( 0, -1 * radius, 0 );
	atpoint_forward = atpoint + ( radius, 0, 0 );
	atpoint_back = atpoint + ( -1 * radius, 0, 0 );
	thread debug_arrival_line( atpoint_high, atpoint_low, color, durationframes );
	thread debug_arrival_line( atpoint_left, atpoint_right, color, durationframes );
	thread debug_arrival_line( atpoint_forward, atpoint_back, color, durationframes );
#/
// SP = 0x0 - check OK
}

// 0x5674
debug_arrival_line( start, end, color, duration )
{
/#
	recordline( start, end, color, "Cover", self );
	debugline( start, end, color, duration );
#/
// SP = 0x0 - check OK
}

// 0x56C0
debug_arrival_record_text( msg, position, color )
{
/#
	record3dtext( msg, position, color, "Animscript" );
#/
// SP = 0x0 - check OK
}

// 0x56F4
fakeailogic()
{
/#
	self.animtype = "default";
	self.a.script = "move";
	self.a.pose = "stand";
	self.a.prevpose = "stand";
	self.weapon = "ak47_sp";
	self.ignoreme = 1;
	self.ignoreall = 1;
	self animmode( "nogravity" );
	self forceteleport( get_players()[0].origin + vector_scale( ( 0, 0, -1 ), 1000 ), self.origin );
	wait 0.05;
#/
// SP = 0x0 - check OK
}

// 0x579C
coverarrivaldebugtool()
{
/#
	nodecolors = [];
	nodecolors["Cover Stand"] = ( 0, 0.54, 0.66 );
	nodecolors["Cover Crouch"] = ( 0, 0.93, 0.72 );
	nodecolors["Cover Crouch Window"] = ( 0, 0.7, 0.5 );
	nodecolors["Cover Prone"] = ( 0, 0.6, 0.46 );
	nodecolors["Cover Right"] = ( 0.85, 0.85, 0.1 );
	nodecolors["Cover Left"] = ( 1, 0.7, 0 );
	nodecolors["Conceal Stand"] = ( 0, 0, 1 );
	nodecolors["Conceal Crouch"] = vector_scale( ( 0, 0, 1 ), 0.75 );
	nodecolors["Conceal Prone"] = vector_scale( ( 0, 0, 1 ), 0.5 );
	nodecolors["Turret"] = ( 0, 0.93, 0.72 );
	nodecolors["Bad"] = ( 1, 0, 0 );
	nodecolors["Poor"] = ( 1, 0.5, 0 );
	nodecolors["Ok"] = ( 1, 1, 0 );
	nodecolors["Good"] = ( 0, 1, 0 );
	wait_for_first_player();
	player = get_players()[0];
	tracemin = ( -15, -15, 18 );
	tracemax = ( 15, 15, 72 );
	hudgood = newdebughudelem();
	hudgood.location = 0;
	hudgood.alignx = "left";
	hudgood.aligny = "middle";
	hudgood.foreground = 1;
	hudgood.fontscale = 1.3;
	hudgood.sort = 20;
	hudgood.x = 680;
	hudgood.y = 240;
	hudgood.og_scale = 1;
	hudgood.color = nodecolors["Good"];
	hudgood.alpha = 1;
	hudok = newdebughudelem();
	hudok.location = 0;
	hudok.alignx = "left";
	hudok.aligny = "middle";
	hudok.foreground = 1;
	hudok.fontscale = 1.3;
	hudok.sort = 20;
	hudok.x = 680;
	hudok.y = 260;
	hudok.og_scale = 1;
	hudok.color = nodecolors["Ok"];
	hudok.alpha = 1;
	hudpoor = newdebughudelem();
	hudpoor.location = 0;
	hudpoor.alignx = "left";
	hudpoor.aligny = "middle";
	hudpoor.foreground = 1;
	hudpoor.fontscale = 1.3;
	hudpoor.sort = 20;
	hudpoor.x = 680;
	hudpoor.y = 280;
	hudpoor.og_scale = 1;
	hudpoor.color = nodecolors["Poor"];
	hudpoor.alpha = 1;
	hudbad = newdebughudelem();
	hudbad.location = 0;
	hudbad.alignx = "left";
	hudbad.aligny = "middle";
	hudbad.foreground = 1;
	hudbad.fontscale = 1.3;
	hudbad.sort = 20;
	hudbad.x = 680;
	hudbad.y = 300;
	hudbad.og_scale = 1;
	hudbad.color = nodecolors["Bad"];
	hudbad.alpha = 1;
	hudtotal = newdebughudelem();
	hudtotal.location = 0;
	hudtotal.alignx = "left";
	hudtotal.aligny = "middle";
	hudtotal.foreground = 1;
	hudtotal.fontscale = 1.3;
	hudtotal.sort = 20;
	hudtotal.x = 680;
	hudtotal.y = 330;
	hudtotal.og_scale = 1;
	hudtotal.color = ( 1, 1, 1 );
	hudtotal.alpha = 1;
	hudgoodtext = newdebughudelem();
	hudgoodtext.location = 0;
	hudgoodtext.alignx = "right";
	hudgoodtext.aligny = "middle";
	hudgoodtext.foreground = 1;
	hudgoodtext.fontscale = 1.3;
	hudgoodtext.sort = 20;
	hudgoodtext.x = 670;
	hudgoodtext.y = 240;
	hudgoodtext.og_scale = 1;
	hudgoodtext.color = nodecolors["Good"];
	hudgoodtext.alpha = 1;
	hudgoodtext settext( "Good: " );
	hudoktext = newdebughudelem();
	hudoktext.location = 0;
	hudoktext.alignx = "right";
	hudoktext.aligny = "middle";
	hudoktext.foreground = 1;
	hudoktext.fontscale = 1.3;
	hudoktext.sort = 20;
	hudoktext.x = 670;
	hudoktext.y = 260;
	hudoktext.og_scale = 1;
	hudoktext.color = nodecolors["Ok"];
	hudoktext.alpha = 1;
	hudoktext settext( "Ok: " );
	hudpoortext = newdebughudelem();
	hudpoortext.location = 0;
	hudpoortext.alignx = "right";
	hudpoortext.aligny = "middle";
	hudpoortext.foreground = 1;
	hudpoortext.fontscale = 1.3;
	hudpoortext.sort = 20;
	hudpoortext.x = 670;
	hudpoortext.y = 280;
	hudpoortext.og_scale = 1;
	hudpoortext.color = nodecolors["Poor"];
	hudpoortext.alpha = 1;
	hudpoortext settext( "Poor: " );
	hudbadtext = newdebughudelem();
	hudbadtext.location = 0;
	hudbadtext.alignx = "right";
	hudbadtext.aligny = "middle";
	hudbadtext.foreground = 1;
	hudbadtext.fontscale = 1.3;
	hudbadtext.sort = 20;
	hudbadtext.x = 670;
	hudbadtext.y = 300;
	hudbadtext.og_scale = 1;
	hudbadtext.color = nodecolors["Bad"];
	hudbadtext.alpha = 1;
	hudbadtext settext( "Bad: " );
	hudlinetext = newdebughudelem();
	hudlinetext.location = 0;
	hudlinetext.alignx = "left";
	hudlinetext.aligny = "middle";
	hudlinetext.foreground = 1;
	hudlinetext.fontscale = 1.3;
	hudlinetext.sort = 20;
	hudlinetext.x = 630;
	hudlinetext.y = 315;
	hudlinetext.og_scale = 1;
	hudlinetext.color = ( 1, 1, 1 );
	hudlinetext.alpha = 1;
	hudlinetext settext( "------------------" );
	hudtotaltext = newdebughudelem();
	hudtotaltext.location = 0;
	hudtotaltext.alignx = "right";
	hudtotaltext.aligny = "middle";
	hudtotaltext.foreground = 1;
	hudtotaltext.fontscale = 1.3;
	hudtotaltext.sort = 20;
	hudtotaltext.x = 670;
	hudtotaltext.y = 330;
	hudtotaltext.og_scale = 1;
	hudtotaltext.color = ( 1, 1, 1 );
	hudtotaltext.alpha = 1;
	hudtotaltext settext( "Total: " );
	badnode = undefined;
	fakeai = undefined;
	tool = GetDvarInt( #"0x57FCCA16" );
	tool = 1;
	fakeai delete();
	fakeai = undefined;
	hudbad.alpha = 0;
	hudpoor.alpha = 0;
	hudok.alpha = 0;
	hudgood.alpha = 0;
	hudtotal.alpha = 0;
	hudbadtext.alpha = 0;
	hudpoortext.alpha = 0;
	hudoktext.alpha = 0;
	hudgoodtext.alpha = 0;
	hudlinetext.alpha = 0;
	hudtotaltext.alpha = 0;
	wait 0.2;
	spawners = getspawnerarray();
	i = 0;
	fakeai = spawners[i] stalingradspawn();
	fakeai animcustom( ::fakeailogic );
	i++;
	wait 0.2;
	hudbad.alpha = 1;
	hudpoor.alpha = 1;
	hudok.alpha = 1;
	hudgood.alpha = 1;
	hudtotal.alpha = 1;
	hudbadtext.alpha = 1;
	hudpoortext.alpha = 1;
	hudoktext.alpha = 1;
	hudgoodtext.alpha = 1;
	hudlinetext.alpha = 1;
	hudtotaltext.alpha = 1;
	numbad = 0;
	numpoor = 0;
	numok = 0;
	numgood = 0;
	tracesthisframe = 0;
	renderedthisframe = 0;
	evaluatedthisframe = 0;
	radius = GetDvarFloat( #"0x876D873E" );
	nodes = getanynodearray( player.origin, radius );
	nodes = [];
	nodes[0] = level.nodedrone.currentnode;
	shownodes = GetDvarInt( #"0x8FA91890" );
	totalnodes = 1;
	totalnodes = nodes.size;
	fakeai.cqb = 0;
	fakeai.weapon = "ak47_sp";
	fakeai.heat = 0;
	tooltype = GetDvarInt( #"0x3F219298" );
	fakeai.cqb = 1;
	fakeai.weapon = "m1911_sp";
	allai = entsearch( level.contents_actor, player.origin, 10000 );
	numai = allai.size;
	numai = 5;
	numai = 15;
	maxnodesperframe = ( numai - 5 ) / ( 15 - 5 );
	maxnodesperframe = ( 1 - maxnodesperframe ) * ( 30 - 5 ) + 5;
	frameinterval = int( ceil( totalnodes / maxnodesperframe ) );
	i = 0;
	node = nodes[i];
	node.angledeltaarray = undefined;
	node.movedeltaarray = undefined;
	node.premovedeltaarray = undefined;
	node.postmovedeltaarray = undefined;
	node.tool = tool;
	node.tooltype = tooltype;
/#
	assert( IsDefined( node ) );
#/
	totalnodes++;
	print3d( node.origin, node.animscript, ( 1, 0, 0 ), 1, 0.2, frameinterval );
	totalnodes++;
	numbad++;
	numpoor++;
	numok++;
	numgood++;
	testai = fakeai;
	nearaiarray = entsearch( level.contents_actor, node.origin, 16 );
	testai = nearaiarray[0];
	rendernode = 1;
	rendernode = 0;
	nodecolor = nodecolors["Good"];
	stance = !(node has_spawnflag( 8 ));
	transtype = anim.approach_types[node.type][stance];
	totaltransitions = 0;
	validtransitions = 0;
	animname = "arrive_" + transtype;
	animname = "exit_" + transtype;
	animname += "_cqb";
	node.angledeltaarray = fakeai angledeltaarray( animname, "move" );
	j = 1;
	totaltransitions++;
	linecolor = vector_scale( ( 1, 0, 0 ), 0.5 );
	approachisgood = 0;
	originalenterpos = undefined;
	approachfinalyaw = node.angles[1] + animscripts\cover_arrival::getnodestanceyawoffset( transtype );
	angle = ( 0, approachfinalyaw - node.angledeltaarray[j], 0 );
	angle = ( 0, approachfinalyaw, 0 );
	forwarddir = anglestoforward( angle );
	rightdir = anglestoright( angle );
	node.movedeltaarray = fakeai movedeltaarray( animname, "move" );
	enterpos = node.origin;
	forward = vector_scale( forwarddir, node.movedeltaarray[j][0] );
	right = vector_scale( rightdir, node.movedeltaarray[j][1] );
	enterpos = node.origin - forward + right;
	enterpos = node.origin + forward - right;
	approachisgood = 1;
	linecolor = vector_scale( ( 0, 1, 0 ), 0.75 );
	line( node.origin, enterpos, linecolor, 1, 1, frameinterval );
	originalenterpos = enterpos;
	node.premovedeltaarray = fakeai premovedeltaarray( animname, "move" );
	forward = vector_scale( forwarddir, node.premovedeltaarray[j][0] );
	right = vector_scale( rightdir, node.premovedeltaarray[j][1] );
	originalenterpos = enterpos - forward + right;
	node.postmovedeltaarray = fakeai postmovedeltaarray( animname, "move" );
	forward = vector_scale( forwarddir, node.postmovedeltaarray[j][0] );
	right = vector_scale( rightdir, node.postmovedeltaarray[j][1] );
	originalenterpos = enterpos + forward - right;
	approachisgood = 0;
	linecolor = vector_scale( ( 1, 0, 0 ), 0.5 );
	line( originalenterpos, enterpos, linecolor, 1, 1, frameinterval );
	print3d( originalenterpos, j + " (" + distance2d( originalenterpos, enterpos ) + ")", linecolor, 1, 0.2, frameinterval );
	print3d( enterpos, j + " (" + distance2d( node.origin, enterpos ) + ")", linecolor, 1, 0.2, frameinterval );
	validtransitions++;
	tracesthisframe++;
	j++;
	node.lastratio = validtransitions / totaltransitions;
	nodecolor = nodecolors["Bad"];
	numbad++;
	badnode = node;
	nodecolor = nodecolors["Poor"];
	numpoor++;
	nodecolor = nodecolors["Ok"];
	numok++;
	numgood++;
	print3d( node.origin, node.type + " (" + transtype + ")", nodecolor, 1, 0.35, frameinterval );
	box( node.origin, vector_scale( ( -1, -1, 0 ), 16 ), vector_scale( ( 1, 1, 1 ), 16 ), node.angles[1], nodecolor, 1, 1, frameinterval );
	nodeforward = anglestoforward( node.angles );
	nodeforward = vector_scale( nodeforward, 8 );
	line( node.origin, node.origin + nodeforward, nodecolor, 1, 1, frameinterval );
	renderedthisframe++;
	evaluatedthisframe++;
	node.lastcheckedtime = GetTime();
	i++;
	hudtotal setvalue( numbad + numpoor + numok + numgood );
	hudbad setvalue( numbad );
	hudpoor setvalue( numpoor );
	hudok setvalue( numok );
	hudgood setvalue( numgood );
	wait 0.05;
#/
// SP = 0x0 - check OK
}