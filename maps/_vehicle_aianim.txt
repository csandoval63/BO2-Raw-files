// maps/_vehicle_aianim.gsc

#include animscripts\shared;
#include animscripts\utility;
#include maps\_vehicle;
#include maps\_turret;
#include common_scripts\utility;
#include maps\_utility;

#using_animtree ( "generic_human" );


// 0x2540
vehicle_enter( vehicle, tag )
{
/#
	assert( !(IsDefined( self.ridingvehicle )), "ai can't ride two vehicles at the same time" );
#/
	self.forced_startingposition = anim_pos_from_tag( vehicle, tag );
	type = vehicle.vehicletype;
	vehicleanim = vehicle get_aianims();
	maxpos = level.vehicle_aianims[type].size;
	pos = set_walkerpos( self, level.vehicle_walkercount[type] );
	vehicle thread walkwithvehicle( self, pos );
	return;
	vehicle.attachedguys[vehicle.attachedguys.size] = self;
	pos = vehicle set_pos( self, maxpos );
	return;
	self.drivingvehicle = 1;
	animpos = anim_pos( vehicle, pos );
	vehicle.usedpositions[pos] = 1;
	self.pos = pos;
	self.delay = animpos.delay;
	vehicle.delayer = self.delay;
	vehicle.delayer += animpos.delayinc;
	self.delay = vehicle.delayer;
	self.ridingvehicle = vehicle;
	self.orghealth = self.health;
	self.vehicle_idle = animpos.idle;
	self.vehicle_idle_combat = animpos.idle_combat;
	self.vehicle_idle_pistol = animpos.idle_pistol;
	self.vehicle_standattack = animpos.standattack;
	self.standing = 0;
	self.allowdeath = 0;
	self.allowdeath = 1;
	vehicle thread guy_death( self, animpos );
	self.allowdeath = 1;
	vehicle.riders[vehicle.riders.size] = self;
	vehicle thread guy_vehicle_death( self );
	return;
	org = vehicle gettagorigin( animpos.sittag );
	angles = vehicle gettagangles( animpos.sittag );
	self linkto( vehicle, animpos.sittag, ( 0, 0, 0 ), ( 0, 0, 0 ) );
	n_turret_index = _get_turret_index_for_tag( animpos.sittag );
	vehicle _vehicle_turret_set_user( self, animpos.sittag );
	self teleport( org, angles );
	self.a.disablelongdeath = 1;
	self gun_remove();
	self.vehicle_pos = pos;
	self.vehicle = vehicle;
	self animcustom( ::guy_man_gunner_turret );
	vehicle thread guy_man_turret( self, pos );
	self.do_combat_getout = 1;
	self.do_combat_getout = 0;
	self.do_pistol_getout = 1;
	self.do_combat_idle = 1;
	self.do_combat_idle = 0;
	self.do_pistol_idle = 1;
	detach_models_with_substr( self, "weapon_" );
	self.origin = org;
	self.angles = angles;
	self.vehicle_pos = pos;
	self.vehicle = vehicle;
	self thread guy_man_gunner_turret();
	vehicle thread guy_man_turret( self, pos );
	vehicle thread guy_handle( self, pos );
	vehicle thread guy_idle( self, pos );
	vehicle thread guy_deathhandle( self, pos );
	self notify( "enter_vehicle", vehicle );
	vehicle thread vehicle_handleunloadevent();
// SP = 0x0 - check OK
}

// 0x29DC
guy_array_enter( guysarray, vehicle )
{
	guysarray = maps\_vehicle::sort_by_startingpos( guysarray );
	lastguy = 0;
	i = 0;
	lastguy = 1;
	guysarray[i] vehicle_enter( vehicle );
	i++;
// SP = 0x0 - check OK
}

// 0x2A34
handle_attached_guys()
{
	type = self.vehicletype;
	i = 0;
	self.walk_tags[i] = "tag_walker" + i;
	self.walk_tags_used[i] = 0;
	i++;
	self.attachedguys = [];
	return;
	maxpos = level.vehicle_aianims[type].size;
	thread ai_wait_go();
	self.runningtovehicle = [];
	self.usedpositions = [];
	self.getinorgs = [];
	self.delayer = 0;
	vehicleanim = self get_aianims();
	i = 0;
	self.usedpositions[i] = 0;
	self.usedpositions[1] = 1;
	i++;
// SP = 0x0 - check OK
}

// 0x2B40
load_ai_goddriver( array )
{
	load_ai( array, 1 );
// SP = 0x0 - check OK
}

// 0x2B58
guy_death( guy, animpos )
{
	guy endon( "death" );
	guy endon( "jumping_out" );
	waittillframeend;
	guy.allowdeath = 0;
	guy.health = 100000;
	guy waittill( "damage" );
	thread guy_deathimate_me( guy, animpos );
	return;
// SP = 0x0 - check OK
}

// 0x2BC0
guy_deathimate_me( guy, animpos )
{
	animtimer = GetTime() + getanimlength( animpos.death ) * 1000;
	angles = guy.angles;
	origin = guy.origin;
	guy = convert_guy_to_drone( guy );
	[[level.global_kill_func]]( "MOD_RIFLE_BULLET", "torso_upper", origin );
	detach_models_with_substr( guy, "weapon_" );
	guy linkto( self, animpos.sittag, ( 0, 0, 0 ), ( 0, 0, 0 ) );
	guy notsolid();
	thread animontag( guy, animpos.sittag, animpos.death );
	guy waittillmatch( "animontagdone" );
	return "start_ragdoll";
	guy unlink();
	guy startragdoll();
	wait animpos.death_delayed_ragdoll;
	guy delete();
	return;
	guy unlink();
	guy delete();
	return;
	guy startragdoll();
	wait 0.05;
	guy delete();
	wait 40;
	guy delete();
// SP = 0x0 - check OK
}

// 0x2D38
load_ai( array, bgoddriver )
{
	bgoddriver = 0;
	array = vehicle_get_riders();
	array_ent_thread( array, ::get_in_vehicle, bgoddriver );
// SP = 0x0 - check OK
}

// 0x2D74
is_rider( guy )
{
	i = 0;
	return 1;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x2DA8
vehicle_get_riders()
{
	array = [];
	ai = getaiarray( self.vteam );
	i = 0;
	guy = ai[i];
	array[array.size] = guy;
	i++;
	return array;
// SP = 0x0 - check OK
}

// 0x2E14
get_my_vehicleride()
{
	array = [];
/#
	assert( IsDefined( self.script_vehicleride ), "Tried to get my ride but I have no .script_vehicleride" );
#/
	vehicles = getentarray( "script_vehicle", "classname" );
	i = 0;
	vehicle = vehicles[i];
	array[array.size] = vehicle;
	i++;
/#
	assert( array.size == 1, "Tried to get my ride but there was zero or multiple rides to choose from" );
#/
	return array[0];
// SP = 0x0 - check OK
}

// 0x2EB0
get_in_vehicle( guy, bgoddriver )
{
	return;
	return;
/#
	assert( isalive( guy ), "tried to load a vehicle with dead guy, check your AI count to assure spawnability of ai's" );
#/
	guy run_to_vehicle( self, bgoddriver );
// SP = 0x0 - check OK
}

// 0x2F04
handle_detached_guys_check()
{
	return 1;
/#
	assertmsg( "script sent too many ai to vehicle( max is: " + level.vehicle_aianims[self.vehicletype].size + " )" );
#/
// SP = 0x0 - check OK
}

// 0x2F38
vehicle_hasavailablespots()
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x2F5C
run_to_vehicle_loaded( vehicle )
{
	vehicle endon( "death" );
	self waittill_any( "long_death", "death", "enteredvehicle" );
	arrayremovevalue( vehicle.runningtovehicle, self );
	vehicle notify( "loaded" );
// SP = 0x0 - check OK
}

// 0x2FBC
remove_magic_bullet_shield_from_guy_on_unload_or_death( guy )
{
	self waittill_any( "unload", "death" );
	guy stop_magic_bullet_shield();
// SP = 0x0 - check OK
}

// 0x2FE4
run_to_vehicle( vehicle, bgoddriver, seat_tag )
{
	bgoddriver = 0;
	vehicleanim = vehicle get_aianims();
	vehicle thread [[vehicle.runtovehicleoverride]]( self );
	return;
	vehicle endon( "death" );
	self endon( "death" );
	vehicle.runningtovehicle[vehicle.runningtovehicle.size] = self;
	self thread run_to_vehicle_loaded( vehicle );
	availablepositions = [];
	chosenorg = undefined;
	origin = 0;
	bisgettin = 0;
	i = 0;
	bisgettin = 1;
	i++;
	self notify( "enteredvehicle" );
	self enter_vehicle( vehicle );
	return;
	wait 0.05;
	positions = vehicle get_availablepositions();
	chosenorg = vehicle vehicle_getinstart( 0 );
/#
	assert( !(IsDefined( self.magic_bullet_shield )), "magic_bullet_shield guy told to god mode drive a vehicle, you should simply load_ai without the god function for this guy" );
#/
	self thread magic_bullet_shield();
	vehicle thread remove_magic_bullet_shield_from_guy_on_unload_or_death( self );
	position_valid = -1;
	i = 0;
	position_valid = i;
	i++;
	chosenorg = positions.availablepositions[position_valid];
	chosenorg = getclosest( self.origin, positions.availablepositions );
	chosenorg = undefined;
	i = 0;
	j = 0;
	chosenorg = positions.availablepositions[j];
	j++;
	i++;
	chosenorg = getclosest( self.origin, positions.availablepositions );
	chosenorg = undefined;
	self notify( "enteredvehicle" );
	self enter_vehicle( vehicle );
	return;
	return;
	self.forced_startingposition = chosenorg.pos;
	vehicle.usedpositions[chosenorg.pos] = 1;
	self.script_moveoverride = 1;
	self notify( "stop_going_to_node" );
	self set_forcegoal();
	self.goalradius = 64;
	self setgoalpos( chosenorg.origin );
	self waittill( "goal" );
	self unset_forcegoal();
	self animscripted( "anim_wait_done", self.origin, self.angles, vehicleanim[chosenorg.pos].waiting );
	vehicle waittill( vehicleanim[chosenorg.pos].wait_for_notify );
	self set_forcegoal();
	self.goalradius = 64;
	self setgoalpos( chosenorg.origin );
	self waittill( "goal" );
	self unset_forcegoal();
	self animscripted( "anim_wait_done", self.origin, self.angles, vehicleanim[chosenorg.pos].waiting );
	on_vehicle = 0;
	i = 0;
	on_vehicle++;
	i++;
	wait 0.05;
	self set_forcegoal();
	self.goalradius = 16;
	self setgoalpos( chosenorg.origin );
	self waittill( "goal" );
	self unset_forcegoal();
	self.allowdeath = 0;
	vehicle = vehicle getanimatemodel();
	vehicle thread setanimrestart_once( vehicleanim[chosenorg.pos].vehicle_getinanim, vehicleanim[chosenorg.pos].vehicle_getinanim_clear );
	origin = vehicle gettagorigin( vehicleanim[chosenorg.pos].vehicle_getinsoundtag );
	origin = vehicle.origin;
	sound = vehicleanim[chosenorg.pos].vehicle_getinsound;
	sound = "veh_truck_door_open";
	vehicle thread maps\_utility::play_sound_in_space( sound, origin );
	vehicle animontag( self, vehicleanim[chosenorg.pos].sittag, vehicleanim[chosenorg.pos].getin );
	self notify( "enteredvehicle" );
	self enter_vehicle( vehicle );
// SP = 0x0 - check OK
}

// 0x3558
anim_pos( vehicle, pos )
{
	return vehicle get_aianims()[pos];
// SP = 0x0 - check OK
}

// 0x3574
anim_pos_from_tag( vehicle, tag )
{
	vehicleanims = level.vehicle_aianims[vehicle.vehicletype];
	keys = getarraykeys( vehicleanims );
	i = 0;
	pos = keys[i];
	return pos;
	i++;
// SP = 0x0 - check OK
}

// 0x35E4
guy_deathhandle( guy, pos )
{
	guy waittill( "death" );
	return;
	arrayremovevalue( self.riders, guy );
	self.usedpositions[pos] = 0;
// SP = 0x0 - check OK
}

// 0x3618
setup_aianimthreads()
{
	level.vehicle_aianimthread = [];
	level.vehicle_aianimcheck = [];
	level.vehicle_aianimthread["idle"] = ::guy_idle;
	level.vehicle_aianimthread["duck"] = ::guy_duck;
	level.vehicle_aianimthread["duck_once"] = ::guy_duck_once;
	level.vehicle_aianimcheck["duck_once"] = ::guy_duck_once_check;
	level.vehicle_aianimthread["weave"] = ::guy_weave;
	level.vehicle_aianimcheck["weave"] = ::guy_weave_check;
	level.vehicle_aianimthread["stand"] = ::guy_stand;
	level.vehicle_aianimthread["twitch"] = ::guy_twitch;
	level.vehicle_aianimthread["turn_right"] = ::guy_turn_right;
	level.vehicle_aianimcheck["turn_right"] = ::guy_turn_right_check;
	level.vehicle_aianimthread["turn_left"] = ::guy_turn_left;
	level.vehicle_aianimcheck["turn_left"] = ::guy_turn_right_check;
	level.vehicle_aianimthread["turn_hardright"] = ::guy_turn_hardright;
	level.vehicle_aianimthread["turn_hardleft"] = ::guy_turn_hardleft;
	level.vehicle_aianimthread["turret_fire"] = ::guy_turret_fire;
	level.vehicle_aianimthread["turret_turnleft"] = ::guy_turret_turnleft;
	level.vehicle_aianimthread["turret_turnright"] = ::guy_turret_turnright;
	level.vehicle_aianimthread["unload"] = ::guy_unload;
	level.vehicle_aianimthread["reaction"] = ::guy_turret_turnright;
	level.vehicle_aianimthread["drive_reaction"] = ::guy_drive_reaction;
	level.vehicle_aianimcheck["drive_reaction"] = ::guy_drive_reaction_check;
	level.vehicle_aianimthread["death_fire"] = ::guy_death_fire;
	level.vehicle_aianimcheck["death_fire"] = ::guy_death_fire_check;
	level.vehicle_aianimthread["move_to_driver"] = ::guy_move_to_driver;
// SP = 0x0 - check OK
}

// 0x37C0
guy_handle( guy, pos )
{
	guy.vehicle_idling = 1;
	guy.queued_anim_threads = [];
	thread guy_deathhandle( guy, pos );
	thread guy_queue_anim( guy, pos );
	guy endon( "death" );
	guy endon( "jumpedout" );
	self waittill( "groupedanimevent", other );
	waittillframeend;
	self.groupedanim_pos = undefined;
	add_anim_queue( guy, level.vehicle_aianimthread[other] );
	waittillframeend;
	self.queueanim = 0;
	guy notify( "newanim" );
	guy.queued_anim_threads = [];
	thread [[level.vehicle_aianimthread[other]]]( guy, pos );
/#
	println( "leaaaaaaaaaaaaaak", other );
#/
// SP = 0x0 - check OK
}

// 0x38C8
add_anim_queue( guy, sthread )
{
	guy.queued_anim_threads[guy.queued_anim_threads.size] = sthread;
// SP = 0x0 - check OK
}

// 0x38E8
guy_queue_anim( guy, pos )
{
	guy endon( "death" );
	self endon( "death" );
	lastanimframe = GetTime() - 100;
	guy waittill( "anim_on_tag_done" );
	guy notify( "newanim" );
	thread [[guy.queued_anim_threads[0]]]( guy, pos );
	arrayremovevalue( guy.queued_anim_threads, guy.queued_anim_threads[0] );
	wait 0.05;
	guy waittill( "anim_on_tag_done" );
	lastanimframe = GetTime();
// SP = 0x0 - check OK
}

// 0x3984
guy_stand( guy, pos )
{
	animpos = anim_pos( self, pos );
	vehicleanim = self get_aianims();
	return;
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	animontag( guy, animpos.sittag, animpos.standup );
	guy_stand_attack( guy, pos );
// SP = 0x0 - check OK
}

// 0x39F0
guy_stand_attack( guy, pos )
{
	animpos = anim_pos( self, pos );
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	guy.standing = 1;
	timer2 = GetTime() + 2000;
	animontag( guy, animpos.sittag, guy.vehicle_standattack, undefined, undefined, "firing" );
	rnum = randomint( 5 ) + 10;
	i = 0;
	animontag( guy, animpos.sittag, animpos.standidle );
	i++;
// SP = 0x0 - check OK
}

// 0x3AAC
guy_stand_down( guy, pos )
{
	animpos = anim_pos( self, pos );
	thread guy_stand_attack( guy, pos );
	return;
	animontag( guy, animpos.sittag, animpos.standdown );
	guy.standing = 0;
	thread guy_idle( guy, pos );
// SP = 0x0 - check OK
}

// 0x3B10
driver_idle_speed( driver, pos )
{
	driver endon( "newanim" );
	self endon( "death" );
	driver endon( "death" );
	animpos = anim_pos( self, pos );
	driver.vehicle_idle = animpos.idle_animstop;
	driver.vehicle_idle = animpos.idle_anim;
	wait 0.25;
// SP = 0x0 - check OK
}

// 0x3B7C
guy_reaction( guy, pos )
{
	animpos = anim_pos( self, pos );
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	animontag( guy, animpos.sittag, animpos.reaction );
	thread guy_idle( guy, pos );
// SP = 0x0 - check OK
}

// 0x3BDC
guy_turret_turnleft( guy, pos )
{
	animpos = anim_pos( self, pos );
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	animontag( guy, animpos.sittag, guy.turret_turnleft );
// SP = 0x0 - check OK
}

// 0x3C2C
guy_turret_turnright( guy, pos )
{
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	animpos = anim_pos( self, pos );
	animontag( guy, animpos.sittag, guy.turret_turnleft );
// SP = 0x0 - check OK
}

// 0x3C80
guy_turret_fire( guy, pos )
{
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	animpos = anim_pos( self, pos );
	animontag( guy, animpos.sittag, animpos.turret_fire );
	thread guy_idle( guy, pos );
// SP = 0x0 - check OK
}

// 0x3CE0
guy_idle( guy, pos, ignoredeath )
{
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	guy.vehicle_idling = 1;
	guy notify( "gotime" );
	return;
	animpos = anim_pos( self, pos );
	return;
	guy hide();
	thread driver_idle_speed( guy, pos );
	guy notify( "idle" );
	animontag( guy, animpos.sittag, guy.vehicle_idle_override );
	theanim = randomoccurrance( guy, animpos.idleoccurrence );
	animontag( guy, animpos.sittag, guy.vehicle_idle[theanim] );
	animontag( guy, animpos.sittag, animpos.player_idle );
	self thread setanimrestart_once( animpos.vehicle_idle );
	animontag( guy, animpos.sittag, guy.vehicle_idle_combat );
	animontag( guy, animpos.sittag, guy.vehicle_idle_pistol );
	animontag( guy, animpos.sittag, guy.vehicle_idle );
// SP = 0x0 - check OK
}

// 0x3EDC
randomoccurrance( guy, occurrences )
{
	range = [];
	totaloccurrance = 0;
	i = 0;
	totaloccurrance += occurrences[i];
	range[i] = totaloccurrance;
	i++;
	pick = randomint( totaloccurrance );
	i = 0;
	return i;
	i++;
// SP = 0x0 - check OK
}

// 0x3F50
guy_duck_once_check( guy, pos )
{
	return IsDefined( anim_pos( self, pos ).duck_once );
// SP = 0x0 - check OK
}

// 0x3F6C
guy_duck_once( guy, pos )
{
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	animpos = anim_pos( self, pos );
	self thread setanimrestart_once( animpos.vehicle_duck_once );
	animontag( guy, animpos.sittag, animpos.duck_once );
	thread guy_idle( guy, pos );
// SP = 0x0 - check OK
}

// 0x3FE8
guy_weave_check( guy, pos )
{
	return IsDefined( anim_pos( self, pos ).weave );
// SP = 0x0 - check OK
}

// 0x4004
guy_weave( guy, pos )
{
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	animpos = anim_pos( self, pos );
	self thread setanimrestart_once( animpos.vehicle_weave );
	animontag( guy, animpos.sittag, animpos.weave );
	thread guy_idle( guy, pos );
// SP = 0x0 - check OK
}

// 0x4080
guy_duck( guy, pos )
{
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	animpos = anim_pos( self, pos );
	animontag( guy, animpos.sittag, animpos.duckin );
	thread guy_duck_idle( guy, pos );
// SP = 0x0 - check OK
}

// 0x40E0
guy_duck_idle( guy, pos )
{
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	animpos = anim_pos( self, pos );
	theanim = randomoccurrance( guy, animpos.duckidleoccurrence );
	animontag( guy, animpos.sittag, animpos.duckidle[theanim] );
// SP = 0x0 - check OK
}

// 0x414C
guy_duck_out( guy, pos )
{
	animpos = anim_pos( self, pos );
	animontag( guy, animpos.sittag, animpos.duckout );
	guy.ducking = 0;
	thread guy_idle( guy, pos );
// SP = 0x0 - check OK
}

// 0x41AC
guy_twitch( guy, pos )
{
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	animpos = anim_pos( self, pos );
	self thread setanimrestart_once( animpos.vehicle_idle_twitchin, 0 );
	animontag( guy, animpos.sittag, animpos.idle_twitchin );
	thread guy_twitch_idle( guy, pos );
// SP = 0x0 - check OK
}

// 0x422C
guy_twitch_idle( guy, pos )
{
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	animpos = anim_pos( self, pos );
	theanim = randomint( animpos.idle_twitch.size );
	animontag( guy, animpos.sittag, animpos.idle_twitch[theanim] );
// SP = 0x0 - check OK
}

// 0x4294
guy_unload_que( guy )
{
	self endon( "death" );
	self.unloadque[self.unloadque.size] = guy;
	guy waittill_any( "death", "jumpedout" );
	arrayremovevalue( self.unloadque, guy );
	self notify( "unloaded" );
	self.unload_group = "default";
// SP = 0x0 - check OK
}

// 0x42EC
riders_unloadable( unload_group )
{
	return 0;
	i = 0;
/#
	assert( IsDefined( self.riders[i].pos ) );
#/
	return 1;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x4354
check_unloadgroup( pos, unload_group )
{
	unload_group = self.unload_group;
	type = self.vehicletype;
	return 1;
/#
	println( "Invalid Unload group on node at origin: " + self.currentnode.origin + " with group:( \"" + unload_group + "\" )" );
	println( "Unloading everybody" );
#/
	return 1;
	group = level.vehicle_unloadgroups[type][unload_group];
	i = 0;
	return 1;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x4400
getoutrig_model_idle( model, tag, animation )
{
	self endon( "unload" );
	animontag( model, tag, animation );
// SP = 0x0 - check OK
}

// 0x4430
getoutrig_model( animpos, model, tag, animation, bidletillunload )
{
	type = self.vehicletype;
	thread getoutrig_model_idle( model, tag, level.vehicle_attachedmodels[type][animpos.getoutrig].idleanim );
	self waittill( "unload" );
	self.unloadque[self.unloadque.size] = model;
	self thread getoutrig_abort( model, tag, animation );
	animontag( model, tag, animation );
	model unlink();
	model delete();
	return;
/#
	assert( IsDefined( self.unloadque ) );
#/
	arrayremovevalue( self.unloadque, model );
	self notify( "unloaded" );
	self.getoutrig[animpos.getoutrig] = undefined;
	wait 10;
	model delete();
// SP = 0x0 - check OK
}

// 0x4514
getoutrig_disable_abort_notify_after_riders_out()
{
	wait 0.05;
	wait 0.05;
	return;
	self notify( "getoutrig_disable_abort" );
// SP = 0x0 - check OK
}

// 0x4570
getoutrig_abort_while_deploying()
{
	self endon( "end_getoutrig_abort_while_deploying" );
	wait 0.05;
	array_delete( self.riders );
	self notify( "crashed_while_deploying" );
// SP = 0x0 - check OK
}

// 0x45A4
getoutrig_abort( model, tag, animation )
{
	totalanimtime = getanimlength( animation );
	ropesfallanimtime = totalanimtime - 1;
	ropesfallanimtime = totalanimtime - 0.5;
/#
	assert( totalanimtime > 2.5 );
#/
/#
	assert( ropesfallanimtime - 2.5 > 0 );
#/
	self endon( "getoutrig_disable_abort" );
	thread getoutrig_disable_abort_notify_after_riders_out();
	thread getoutrig_abort_while_deploying();
	waittill_notify_or_timeout( "crashed_while_deploying", 2.5 );
	self notify( "end_getoutrig_abort_while_deploying" );
	wait 0.05;
	thread animontag( model, tag, animation );
	waittillframeend;
	model setanimtime( animation, ropesfallanimtime / totalanimtime );
	i = 0;
	self.riders[i] damage_notify_wrapper( 100, self.riders[i].ridingvehicle );
	i++;
// SP = 0x0 - check OK
}

// 0x4710
setanimrestart_once( vehicle_anim, bclearanim )
{
	self endon( "death" );
	self endon( "dont_clear_anim" );
	bclearanim = 1;
	cycletime = getanimlength( vehicle_anim );
	self setanimrestart( vehicle_anim );
	wait cycletime;
	self clearanim( vehicle_anim, 0 );
// SP = 0x0 - check OK
}

// 0x4768
getout_rigspawn( animatemodel, pos, bidletillunload )
{
	bidletillunload = 1;
	type = self.vehicletype;
	animpos = anim_pos( self, pos );
	overrridegetoutrig = 1;
	overrridegetoutrig = 0;
	return;
	origin = animatemodel gettagorigin( level.vehicle_attachedmodels[type][animpos.getoutrig].tag );
	angles = animatemodel gettagangles( level.vehicle_attachedmodels[type][animpos.getoutrig].tag );
	self.getoutriganimating[animpos.getoutrig] = 1;
	getoutrig_model = spawn( "script_model", origin );
	getoutrig_model.angles = angles;
	getoutrig_model.origin = origin;
	getoutrig_model setmodel( level.vehicle_attachedmodels[type][animpos.getoutrig].model );
	self.getoutrig[animpos.getoutrig] = getoutrig_model;
	getoutrig_model useanimtree( -1 );
	getoutrig_model setforcenocull();
	getoutrig_model linkto( animatemodel, level.vehicle_attachedmodels[type][animpos.getoutrig].tag, ( 0, 0, 0 ), ( 0, 0, 0 ) );
	thread getoutrig_model( animpos, getoutrig_model, level.vehicle_attachedmodels[type][animpos.getoutrig].tag, level.vehicle_attachedmodels[type][animpos.getoutrig].dropanim, bidletillunload );
	return getoutrig_model;
// SP = 0x0 - check OK
}

// 0x4904
check_sound_tag_dupe( soundtag )
{
	self.sound_tag_dupe = [];
	duped = 0;
	self.sound_tag_dupe[soundtag] = 1;
	duped = 1;
	thread check_sound_tag_dupe_reset( soundtag );
	return duped;
// SP = 0x0 - check OK
}

// 0x4950
check_sound_tag_dupe_reset( soundtag )
{
	wait 0.05;
	return;
	self.sound_tag_dupe[soundtag] = 0;
	keys = getarraykeys( self.sound_tag_dupe );
	i = 0;
	return;
	i++;
	self.sound_tag_dupe = undefined;
// SP = 0x0 - check OK
}

// 0x49AC
guy_unload( guy, pos )
{
	animpos = anim_pos( self, pos );
	type = self.vehicletype;
	thread guy_idle( guy, pos );
	return;
	thread guy_idle( guy, pos );
	return;
	guy show();
	guy.takedamage = guy.script_toggletakedamage;
	self thread guy_unload_que( guy );
	self endon( "death" );
	guy endon( "death" );
	animatemodel = getanimatemodel();
	animatemodel thread setanimrestart_once( animpos.vehicle_getoutanim_pistol, animpos.vehicle_getoutanim_clear );
	self notify( "open_door_climbout" );
	sound_tag_dupped = 0;
	sound_tag_dupped = check_sound_tag_dupe( animpos.vehicle_getoutsoundtag );
	origin = animatemodel gettagorigin( animpos.vehicle_getoutsoundtag );
	origin = animatemodel.origin;
	sound = "veh_truck_door_open";
	self thread maps\_utility::play_sound_in_space( sound, origin );
	sound_tag_dupped = undefined;
	animatemodel thread setanimrestart_once( animpos.vehicle_getoutanim, animpos.vehicle_getoutanim_clear );
	self notify( "open_door_climbout" );
	sound_tag_dupped = 0;
	sound_tag_dupped = check_sound_tag_dupe( animpos.vehicle_getoutsoundtag );
	origin = animatemodel gettagorigin( animpos.vehicle_getoutsoundtag );
	origin = animatemodel.origin;
	sound = "veh_truck_door_open";
	self thread maps\_utility::play_sound_in_space( sound, origin );
	sound_tag_dupped = undefined;
	delay = 0;
	delay += getanimlength( animpos.getout_timed_anim );
	delay += animpos.delay;
	delay += guy.delay;
	thread guy_idle( guy, pos );
	wait delay;
	hascombatjumpout = IsDefined( animpos.getout_combat );
	haspistoljumpout = IsDefined( animpos.getout_pistol );
	guy_stand_down( guy, pos );
	guy waittill( "idle" );
	guy.deathanim = undefined;
	guy notify( "newanim" );
	guy pushplayer( 1 );
	bnoanimunload = 0;
	bnoanimunload = 1;
	self thread guy_idle( guy, pos );
	return;
	guy.health = guy.orghealth;
	guy.orghealth = undefined;
	guy endon( "death" );
	guy.allowdeath = 0;
	tag = animpos.exittag;
	tag = animpos.sittag;
	animation = animpos.getout_combat;
	animation = animpos.getout_combat;
	animation = animpos.getout_pistol;
	animation = guy.get_out_override;
	animation = animpos.player_getout;
	animation = animpos.getout;
	_vehicle_turret_clear_user( guy, animpos.sittag );
	self thread guy_unlink_on_death( guy );
	thread guy_idle( guy, pos );
	getoutrig_model = self getout_rigspawn( animatemodel, guy.pos, 0 );
	guy thread play_sound_on_tag( animpos.getoutsnd, "J_Wrist_RI", 1 );
	guy thread play_sound_on_entity( animpos.player_getout_sound );
	guy thread play_loop_sound_on_tag( animpos.getoutloopsnd );
	get_players()[0] thread play_loop_sound_on_entity( animpos.player_getout_sound_loop );
	guy notify( "newanim" );
	guy notify( "jumping_out" );
	guy.b_rappelling = 1;
	guy.ragdoll_getout_death = 1;
	guy.ragdoll_getout_death = 1;
	guy.ragdoll_fall_anim = animpos.ragdoll_fall_anim;
	animontag( guy, tag, animation );
	secondaryunloadtag = tag;
	secondaryunloadtag = animpos.getout_secondary_tag;
	animontag( guy, secondaryunloadtag, animpos.getout_secondary );
	get_players()[0] thread stop_loop_sound_on_entity( animpos.player_getout_sound_loop );
	guy thread stop_loop_sound_on_entity( animpos.getoutloopsnd );
	get_players()[0] thread play_sound_on_entity( animpos.player_getout_sound_end );
	arrayremovevalue( self.riders, guy );
	self.usedpositions[pos] = 0;
	guy.ridingvehicle = undefined;
	guy.drivingvehicle = undefined;
	guy notify( "exit_vehicle" );
	level notify( "helicopter_unloaded_ai", guy );
	guy.b_rappelling = 0;
	guy delete();
	return;
	guy unlink();
	guy.allowdeath = 1;
	guy delete();
	return;
	guy delete();
	return;
	guy delete();
	return;
	guy.a.disablelongdeath = 0;
	guy.forced_startingposition = undefined;
	guy notify( "jumpedout" );
	guy.desired_anim_pose = animpos.getoutstance;
	guy allowedstances( "crouch" );
	guy thread animscripts\utility::updateanimpose();
	guy allowedstances( "stand", "crouch", "prone" );
	guy pushplayer( 0 );
	qsetgoalpos = 0;
	qsetgoalpos = 0;
	qsetgoalpos = 1;
	targetednodes = getnodearray( guy.target, "targetname" );
	qsetgoalpos = 1;
	guy.goalradius = 600;
	guy setgoalpos( guy.origin );
// SP = 0x8 - check failed (function may have been decompiled incorrectly)
}

// 0x5288
animontag( guy, tag, animation, notetracks, sthreads, flag )
{
	guy notify( "animontag_thread" );
	guy endon( "animontag_thread" );
	flag = "animontagdone";
	animatemodel = self.modeldummy;
	animatemodel = self;
	org = guy.origin;
	angles = guy.angles;
	org = animatemodel gettagorigin( tag );
	angles = animatemodel gettagangles( tag );
	level thread animontag_ragdoll_death( guy, self );
	guy animscripted( flag, org, angles, animation );
	thread donotetracks( guy, animatemodel, flag );
	i = 0;
	guy waittillmatch( flag );
	return notetracks[i];
	guy thread [[sthreads[i]]]();
	i++;
	guy waittillmatch( flag );
	return "end";
	guy notify( "anim_on_tag_done" );
	guy.ragdoll_getout_death = undefined;
// SP = 0x0 - check OK
}

// 0x53AC
animontag_ragdoll_death_watch_for_damage()
{
	self endon( "anim_on_tag_done" );
	self waittill( "damage", damage, attacker, damagedirection, damagepoint, damagemod );
	self notify( "vehicle_damage", damage, attacker, damagedirection, damagepoint, damagemod );
// SP = 0x0 - check OK
}

// 0x53F0
animontag_ragdoll_death_watch_for_damage_notdone()
{
	self endon( "anim_on_tag_done" );
	self waittill( "damage_notdone", damage, attacker, damagedirection, damagepoint, damagemod );
	self notify( "vehicle_damage", damage, attacker, damagedirection, damagepoint, damagemod );
// SP = 0x0 - check OK
}

// 0x5434
animontag_ragdoll_death( guy, vehicle )
{
	return;
	guy setcandamage( 1 );
	guy endon( "anim_on_tag_done" );
	guy thread animontag_ragdoll_death_watch_for_damage();
	guy thread animontag_ragdoll_death_watch_for_damage_notdone();
	damage = undefined;
	attacker = undefined;
	damagedirection = undefined;
	damagepoint = undefined;
	damagemod = undefined;
	explosivedamage = 0;
	vehicleallreadydead = vehicle.health <= 0;
	guy waittill( "vehicle_damage", damage, attacker, damagedirection, damagepoint, damagemod );
	explosivedamage = isexplosivedamagemod( damagemod );
	return;
	guy.deathanim = undefined;
	guy.deathfunction = undefined;
	guy.anim_disablepain = 1;
	movedelta = getmovedelta( guy.ragdoll_fall_anim, 0, 1 );
	groundpos = physicstrace( guy.origin + vector_scale( ( 0, 0, 1 ), 16 ), guy.origin - vector_scale( ( 0, 0, 1 ), 10000 ) );
	distancefromground = distance( guy.origin + vector_scale( ( 0, 0, 1 ), 16 ), groundpos );
	guy thread play_sound_on_entity( "generic_death_falling" );
	guy animscripted( "fastrope_fall", guy.origin, guy.angles, guy.ragdoll_fall_anim );
	guy waittillmatch( "fastrope_fall" );
	return "start_ragdoll";
	return;
	guy.deathanim = undefined;
	guy.deathfunction = undefined;
	guy.anim_disablepain = 1;
	guy dodamage( guy.health + 100, attacker.origin, attacker );
	guy stopanimscripted();
	guy.delayeddeath = 0;
	guy.allowdeath = 1;
	guy.nogibdeathanim = 1;
	guy.health = guy.maxhealth;
	guy dodamage( guy.health + 100, damagepoint, attacker, -1, "explosive" );
	guy animscripts\utility::do_ragdoll_death();
// SP = 0x0 - check OK
}

// 0x56E8
isexplosivedamagemod( mod )
{
	return 0;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x5730
donotetracks( guy, vehicle, flag )
{
	guy endon( "newanim" );
	vehicle endon( "death" );
	guy endon( "death" );
	guy animscripts\shared::donotetracks( flag );
// SP = 0x0 - check OK
}

// 0x5760
animatemoveintoplace( guy, org, angles, movetospotanim )
{
	guy animscripted( "movetospot", org, angles, movetospotanim );
	guy waittillmatch( "movetospot" );
	return "end";
// SP = 0x0 - check OK
}

// 0x5790
guy_vehicle_death( guy )
{
	animpos = anim_pos( self, guy.pos );
	self endon( "unload" );
	guy endon( "death" );
	self endon( "forcedremoval" );
	self waittill( "death" );
	thread guy_idle( guy, guy.pos, 1 );
	wait animpos.unload_ondeath;
	self.groupedanim_pos = guy.pos;
	self notify( "groupedanimevent", "unload" );
	return;
	origin = guy.origin;
	guy delete();
	[[level.global_kill_func]]( "MOD_RIFLE_BULLET", "torso_upper", origin );
// SP = 0x0 - check OK
}

// 0x5848
guy_turn_right_check( guy, pos )
{
	return IsDefined( anim_pos( self, pos ).turn_right );
// SP = 0x0 - check OK
}

// 0x5864
guy_turn_right( guy, pos )
{
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	animpos = anim_pos( self, pos );
	thread setanimrestart_once( animpos.vehicle_turn_right );
	animontag( guy, animpos.sittag, animpos.turn_right );
	thread guy_idle( guy, pos );
// SP = 0x0 - check OK
}

// 0x58D4
guy_turn_left( guy, pos )
{
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	animpos = anim_pos( self, pos );
	self thread setanimrestart_once( animpos.vehicle_turn_left );
	animontag( guy, animpos.sittag, animpos.turn_left );
	thread guy_idle( guy, pos );
// SP = 0x0 - check OK
}

// 0x5948
guy_turn_left_check( guy, pos )
{
	return IsDefined( anim_pos( self, pos ).turn_left );
// SP = 0x0 - check OK
}

// 0x5964
guy_turn_hardright( guy, pos )
{
	animpos = level.vehicle_aianims[self.vehicletype][pos];
	guy.vehicle_idle_override = animpos.idle_hardright;
// SP = 0x0 - check OK
}

// 0x5998
guy_turn_hardleft( guy, pos )
{
	animpos = level.vehicle_aianims[self.vehicletype][pos];
	guy.vehicle_idle_override = animpos.idle_hardleft;
// SP = 0x0 - check OK
}

// 0x59CC
guy_drive_reaction( guy, pos )
{
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	animpos = anim_pos( self, pos );
	animontag( guy, animpos.sittag, animpos.drive_reaction );
	thread guy_idle( guy, pos );
// SP = 0x0 - check OK
}

// 0x5A20
guy_drive_reaction_check( guy, pos )
{
	return IsDefined( anim_pos( self, pos ).drive_reaction );
// SP = 0x0 - check OK
}

// 0x5A3C
guy_death_fire( guy, pos )
{
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	animpos = anim_pos( self, pos );
	animontag( guy, animpos.sittag, animpos.death_fire );
	thread guy_idle( guy, pos );
// SP = 0x0 - check OK
}

// 0x5A90
guy_death_fire_check( guy, pos )
{
	return IsDefined( anim_pos( self, pos ).death_fire );
// SP = 0x0 - check OK
}

// 0x5AAC
guy_move_to_driver( guy, pos )
{
	guy endon( "newanim" );
	self endon( "death" );
	guy endon( "death" );
	pos = 0;
	animpos = anim_pos( self, pos );
	guy.pos = 0;
	guy.drivingvehicle = 1;
	guy.vehicle_idle = animpos.idle;
	guy.ridingvehicle = self;
	guy.orghealth = guy.health;
	arrayremovevalue( self.attachedguys, self.attachedguys[1] );
	self.attachedguys[0] = guy;
	animontag( guy, animpos.sittag, animpos.move_to_driver );
	guy unlink();
	guy linkto( self, animpos.sittag );
	wait 0.05;
	thread guy_idle( guy, pos );
	guy notify( "moved_to_driver" );
// SP = 0x0 - check OK
}

// 0x5B94
ai_wait_go()
{
	self endon( "death" );
	self waittill( "loaded" );
	self maps\_vehicle::gopath();
// SP = 0x0 - check OK
}

// 0x5BB4
set_pos( guy, maxpos )
{
	pos = undefined;
	script_startingposition = IsDefined( guy.script_startingposition );
	pos = guy.forced_startingposition;
/#
	assert( pos >= 0, "script_startingposition on a vehicle rider must be between " + maxpos + " and 0" );
#/
	return pos;
	pos = guy.script_startingposition;
/#
	assert( pos >= 0, "script_startingposition on a vehicle rider must be between " + maxpos + " and 0" );
#/
/#
	println( "vehicle rider with script_startingposition: " + guy.script_startingposition + " and script_vehicleride: " + self.script_vehicleride + " that's been taken" );
#/
/#
	assertmsg( "startingposition conflict, see console" );
#/
	lowestpassengerindex = 0;
	lowestpassengerindex = self.vehicle_numdrivers;
	j = lowestpassengerindex;
	pos = j;
	j++;
	return pos;
// SP = 0x0 - check OK
}

// 0x5CE8
guy_man_gunner_turret()
{
	self notify( "animontag_thread" );
	self endon( "animontag_thread" );
	self endon( "death" );
	self.vehicle endon( "death" );
	animpos = anim_pos( self.vehicle, self.vehicle_pos );
	self animmode( "point relative" );
	org = self.vehicle gettagorigin( animpos.sittag );
	org2 = self.vehicle gettagorigin( "tag_gunner_turret1" );
/#
	recordline( self.vehicle.origin, org, ( 1, 0, 0 ), "Script", self );
	recordline( self.vehicle.origin, org2, ( 0, 1, 0 ), "Script", self );
#/
	self setanimknobrestart( animpos.stunned, 1, 0.25, 1 );
	wait 0.1;
	self clearanim( %root, 0.05 );
	firing = self.vehicle isgunnerfiring( animpos.vehiclegunner - 1 );
	baseanim = animpos.idle;
	upanim = animpos.aimup;
	downanim = animpos.aimdown;
	vehicle_baseanim = animpos.vehicle_idle;
	vehicle_upanim = animpos.vehicle_aimup;
	vehicle_downanim = animpos.vehicle_aimdown;
	self setanim( baseanim, 1 );
	self.vehicle setanim( vehicle_baseanim, 1 );
	pitchdelta = self.vehicle getgunneranimpitch( animpos.vehiclegunner - 1 );
	pitchdelta = 60;
	weight = pitchdelta / 60;
	self setanimlimited( downanim, weight, 0.05 );
	self setanimlimited( baseanim, 1 - weight, 0.05 );
	pitchdelta = 0 - 60;
	weight = 0 - pitchdelta / 60;
	self setanimlimited( upanim, weight, 0.05 );
	self setanimlimited( baseanim, 1 - weight, 0.05 );
	wait 0.05;
// SP = 0x18 - check failed (function may have been decompiled incorrectly)
}

// 0x6014
guy_man_turret( guy, pos )
{
	animpos = anim_pos( self, pos );
	turret = self.mgturret[animpos.mgturret];
	turret setdefaultdroppitch( 0 );
	wait 0.1;
	turret endon( "death" );
	guy endon( "death" );
	turret setmode( "auto_ai" );
	turret setturretignoregoals( 1 );
	guy.script_on_vehicle_turret = 1;
	guy useturret( turret );
	wait 1;
// SP = 0x0 - check OK
}

// 0x60B0
guy_unlink_on_death( guy )
{
	guy endon( "jumpedout" );
	guy waittill( "death" );
	guy unlink();
// SP = 0x0 - check OK
}

// 0x60DC
blowup_riders()
{
	self array_ent_thread( self.riders, ::guy_blowup );
// SP = 0x0 - check OK
}

// 0x60F8
guy_blowup( guy )
{
	return;
	pos = guy.pos;
	anim_pos = anim_pos( self, pos );
	return;
	[[level.global_kill_func]]( "MOD_RIFLE_BULLET", "torso_upper", guy.origin );
	deathanim = anim_pos.explosion_death;
	deathanim = guy.explosion_death_override;
	angles = self.angles;
	origin = guy.origin;
	origin += vector_scale( anglestoforward( angles ), anim_pos.explosion_death_offset[0] );
	origin += vector_scale( anglestoright( angles ), anim_pos.explosion_death_offset[1] );
	origin += vector_scale( anglestoup( angles ), anim_pos.explosion_death_offset[2] );
	guy = convert_guy_to_drone( guy );
	detach_models_with_substr( guy, "weapon_" );
	guy notsolid();
	guy.origin = origin;
	guy.angles = angles;
	guy stopanimscripted();
	guy animscripted( "deathanim", origin, angles, deathanim );
	fraction = 0.3;
	fraction = anim_pos.explosion_death_ragdollfraction;
	animlength = getanimlength( anim_pos.explosion_death );
	timer = GetTime() + animlength * 1000;
	wait animlength * fraction;
	force = ( 0, 0, 1 );
	org = guy.origin;
	guy delete();
	return;
	org = guy.origin;
	wait 0.05;
	force = guy.origin - org;
	guy startragdoll();
	wait 0.05;
	force = vector_scale( force, 20000 );
	i = 0;
	org = guy.origin;
	wait 0.05;
	i++;
	guy delete();
	wait 40;
	guy delete();
// SP = 0x0 - check OK
}

// 0x634C
convert_guy_to_drone( guy, bkeepguy )
{
	bkeepguy = 0;
	model = spawn( "script_model", guy.origin );
	model.angles = guy.angles;
	model setmodel( guy.model );
	size = guy getattachsize();
	i = 0;
	model attach( guy getattachmodelname( i ), guy getattachtagname( i ) );
	i++;
	model useanimtree( -1 );
	model.team = guy.team;
	guy delete();
	model makefakeai();
	return model;
// SP = 0x0 - check OK
}

// 0x6424
vehicle_animate( animation, animtree )
{
	self useanimtree( animtree );
	self setanim( animation );
// SP = 0x0 - check OK
}

// 0x6448
vehicle_getinstart( pos )
{
	animpos = anim_pos( self, pos );
	return vehicle_getanimstart( animpos.getin, animpos.sittag, pos );
// SP = 0x0 - check OK
}

// 0x6478
vehicle_getanimstart( animation, tag, pos )
{
	struct = spawnstruct();
	origin = undefined;
	angles = undefined;
/#
	assert( IsDefined( animation ) );
#/
	org = self gettagorigin( tag );
	ang = self gettagangles( tag );
	origin = getstartorigin( org, ang, animation );
	angles = getstartangles( org, ang, animation );
	struct.origin = origin;
	struct.angles = angles;
	struct.pos = pos;
	return struct;
// SP = 0x0 - check OK
}

// 0x6510
get_availablepositions()
{
	vehicleanim = get_aianims();
	availablepositions = [];
	nonanimatedpositions = [];
	i = 0;
	availablepositions[availablepositions.size] = vehicle_getinstart( i );
	nonanimatedpositions[nonanimatedpositions.size] = i;
	i++;
	struct = spawnstruct();
	struct.availablepositions = availablepositions;
	struct.nonanimatedpositions = nonanimatedpositions;
	return struct;
// SP = 0x0 - check OK
}

// 0x65A8
set_walkerpos( guy, maxpos )
{
	pos = undefined;
	pos = guy.script_startingposition;
/#
	assert( pos >= 0, "script_startingposition on a vehicle rider must be between " + maxpos + " and 0" );
#/
	pos = -1;
	j = 0;
	pos = j;
	self.walk_tags_used[j] = 1;
	j++;
/#
	assert( pos >= 0, "Vehicle ran out of walking spots. This is usually caused by making more than 6 AI walk with a vehicle." );
#/
	return pos;
// SP = 0x0 - check OK
}

// 0x664C
walkwithvehicle( guy, pos )
{
	self.walkers = [];
	self.walkers[self.walkers.size] = guy;
	guy.followmode = "close";
	guy.walkingvehicle = self;
	guy.vehiclewalkmember = pos;
	level thread vehiclewalker_freespot_ondeath( guy );
	guy notify( "stop friendly think" );
	guy vehiclewalker_updategoalpos( self, "once" );
	guy thread vehiclewalker_removeonunload( self );
	guy thread vehiclewalker_updategoalpos( self );
	guy thread vehiclewalker_teamunderattack();
// SP = 0x0 - check OK
}

// 0x66F4
vehiclewalker_removeonunload( vehicle )
{
	vehicle endon( "death" );
	vehicle waittill( "unload" );
	arrayremovevalue( vehicle.walkers, self );
// SP = 0x0 - check OK
}

// 0x671C
shiftsides( side )
{
	return;
/#
	iprintln( "Valid sides are 'left' and 'right' only" );
#/
	return;
	return;
	return;
	i = 0;
	self notify( "stop updating goalpos" );
	self setgoalpos( self.walkingvehicle.backpos.origin );
	self.walkingvehicle.walk_tags_used[self.vehiclewalkmember] = 0;
	self.vehiclewalkmember = i;
	self.walkingvehicle.walk_tags_used[self.vehiclewalkmember] = 1;
	self waittill( "goal" );
	self thread vehiclewalker_updategoalpos( self.walkingvehicle );
	self.vehiclewalkmember = i;
	return;
/#
	iprintln( "TANKAI: Guy couldn't move to the " + side + " side of the tank because no positions on that side are free" );
#/
	i++;
// SP = 0x0 - check OK
}

// 0x6850
vehiclewalker_freespot_ondeath( guy )
{
	guy waittill( "death" );
	return;
	guy.walkingvehicle.walk_tags_used[guy.vehiclewalkmember] = 0;
// SP = 0x0 - check OK
}

// 0x6880
vehiclewalker_teamunderattack()
{
	self endon( "death" );
	self waittill( "damage", amount, attacker );
	self.walkingvehicle.teamunderattack = 1;
	self.walkingvehicle notify( "unload" );
	return;
// SP = 0x0 - check OK
}

// 0x692C
getnewnodepositionaheadofvehicle( guy )
{
	minimumdistance = 300 + 50 * self getspeedmph();
	nextnode = undefined;
	return self.origin;
	nextnode = getvehiclenode( self.currentnode.target, "targetname" );
	return guy.nodeaftervehiclewalk.origin;
	return self.origin;
	return nextnode.origin;
	return nextnode.origin;
	nextnode = getvehiclenode( nextnode.target, "targetname" );
	return guy.nodeaftervehiclewalk.origin;
	return self.origin;
// SP = 0x0 - check OK
}

// 0x6A28
vehiclewalker_updategoalpos( tank, option )
{
	self endon( "death" );
	tank endon( "death" );
	self endon( "stop updating goalpos" );
	self endon( "unload" );
	self.oldgoalradius = self.goalradius;
	self.goalradius = 300;
	self.walkdist = 64;
	position = tank getnewnodepositionaheadofvehicle( self );
	self.oldgoalradius = self.goalradius;
	self.goalradius = 2;
	self.walkdist = 64;
	position = tank gettagorigin( tank.walk_tags[self.vehiclewalkmember] );
	trace = bullettrace( position + vector_scale( ( 0, 0, 1 ), 100 ), position - vector_scale( ( 0, 0, 1 ), 500 ), 0, undefined );
	self teleport( trace["position"] );
	self setgoalpos( trace["position"] );
	return;
	tankspeed = tank getspeedmph();
	trace = bullettrace( position + vector_scale( ( 0, 0, 1 ), 100 ), position - vector_scale( ( 0, 0, 1 ), 500 ), 0, undefined );
	self setgoalpos( trace["position"] );
	wait 0.5;
// SP = 0x0 - check OK
}

// 0x6B78
getanimatemodel()
{
	return self.modeldummy;
	return self;
// SP = 0x0 - check OK
}

// 0x6B94
animpos_override_standattack( type, pos, animation )
{
	level.vehicle_aianims[type][pos].vehicle_standattack = animation;
// SP = 0x0 - check OK
}

// 0x6BB4
detach_models_with_substr( guy, substr )
{
	size = guy getattachsize();
	modelstodetach = [];
	tagsstodetach = [];
	i = 0;
	modelname = guy getattachmodelname( i );
	tagname = guy getattachtagname( i );
	modelstodetach[0] = modelname;
	tagsstodetach[0] = tagname;
	i++;
	i = 0;
	guy detach( modelstodetach[i], tagsstodetach[i] );
	i++;
// SP = 0x0 - check OK
}

// 0x6C64
should_give_orghealth()
{
	return 0;
	return 0;
	return !(IsDefined( self.magic_bullet_shield ));
// SP = 0x0 - check OK
}

// 0x6C8C
get_aianims()
{
	vehicleanims = level.vehicle_aianims[self.vehicletype];
	keys = getarraykeys( vehicleanims );
	i = 0;
	key = keys[i];
	override = self.vehicle_aianims[key];
	vehicleanims[key].idle = override.idle;
	vehicleanims[key].getout = override.getout;
	vehicleanims[key].getin = override.getin;
	vehicleanims[key].waiting = override.waiting;
	i++;
	return vehicleanims;
// SP = 0x0 - check OK
}

// 0x6D64
override_anim( action, tag, animation )
{
	pos = anim_pos_from_tag( self, tag );
/#
	assert( IsDefined( pos ), "_vehicle_aianim::override_anim - No valid position set up for tag '" + tag + "' on vehicle of type '" + self.vehicletype + "'." );
#/
	self.vehicle_aianims[pos] = spawnstruct();
	switch ( action )
	{
		case "getin":
			self.vehicle_aianims[pos].getin = animation;
			break;
		case "getout":
			self.vehicle_aianims[pos].idle = animation;
			break;
		case "idle":
			self.vehicle_aianims[pos].getout = animation;
			break;
		default:
/#
			assertmsg( "_vehicle_aianim::override_anim - '" + action + "' action is not supported for overriding the animation." );
#/
	}
// SP = 0x0 - check OK
}