// maps/mp/killstreaks/_turret_killstreak.gsc

#include maps\mp\killstreaks\_ai_tank;
#include maps\mp\animscripts\dog_flashed;
#include maps\mp\_scrambler;
#include maps\mp\killstreaks\_remote_weapons;
#include maps\mp\gametypes\_weaponobjects;
#include maps\mp\gametypes\_globallogic_audio;
#include maps\mp\_challenges;
#include maps\mp\_scoreevents;
#include maps\mp\gametypes\_damagefeedback;
#include maps\mp\gametypes\_globallogic_player;
#include maps\mp\gametypes\_spawning;
#include maps\mp\_hacker_tool;
#include maps\mp\_entityheadicons;
#include maps\mp\killstreaks\_killstreakrules;
#include maps\mp\killstreaks\_supplydrop;
#include maps\mp\killstreaks\_killstreaks;
#include maps\mp\gametypes\_tweakables;
#include maps\mp\_mgturret;
#include maps\mp\gametypes\_weapons;
#include maps\mp\gametypes\_hud_util;
#include common_scripts\utility;
#include maps\mp\_utility;

#using_animtree ( "mp_microwaveturret" );


// 0x2FB8
init()
{
	precacheturret( "auto_gun_turret_mp" );
	precacheturret( "microwave_turret_mp" );
	precachemodel( "t6_wpn_turret_sentry_gun" );
	precachemodel( "t6_wpn_turret_sentry_gun_yellow" );
	precachemodel( "t6_wpn_turret_sentry_gun_red" );
	precachemodel( "t6_wpn_turret_ads_world" );
	precachemodel( "t6_wpn_turret_ads_carry" );
	precachemodel( "t6_wpn_turret_ads_carry_animate" );
	precachemodel( "t6_wpn_turret_ads_carry_animate_red" );
	precachemodel( "t6_wpn_turret_ads_carry_red" );
	precachemodel( "tag_microwavefx" );
	precacheshellshock( "mp_radiation_high" );
	precacheshellshock( "mp_radiation_med" );
	precacheshellshock( "mp_radiation_low" );
	precacheitem( "killstreak_remote_turret_mp" );
	thread maps\mp\_mgturret::init_turret_difficulty_settings();
	level.auto_turret_timeout = 240;
	level.microwave_radius = 750;
	level.microwave_turret_cone_dot = cos( 45 );
	level.microwave_turret_angle = 90;
	level.microwave_turret_damage = 10;
	level.microwave_fx_size = 150;
	flag_init( "end_target_confirm" );
	level.auto_turret_settings = [];
	level.microwaveopenanim = %o_hpm_open;
	level.microwavecloseanim = %o_hpm_close;
	level.microwavedestroyedanim = %o_hpm_destroyed;
	level.auto_turret_settings["sentry"] = spawnstruct();
	level.auto_turret_settings["sentry"].hintstring = &"KILLSTREAK_SENTRY_TURRET_PICKUP";
	level.auto_turret_settings["sentry"].hackerhintstring = &"KILLSTREAK_TURRET_HACKING";
	level.auto_turret_settings["sentry"].disablehintstring = &"KILLSTREAK_TURRET_SENTRY_DISABLE";
	level.auto_turret_settings["sentry"].hinticon = "hud_ks_auto_turret";
	level.auto_turret_settings["sentry"].modelbase = "t6_wpn_turret_sentry_gun";
	level.auto_turret_settings["sentry"].modelgoodplacement = "t6_wpn_turret_sentry_gun_yellow";
	level.auto_turret_settings["sentry"].modelbadplacement = "t6_wpn_turret_sentry_gun_red";
	level.auto_turret_settings["sentry"].stunfx = loadfx( "weapon/sentry_gun/fx_sentry_gun_emp_stun" );
	level.auto_turret_settings["sentry"].stunfxtag = "tag_origin";
	level.auto_turret_settings["sentry"].damagefx = loadfx( "weapon/sentry_gun/fx_sentry_gun_damage_state" );
	level.auto_turret_settings["sentry"].disablefx = loadfx( "weapon/sentry_gun/fx_sentry_gun_death_state" );
	level.auto_turret_settings["sentry"].explodefx = loadfx( "weapon/sentry_gun/fx_sentry_gun_exp" );
	level.auto_turret_settings["sentry"].stunfxfrequencymin = 0.1;
	level.auto_turret_settings["sentry"].stunfxfrequencymax = 0.75;
	level.auto_turret_settings["sentry"].turretinitdelay = 1.6;
	level.auto_turret_settings["sentry"].hackertoolradius = level.sentryhackertoolradius;
	level.auto_turret_settings["sentry"].hackertooltimems = level.sentryhackertooltimems;
	level.auto_turret_settings["tow"] = spawnstruct();
	level.auto_turret_settings["tow"].hintstring = &"KILLSTREAK_TOW_TURRET_PICKUP";
	level.auto_turret_settings["tow"].hackerhintstring = &"KILLSTREAK_TURRET_HACKING";
	level.auto_turret_settings["tow"].hinticon = "hud_ks_sam_turret";
	level.auto_turret_settings["tow"].modelbase = "t6_wpn_turret_sam";
	level.auto_turret_settings["tow"].modelgoodplacement = "t6_wpn_turret_sam_yellow";
	level.auto_turret_settings["tow"].modelbadplacement = "t6_wpn_turret_sam_red";
	level.auto_turret_settings["tow"].stunfx = loadfx( "weapon/grenade/fx_spark_disabled_weapon_lg" );
	level.auto_turret_settings["tow"].stunfxtag = "TAG_aim";
	level.auto_turret_settings["tow"].stunfxfrequencymin = 0.1;
	level.auto_turret_settings["tow"].stunfxfrequencymax = 0.75;
	level.auto_turret_settings["tow"].turretinitdelay = 3;
	level.auto_turret_settings["tow"].turretfiredelay = 5;
	level.auto_turret_settings["microwave"] = spawnstruct();
	level.auto_turret_settings["microwave"].hintstring = &"KILLSTREAK_MICROWAVE_TURRET_PICKUP";
	level.auto_turret_settings["microwave"].hackerhintstring = &"KILLSTREAK_TURRET_MICROWAVE_HACKING";
	level.auto_turret_settings["microwave"].disablehintstring = &"KILLSTREAK_TURRET_MICROWAVE_DISABLE";
	level.auto_turret_settings["microwave"].hinticon = "hud_ks_microwave_turret";
	level.auto_turret_settings["microwave"].modelbase = "t6_wpn_turret_ads_world";
	level.auto_turret_settings["microwave"].modelgoodplacement = "t6_wpn_turret_ads_carry";
	level.auto_turret_settings["microwave"].modelgoodplacementanimate = "t6_wpn_turret_ads_carry_animate";
	level.auto_turret_settings["microwave"].modelbadplacementanimate = "t6_wpn_turret_ads_carry_animate_red";
	level.auto_turret_settings["microwave"].modelbadplacement = "t6_wpn_turret_ads_carry_red";
	level.auto_turret_settings["microwave"].stunfx = loadfx( "weapon/silent_gaurdian/fx_sg_emp_stun" );
	level.auto_turret_settings["microwave"].loopsoundfx = "wpn_sguard_beam";
	level.auto_turret_settings["microwave"].stunfxtag = "tag_origin";
	level.auto_turret_settings["microwave"].damagefx = loadfx( "weapon/silent_gaurdian/fx_sg_damage_state" );
	level.auto_turret_settings["microwave"].disablefx = loadfx( "weapon/silent_gaurdian/fx_sg_death_state" );
	level.auto_turret_settings["microwave"].explodefx = loadfx( "weapon/silent_gaurdian/fx_sg_exp" );
	level.auto_turret_settings["microwave"].stunfxfrequencymin = 0.1;
	level.auto_turret_settings["microwave"].stunfxfrequencymax = 0.75;
	level.auto_turret_settings["microwave"].turretinitdelay = 1;
	level.auto_turret_settings["microwave"].timeout = 240;
	level.auto_turret_settings["microwave"].fxchecktime = 5;
	level.auto_turret_settings["microwave"].hackertoolradius = level.microwavehackertoolradius;
	level.auto_turret_settings["microwave"].hackertooltimems = level.microwavehackertooltimems;
	level.auto_turret_settings["microwave"].microwave_radius_1 = int( level.microwave_radius / 8 );
	level.auto_turret_settings["microwave"].microwave_radius_2 = int( level.microwave_radius / 2 );
	level.auto_turret_settings["microwave"].microwave_radius_3 = int( level.microwave_radius * 3 / 4 );
	level.auto_turret_settings["microwave"].microwave_radius_4 = int( level.microwave_radius );
	level.auto_turret_settings["microwave"].fx = loadfx( "weapon/silent_gaurdian/fx_sg_distortion_cone_ash" );
	level._turret_explode_fx = loadfx( "explosions/fx_exp_equipment_lg" );
	minefields = getentarray( "minefield", "targetname" );
	hurt_triggers = getentarray( "trigger_hurt", "classname" );
	level.fatal_triggers = arraycombine( minefields, hurt_triggers, 1, 0 );
	level.noturretplacementtriggers = getentarray( "no_turret_placement", "targetname" );
	level notify( "no_turret_trigger_created" );
	maps\mp\killstreaks\_killstreaks::registerkillstreak( "autoturret_mp", "autoturret_mp", "killstreak_auto_turret", "auto_turret_used", ::usesentryturretkillstreak );
	maps\mp\killstreaks\_killstreaks::registerkillstreakaltweapon( "autoturret_mp", "auto_gun_turret_mp" );
	maps\mp\killstreaks\_killstreaks::registerkillstreakremoteoverrideweapon( "autoturret_mp", "killstreak_remote_turret_mp" );
	maps\mp\killstreaks\_killstreaks::registerkillstreakstrings( "autoturret_mp", &"KILLSTREAK_EARNED_AUTO_TURRET", &"KILLSTREAK_AUTO_TURRET_NOT_AVAILABLE" );
	maps\mp\killstreaks\_killstreaks::registerkillstreakdialog( "autoturret_mp", "mpl_killstreak_auto_turret", "kls_turret_used", "", "kls_turret_enemy", "", "kls_turret_ready" );
	maps\mp\killstreaks\_killstreaks::registerkillstreakdevdvar( "autoturret_mp", "scr_giveautoturret" );
	maps\mp\killstreaks\_killstreaks::registerkillstreak( "turret_drop_mp", "turret_drop_mp", "killstreak_auto_turret_drop", "auto_turret_used", ::usekillstreakturretdrop, undefined, 1 );
	maps\mp\killstreaks\_killstreaks::registerkillstreakremoteoverrideweapon( "turret_drop_mp", "killstreak_remote_turret_mp" );
	maps\mp\killstreaks\_killstreaks::registerkillstreakstrings( "turret_drop_mp", &"KILLSTREAK_EARNED_AUTO_TURRET", &"KILLSTREAK_AIRSPACE_FULL" );
	maps\mp\killstreaks\_killstreaks::registerkillstreakdialog( "turret_drop_mp", "mpl_killstreak_turret", "kls_turret_used", "", "kls_turret_enemy", "", "kls_turret_ready" );
	maps\mp\killstreaks\_killstreaks::registerkillstreakdevdvar( "turret_drop_mp", "scr_giveautoturretdrop" );
	maps\mp\killstreaks\_supplydrop::registercratetype( "turret_drop_mp", "killstreak", "autoturret_mp", 1, &"KILLSTREAK_AUTO_TURRET_CRATE", undefined, "MEDAL_SHARE_PACKAGE_AUTO_TURRET", maps\mp\killstreaks\_supplydrop::givecratekillstreak );
	level.killstreakicons["autoturret_mp"] = "hud_ks_auto_turret";
	maps\mp\killstreaks\_killstreaks::registerkillstreak( "microwaveturret_mp", "microwaveturret_mp", "killstreak_microwave_turret", "microwave_turret_used", ::usemicrowaveturretkillstreak );
	maps\mp\killstreaks\_killstreaks::registerkillstreakaltweapon( "microwaveturret_mp", "microwave_turret_mp" );
	maps\mp\killstreaks\_killstreaks::registerkillstreakaltweapon( "microwaveturret_mp", "microwave_turret_damage_mp" );
	maps\mp\killstreaks\_killstreaks::registerkillstreakstrings( "microwaveturret_mp", &"KILLSTREAK_EARNED_MICROWAVE_TURRET", &"KILLSTREAK_MICROWAVE_TURRET_NOT_AVAILABLE" );
	maps\mp\killstreaks\_killstreaks::registerkillstreakdialog( "microwaveturret_mp", "mpl_killstreak_auto_turret", "kls_microwave_used", "", "kls_microwave_enemy", "", "kls_microwave_ready" );
	maps\mp\killstreaks\_killstreaks::registerkillstreakdevdvar( "microwaveturret_mp", "scr_givemicrowaveturret" );
	maps\mp\killstreaks\_killstreaks::setkillstreakteamkillpenaltyscale( "microwaveturret_mp", level.teamkillreducedpenalty );
	maps\mp\killstreaks\_killstreaks::registerkillstreak( "microwaveturret_drop_mp", "microwaveturret_drop_mp", "killstreak_microwave_turret_drop", "microwave_turret_used", ::usekillstreakturretdrop, undefined, 1 );
	maps\mp\killstreaks\_killstreaks::registerkillstreakstrings( "microwaveturret_drop_mp", &"KILLSTREAK_EARNED_MICROWAVE_TURRET", &"KILLSTREAK_AIRSPACE_FULL" );
	maps\mp\killstreaks\_killstreaks::registerkillstreakdialog( "microwaveturret_drop_mp", "mpl_killstreak_turret", "kls_microwave_used", "", "kls_microwave_enemy", "", "kls_microwave_ready" );
	maps\mp\killstreaks\_killstreaks::registerkillstreakdevdvar( "microwaveturret_drop_mp", "scr_givemicrowaveturretdrop" );
	maps\mp\killstreaks\_supplydrop::registercratetype( "microwaveturret_drop_mp", "killstreak", "microwaveturret_mp", 1, &"KILLSTREAK_MICROWAVE_TURRET_CRATE", undefined, "MEDAL_SHARE_PACKAGE_MICROWAVE_TURRET", maps\mp\killstreaks\_supplydrop::givecratekillstreak );
	level.killstreakicons["microwaveturret_mp"] = "hud_ks_microwave_turret";
	level.turrets_headicon_offset = [];
	level.turrets_headicon_offset["default"] = vector_scale( ( 0, 0, 1 ), 70 );
	level.turrets_headicon_offset["sentry"] = vector_scale( ( 0, 0, 1 ), 70 );
	level.turrets_headicon_offset["tow"] = vector_scale( ( 0, 0, 1 ), 65 );
	level.turrets_headicon_offset["microwave"] = vector_scale( ( 0, 0, 1 ), 80 );
	level.turrets_hacker_trigger_width = 72;
	level.turrets_hacker_trigger_height = 96;
	setdvar( "scr_turret_no_timeout", 0 );
	setdvar( "turret_sentryTargetTime", 1500 );
	setdvar( "turret_TargetLeadBias", 1.5 );
	registerclientfield( "turret", "turret_microwave_sounds", 1000, 1, "int" );
// SP = 0x0 - check OK
}

// 0x3968
usekillstreakturretdrop( hardpointtype )
{
	return 0;
	result = self maps\mp\killstreaks\_supplydrop::usesupplydropmarker();
	self notify( "supply_drop_marker_done" );
	return 0;
	return result;
// SP = 0x0 - check OK
}

// 0x39AC
usesentryturretkillstreak( hardpointtype )
{
	return 0;
	return 0;
	killstreak_id = self maps\mp\killstreaks\_killstreakrules::killstreakstart( hardpointtype, self.team );
	return 0;
	turret = self usesentryturret( hardpointtype );
	turret.killstreak_id = killstreak_id;
	event = turret waittill_any_return( "turret_placed", "destroy_turret", "death", "turret_emped" );
	level.globalkillstreakscalled++;
	self addweaponstat( hardpointtype, "used", 1 );
	return 1;
	returnturrettoinventory( turret );
	return 0;
	level.globalkillstreakscalled++;
	self addweaponstat( hardpointtype, "used", 1 );
	turret notify( "destroy_turret", 0 );
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x3AA4
usetowturretkillstreak( hardpointtype )
{
	return 0;
	killstreak_id = self maps\mp\killstreaks\_killstreakrules::killstreakstart( hardpointtype, self.team );
	return 0;
	turret = self usetowturret( hardpointtype );
	turret.killstreak_id = killstreak_id;
	event = turret waittill_any_return( "turret_placed", "destroy_turret", "death", "turret_emped" );
	return 1;
	returnturrettoinventory( turret );
	return 0;
	turret notify( "destroy_turret", 0 );
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x3B5C
usemicrowaveturretkillstreak( hardpointtype )
{
	return 0;
	return 0;
	killstreak_id = self maps\mp\killstreaks\_killstreakrules::killstreakstart( hardpointtype, self.team );
	return 0;
	turret = self usemicrowaveturret( hardpointtype );
	turret.killstreak_id = killstreak_id;
	event = turret waittill_any_return( "turret_placed", "destroy_turret", "death", "turret_emped" );
	level.globalkillstreakscalled++;
	self addweaponstat( hardpointtype, "used", 1 );
	return 1;
	returnturrettoinventory( turret );
	return 0;
	level.globalkillstreakscalled++;
	self addweaponstat( hardpointtype, "used", 1 );
	turret notify( "destroy_turret", 0 );
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x3C54
usesentryturret( hardpointtype )
{
	self maps\mp\killstreaks\_killstreaks::switchtolastnonkillstreakweapon();
	level.globalkillstreakscalled++;
	self addweaponstat( hardpointtype, "used", 1 );
	turret = spawnturret( "auto_turret", self.origin, "auto_gun_turret_mp" );
	turret.turrettype = "sentry";
	turret setturrettype( turret.turrettype );
	turret setmodel( level.auto_turret_settings[turret.turrettype].modelgoodplacement );
	turret.angles = self.angles;
	turret.hardpointweapon = hardpointtype;
	turret.hasbeenplanted = 0;
	turret.waitfortargettobeginlifespan = 0;
	self.turret_active = 0;
	self.curr_time = -1;
	turret.stunnedbytacticalgrenade = 0;
	turret.stuntime = 0;
	turret setturretowner( self );
	turret setturretminimapvisible( 1 );
	turret.isfrominventory = self.usingkillstreakfrominventory;
	turret setdrawinfrared( 1 );
	target_set( turret, vector_scale( ( 0, 0, 1 ), 40 ) );
	turret.controlled = 0;
	self.numturrets = 1;
	self.numturrets++;
	turret.ownernumber = self.numturrets;
	turret setturretteam( self.team );
	turret.team = self.team;
	turret setturretteam( "free" );
	turret.team = "free";
	setupturrethealth( turret );
	turret.carried = 1;
	turret.curr_time = 0;
	turret.stunduration = 5;
	turret.remotecontrolled = 0;
	turret thread watchturretlifespan();
	self thread watchownerdisconnect( turret );
	self thread watchownerteamkillkicked( turret );
	turret thread destroyturret();
	turret thread turret_target_aquired_watch( self );
	turret thread turret_target_lost_watch( self );
	self thread startcarryturret( turret );
	return turret;
// SP = 0x0 - check OK
}

// 0x3E6C
usetowturret( hardpointtype )
{
	self maps\mp\killstreaks\_killstreaks::switchtolastnonkillstreakweapon();
	level.globalkillstreakscalled++;
	self addweaponstat( hardpointtype, "used", 1 );
	turret = spawnturret( "auto_turret", self.origin, "tow_turret_mp" );
	turret.turrettype = "tow";
	turret setturrettype( turret.turrettype );
	turret setmodel( level.auto_turret_settings[turret.turrettype].modelgoodplacement );
	turret.angles = self.angles;
	turret.hardpointweapon = hardpointtype;
	turret.hasbeenplanted = 0;
	turret.waitfortargettobeginlifespan = 0;
	turret.firetime = level.auto_turret_settings["tow"].turretfiredelay;
	self.turret_active = 0;
	turret.stunnedbytacticalgrenade = 0;
	turret.stuntime = 0;
	turret setturretowner( self );
	turret setturretminimapvisible( 1 );
	turret.isfrominventory = self.usingkillstreakfrominventory;
	turret setturretteam( self.team );
	turret.team = self.team;
	turret setturretteam( "free" );
	turret.team = "free";
	setupturrethealth( turret );
	turret.carried = 1;
	turret.curr_time = 0;
	turret.stunduration = 5;
	turret setscanningpitch( -35 );
	turret thread watchturretlifespan();
	self thread watchownerdisconnect( turret );
	self thread watchownerteamkillkicked( turret );
	turret thread destroyturret();
	self thread startcarryturret( turret );
	return turret;
// SP = 0x0 - check OK
}

// 0x4038
usemicrowaveturret( hardpointtype )
{
	self maps\mp\killstreaks\_killstreaks::switchtolastnonkillstreakweapon();
	level.globalkillstreakscalled++;
	self addweaponstat( hardpointtype, "used", 1 );
	turret = spawnturret( "auto_turret", self.origin, "microwave_turret_mp" );
	turret.turrettype = "microwave";
	turret setturrettype( turret.turrettype );
	turret setmodel( level.auto_turret_settings[turret.turrettype].modelgoodplacement );
	turret.angles = self.angles;
	turret.hardpointweapon = hardpointtype;
	turret.hasbeenplanted = 0;
	turret.waitfortargettobeginlifespan = 0;
	self.turret_active = 0;
	self.curr_time = -1;
	turret.stunnedbytacticalgrenade = 0;
	turret.stuntime = 0;
	turret setturretowner( self );
	turret setturretminimapvisible( 1 );
	turret.isfrominventory = self.usingkillstreakfrominventory;
	turret setdrawinfrared( 1 );
	turret.controlled = 0;
	turret.soundmod = "hpm";
	target_set( turret, vector_scale( ( 0, 0, 1 ), 30 ) );
	turret setturretteam( self.team );
	turret.team = self.team;
	turret setturretteam( "free" );
	turret.team = "free";
	setupturrethealth( turret );
	turret.carried = 1;
	turret.curr_time = 0;
	turret.stunduration = 5;
	turret thread watchturretlifespan();
	self thread watchownerdisconnect( turret );
	turret thread destroyturret();
	self thread startcarryturret( turret );
	return turret;
// SP = 0x0 - check OK
}

// 0x420C
watchroundandgameend( turret )
{
	self endon( "disconnect" );
	turret notify( "watchRoundAndGameEnd" );
	turret endon( "watchRoundAndGameEnd" );
	turret endon( "destroy_turret" );
	turret endon( "hacked" );
	turret endon( "death" );
	level waittill( "game_ended" );
	self stopcarryturret( turret );
	turret notify( "destroy_turret", 0 );
// SP = 0x0 - check OK
}

// 0x4258
giveturretback( turret )
{
	maps\mp\killstreaks\_killstreaks::givekillstreak( turret.hardpointweapon, undefined, undefined, 1 );
// SP = 0x0 - check OK
}

// 0x429C
watchownerdeath( turret )
{
	self endon( "disconnect" );
	turret endon( "turret_placed" );
	turret endon( "destroy_turret" );
	turret endon( "hacked" );
	self waittill( "death" );
	self returnturrettoinventory( turret );
	self stopcarryturret( turret );
	turret notify( "destroy_turret", 0 );
	placement = self canplayerplaceturret( turret );
	turret.origin = placement["origin"];
	turret.angles = placement["angles"];
	self placeturret( turret );
	self stopcarryturret( turret );
	turret notify( "destroy_turret", 0 );
	self stopcarryturret( turret );
	turret notify( "destroy_turret", 0 );
// SP = 0x0 - check OK
}

// 0x439C
returnturrettoinventory( turret )
{
	self stopcarryturret( turret );
	turret notify( "destroy_turret", 0 );
	turret setturretcarried( 0 );
	self stopcarryturret( turret );
	turret notify( "destroy_turret", 0 );
	self _enableweapon();
// SP = 0x0 - check OK
}

// 0x440C
watchowneremp( turret )
{
	self endon( "disconnect" );
	self endon( "death" );
	turret endon( "turret_placed" );
	turret endon( "destroy_turret" );
	turret endon( "hacked" );
	self waittill( "emp_jammed" );
	turret setturretcarried( 0 );
	self stopcarryturret( turret );
	self _enableweapon();
	self takeweapon( turret.hardpointweapon );
	turret notify( "turret_emped" );
	self placeturret( turret );
	self stopcarryturret( turret );
	turret notify( "turret_emped", 0 );
// SP = 0x0 - check OK
}

// 0x44CC
watchownerteamkillkicked( turret )
{
	turret endon( "turret_deactivated" );
	turret endon( "hacked" );
	turret endon( "destroy_turret" );
	self waittill( "teamKillKicked" );
	turret notify( "destroy_turret", 0 );
// SP = 0x0 - check OK
}

// 0x4500
watchownerdisconnect( turret )
{
	turret endon( "turret_deactivated" );
	turret endon( "hacked" );
	self waittill_any( "disconnect", "joined_team" );
	turret notify( "destroy_turret", 1 );
// SP = 0x0 - check OK
}

// 0x453C
startcarryturret( turret )
{
	turret maketurretunusable();
	turret setturretcarried( 1 );
	self _disableweapon();
	turret stoploopsound();
	turret setmode( "auto_ai" );
	turret notify( "stop_burst_fire_unmanned" );
	turret notify( "target_lost" );
	turret notify( "stop_microwave" );
	turret.carried = 1;
	level notify( "drop_objects_to_ground", turret.origin, 80 );
	self carryturret( turret, vector_scale( ( 1, 0, 0 ), 40 ), ( 0, 0, 0 ) );
	self thread watchownerdeath( turret );
	self thread watchowneremp( turret );
	self thread watchroundandgameend( turret );
	turret maps\mp\_entityheadicons::destroyentityheadicons();
	turret setturretowner( self );
	turret setdefaultdroppitch( -90 );
	self thread watchreturnturrettoinventory( turret );
	self thread updateturretplacement( turret );
	self thread watchturretplacement( turret );
	turret clearclientflag( 2 );
	turret setclientflag( 3 );
	self playsoundtoplayer( "mpl_turret_micro_startup", self );
	turret notify( "turret_carried" );
	turret notify( "turret_target_lost" );
// SP = 0x0 - check OK
}

// 0x46CC
watchreturnturrettoinventory( turret )
{
	self endon( "death" );
	self endon( "entering_last_stand" );
	self endon( "disconnect" );
	turret endon( "turret_placed" );
	turret endon( "turret_deactivated" );
	wait 0.05;
	returnturrettoinventory( turret );
	return;
	wait 0.05;
// SP = 0x0 - check OK
}

// 0x4728
updateturretplacement( turret )
{
	self endon( "death" );
	self endon( "entering_last_stand" );
	self endon( "disconnect" );
	turret endon( "turret_placed" );
	turret endon( "turret_deactivated" );
	lastplacedturret = -1;
	turret.canbeplaced = 0;
	firstmodel = 1;
	placement = self canplayerplaceturret( turret );
	turret.origin = placement["origin"];
	turret.angles = placement["angles"];
	good_spot_check = placement["result"] & !(turret turretinhurttrigger()) & !(turret turretinnoturretplacementtrigger());
	turret.canbeplaced = good_spot_check;
	turret setmodel( level.auto_turret_settings[turret.turrettype].modelgoodplacement );
	turret setmodel( level.auto_turret_settings[turret.turrettype].modelbadplacement );
	lastplacedturret = turret.canbeplaced;
	turret setmodel( level.auto_turret_settings[turret.turrettype].modelgoodplacementanimate );
	turret setmodel( level.auto_turret_settings[turret.turrettype].modelbadplacementanimate );
	firstmodel = 0;
	lastplacedturret = turret.canbeplaced;
	wait 0.05;
// SP = 0x0 - check OK
}

// 0x48B0
turretinhurttrigger()
{
	i = 0;
	return 1;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x48E8
turretinnoturretplacementtrigger()
{
	i = 0;
	return 1;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x4920
watchturretplacement( turret )
{
	self endon( "disconnect" );
	self endon( "death" );
	self endon( "entering_last_stand" );
	turret endon( "turret_placed" );
	turret endon( "turret_deactivated" );
	wait 0.05;
	placement = self canplayerplaceturret( turret );
	turret.origin = placement["origin"];
	turret.angles = placement["angles"];
	self placeturret( turret );
	wait 0.05;
// SP = 0x0 - check OK
}

// 0x49D0
placeturret( turret )
{
	return;
	turret setturretcarried( 0 );
	self stopcarryturret( turret, turret.origin, turret.angles );
	turret spawnturretpickuptrigger( self );
	turret maps\mp\_hacker_tool::registerwithhackertool( level.auto_turret_settings[turret.turrettype].hackertoolradius, level.auto_turret_settings[turret.turrettype].hackertooltimems );
	self thread initturret( turret );
	self _enableweapon();
	turret.carried = 0;
	turret.hasbeenplanted = 1;
	turret thread stunturrettacticalgrenade( turret.stunduration );
	turret playloopsound( level.auto_turret_settings[turret.turrettype].loopsoundfx );
	self playrumbleonentity( "damage_heavy" );
	turret notify( "turret_placed" );
// SP = 0x0 - check OK
}

// 0x4ADC
initturret( turret )
{
	maps\mp\_mgturret::turret_set_difficulty( turret, "fu" );
	turret setmodel( level.auto_turret_settings[turret.turrettype].modelbase );
	turret clearclientflag( 3 );
	turret setclientflag( 2 );
	turret setforcenocull();
	turret playsound( "mpl_turret_startup" );
	offset = level.turrets_headicon_offset["default"];
	offset = level.turrets_headicon_offset[turret.turrettype];
	turret maps\mp\_entityheadicons::setentityheadicon( self.pers["team"], self, offset );
	turret maketurretunusable();
	turret setmode( "auto_nonai" );
	turret setturretowner( self );
	turret.owner = self;
	turret setdefaultdroppitch( 45 );
	turret.dangerous_nodes = [];
	turret thread turret_sentry_think( self );
	turret thread turret_tow_think( self );
	turret thread turret_microwave_think( self );
	turret.turret_active = 1;
	turret.spawninfluencerid = maps\mp\gametypes\_spawning::create_auto_turret_influencer( turret.origin, turret.team, turret.angles );
	turret.spawninfluencercloseid = maps\mp\gametypes\_spawning::create_auto_turret_influencer_close( turret.origin, turret.team, turret.angles );
	turret thread watchdamage();
	turret thread checkforstundamage();
	wait 1;
	flag_set( "end_target_confirm" );
// SP = 0x0 - check OK
}

// 0x4CB4
setupturrethealth( turret )
{
	turret.health = 100000;
	turret.maxhealth = 650;
	turret.bulletdamagereduction = 0.6;
	turret.explosivedamagereduction = 2;
// SP = 0x0 - check OK
}

// 0x4CF0
watchdamage()
{
	self endon( "turret_deactivated" );
	medalgiven = 0;
	self.damagetaken = 0;
	low_health = 0;
	playfxontag( level.auto_turret_settings[self.turrettype].damagefx, self, level.auto_turret_settings[self.turrettype].stunfxtag );
	low_health = 1;
	self waittill( "damage", damage, attacker, direction, point, type, tagname, modelname, partname, weaponname );
	self.skipfutz = 1;
	self notify( "destroy_turret", 0 );
	return;
	allowperks = 1;
	attacker = attacker.owner;
	allowperks = 0;
	self.health += damage;
	damagetakenbefore = self.damagetaken;
	damage += int( damage * level.cac_armorpiercing_data );
	damage *= 5;
	self.damagetaken += self.bulletdamagereduction * damage;
	self.damagetaken += damage * 10;
	self.damagetaken += 200 * self.explosivedamagereduction;
	self.damagetaken += self.explosivedamagereduction * damage;
	attacker playlocalsound( "fly_riotshield_impact_knife" );
	self.damagetaken += self.maxhealth;
	self.damagetaken += damage;
	damagedealt = self.damagetaken - damagetakenbefore;
	self.owner sendkillstreakdamageevent( int( damagedealt ) );
	switch ( weaponname )
	{
		case "emp_grenade_mp":
			self thread stunturrettacticalgrenade( self.stunduration );
			attacker maps\mp\gametypes\_damagefeedback::updatedamagefeedback( type );
			attacker maps\mp\gametypes\_damagefeedback::updatedamagefeedback( type );
			break;
		default:
			attacker maps\mp\gametypes\_damagefeedback::updatedamagefeedback( type );
			break;
	}
	attacker maps\mp\gametypes\_damagefeedback::updatedamagefeedback( type );
	maps\mp\_scoreevents::processscoreevent( "destroyed_sentry_gun", attacker, self, weaponname );
	maps\mp\_scoreevents::processscoreevent( "destroyed_microwave_turret", attacker, self, weaponname );
	attacker maps\mp\_challenges::destroyedturret( weaponname );
	level.globalkillstreaksdestroyed++;
	attacker addweaponstat( self.hardpointweapon, "destroyed", 1 );
	attacker addweaponstat( weaponname, "destroyed_controlled_killstreak", 1 );
	owner = self.owner;
	owner maps\mp\gametypes\_globallogic_audio::leaderdialogonplayer( "sentry_destroyed", "item_destroyed" );
	owner maps\mp\gametypes\_globallogic_audio::leaderdialogonplayer( "microwave_destroyed", "item_destroyed" );
	owner stopcarryturret( self );
	self.damagetaken = self.health;
	self.dead = 1;
	self notify( "destroy_turret", 1 );
	playfxontag( level.auto_turret_settings[self.turrettype].damagefx, self, level.auto_turret_settings[self.turrettype].stunfxtag );
	low_health = 1;
// SP = 0x0 - check OK
}

// 0x52CC
watchturretlifespan( turret )
{
	self endon( "turret_deactivated" );
	self endon( "death" );
	timeout = level.auto_turret_timeout;
	timeout = level.auto_turret_settings[turret.turrettype].timeout;
	wait 0.1;
	self deleteturretusetrigger();
	self.curr_time += 1;
	wait 1;
	shouldtimeout = GetDvar( #"0xD3B62F34" );
	return;
	self notify( "destroy_turret", 1 );
// SP = 0x0 - check OK
}

// 0x53A8
checkforstundamage()
{
	self endon( "turret_deactivated" );
	self waittill( "damage_caused_by", weapon );
	self thread stunturrettacticalgrenade( self.stunduration );
// SP = 0x0 - check OK
}

// 0x53F4
stunturrettacticalgrenade( duration )
{
	self endon( "turret_deactivated" );
	self setmode( "auto_ai" );
	self notify( "stop_burst_fire_unmanned" );
	return;
	self.stunnedbytacticalgrenade = 1;
	self thread stunturretfx( duration, 0, 1 );
	self clearclientflag( 2 );
	self setclientflag( 3 );
	self notify( "microwave_end_fx" );
	self.owner freezecontrols( 1 );
	self.owner thread maps\mp\killstreaks\_remote_weapons::stunstaticfx( duration );
	return;
	self.stuntime += 0.1;
	wait 0.1;
	self.stunnedbytacticalgrenade = 0;
	self.stuntime = 0;
	self.owner freezecontrols( 0 );
	self setmode( "auto_nonai" );
	self thread maps\mp\_mgturret::burst_fire_unmanned();
	self clearclientflag( 3 );
	self setclientflag( 2 );
	wait 0.5;
	self thread microwave_fx();
	self notify( "turret_stun_ended" );
// SP = 0x0 - check OK
}

// 0x55A4
stunturret( duration, isdead, isemp )
{
	self endon( "turret_deactivated" );
	self setmode( "auto_ai" );
	self notify( "stop_burst_fire_unmanned" );
	self thread stunturretfx( duration, isdead, isemp );
	self.owner freezecontrols( 1 );
	self clearclientflag( 2 );
	self setclientflag( 4 );
	wait duration;
	return;
	self.owner freezecontrols( 0 );
	self setmode( "auto_nonai" );
	self thread maps\mp\_mgturret::burst_fire_unmanned();
	self notify( "turret_stun_ended" );
	level notify( "turret_stun_ended", self );
// SP = 0x0 - check OK
}

// 0x56B0
stunfxthink( fx )
{
	fx endon( "death" );
	self stoploopsound();
	self waittill_any( "death", "turret_stun_ended", "turret_deactivated", "hacked", "turret_carried" );
	self playloopsound( level.auto_turret_settings[self.turrettype].loopsoundfx );
	fx delete();
// SP = 0x0 - check OK
}

// 0x5728
stunturretfx( duration, isdead, isemp )
{
	self endon( "turret_deactivated" );
	self endon( "death" );
	self endon( "turret_stun_ended" );
	origin = self gettagorigin( level.auto_turret_settings[self.turrettype].stunfxtag );
	self.stun_fx = spawn( "script_model", origin );
	self.stun_fx setmodel( "tag_origin" );
	self thread stunfxthink( self.stun_fx );
	wait 0.1;
	self.stun_fx playsound( "dst_disable_spark" );
	time = 0;
	playfxontag( level.auto_turret_settings[self.turrettype].disablefx, self.stun_fx, "tag_origin" );
	playfxontag( level.auto_turret_settings[self.turrettype].stunfx, self.stun_fx, "tag_origin" );
	wait 0.25;
	time += 0.25;
// SP = 0x0 - check OK
}

// 0x5844
isstunweapon( weapon )
{
	switch ( weapon )
	{
		case "emp_grenade_mp":
			return 1;
		default:
			return 0;
	}
// SP = 0x0 - check OK
}

// 0x5874
scramblerstun( stun )
{
	self thread stunturret( 0, 1 );
	self setmode( "auto_nonai" );
	self thread maps\mp\_mgturret::burst_fire_unmanned();
	self notify( "turret_stun_ended" );
	level notify( "turret_stun_ended", self );
// SP = 0x0 - check OK
}

// 0x58D4
watchscramble()
{
	self endon( "death" );
	self endon( "turret_deactivated" );
	self endon( "turret_carried" );
	self thread scramblerstun( 1 );
	level waittill_any( "scrambler_spawn", "scrambler_death", "hacked", "turret_stun_ended" );
	wait 0.05;
	self thread scramblerstun( 1 );
	self scramblerstun( 0 );
// SP = 0x0 - check OK
}

// 0x595C
destroyturret()
{
	self waittill( "destroy_turret", playdeathanim );
	self remove_turret_dangerous_nodes();
	maps\mp\killstreaks\_killstreakrules::killstreakstop( "autoturret_mp", self.team, self.killstreak_id );
	self notify( "removed_on_death" );
	self.owner notify( "remove_remote_weapon", 1 );
	self.owner notify( "find_remote_weapon" );
	maps\mp\killstreaks\_killstreakrules::killstreakstop( "auto_tow_mp", self.team, self.killstreak_id );
	self notify( "microwave_end_fx" );
	maps\mp\killstreaks\_killstreakrules::killstreakstop( "microwaveturret_mp", self.team, self.killstreak_id );
	self.owner sendkillstreakdamageevent( 600 );
	self.owner destroy_remote_hud();
	self.turret_active = 0;
	self.curr_time = -1;
	self setmode( "auto_ai" );
	self notify( "stop_burst_fire_unmanned" );
	self notify( "turret_deactivated" );
	self deleteturretusetrigger();
	self playsound( "dst_equipment_destroy" );
	self stunturret( self.stunduration, 1, self.stunnedbytacticalgrenade );
	level notify( "drop_objects_to_ground", self.origin, 80 );
	removeinfluencer( self.spawninfluencerid );
	self.spawninfluencerid = undefined;
	removeinfluencer( self.spawninfluencercloseid );
	self.spawninfluencercloseid = undefined;
	self setturretminimapvisible( 0 );
	self laseroff();
	wait 0.1;
	playfx( level.auto_turret_settings[self.turrettype].explodefx, self.origin, self.angles );
	self playsound( "mpl_turret_exp" );
	self.owner stopcarryturret( self );
	self.owner _enableweapon();
	self delete();
// SP = 0x0 - check OK
}

// 0x5BC4
deleteturretusetrigger()
{
	self remove_turret_dangerous_nodes();
	self.pickuptrigger delete();
	self.hackertrigger.progressbar destroyelem();
	self.hackertrigger.progresstext destroyelem();
	self.hackertrigger delete();
	self.disabletrigger.progressbar destroyelem();
	self.disabletrigger.progresstext destroyelem();
	self.disabletrigger delete();
// SP = 0x0 - check OK
}

// 0x5C78
spawnturretpickuptrigger( player )
{
	pos = self.origin + vector_scale( ( 0, 0, 1 ), 15 );
	self.pickuptrigger = spawn( "trigger_radius_use", pos );
	self.pickuptrigger setcursorhint( "HINT_NOICON", self );
	self.pickuptrigger sethintstring( level.auto_turret_settings[self.turrettype].hintstring );
	self.pickuptrigger sethintstring( &"MP_GENERIC_PICKUP" );
	self.pickuptrigger setteamfortrigger( player.team );
	player clientclaimtrigger( self.pickuptrigger );
	self thread watchturretuse( self.pickuptrigger );
// SP = 0x0 - check OK
}

// 0x5D38
watchturretuse( trigger )
{
	self endon( "delete" );
	self endon( "turret_deactivated" );
	self endon( "turret_carried" );
	trigger waittill( "trigger", player );
	removeinfluencer( self.spawninfluencerid );
	self.spawninfluencerid = undefined;
	removeinfluencer( self.spawninfluencercloseid );
	self.spawninfluencercloseid = undefined;
	player playrumbleonentity( "damage_heavy" );
	self playsound( "mpl_turret_down" );
	self deleteturretusetrigger();
	self notify( "microwave_end_fx" );
	player notify( "remove_remote_weapon", 0 );
	player thread startcarryturret( self );
	self deleteturretusetrigger();
// SP = 0x0 - check OK
}

// 0x5EE4
turret_target_aquired_watch( player )
{
	level endon( "game_ended" );
	self endon( "death" );
	self endon( "destroy_turret" );
	player endon( "disconnect" );
	self waittill( "turret_target_aquired" );
	self laseron();
// SP = 0x0 - check OK
}

// 0x5F24
turret_target_lost_watch( player )
{
	level endon( "game_ended" );
	self endon( "death" );
	self endon( "destroy_turret" );
	player endon( "disconnect" );
	self waittill( "turret_target_lost" );
	self laseroff();
// SP = 0x0 - check OK
}

// 0x5F64
turret_sentry_think( player )
{
	self endon( "destroy_turret" );
	self.pickuptrigger endon( "trigger" );
	player maps\mp\killstreaks\_remote_weapons::initremoteweapon( self, "killstreak_remote_turret_mp" );
	wait level.auto_turret_settings[self.turrettype].turretinitdelay;
	self thread maps\mp\_mgturret::burst_fire_unmanned();
// SP = 0x0 - check OK
}

// 0x5FAC
turret_tow_think( player )
{
	self endon( "turret_deactivated" );
	self endon( "death" );
	player endon( "disconnect" );
	level endon( "game_ended" );
	turretstate = "started";
	self thread missile_fired_notify();
	wait level.auto_turret_settings[self.turrettype].turretinitdelay;
	turretstate = "firing";
	self playsound( "mpl_turret_alert" );
	self thread do_tow_shoot( player );
	self notify( "target_lost" );
	turretstate = "scanning";
	self waittill( "turretstatechange" );
	self notify( "target_lost" );
// SP = 0x0 - check OK
}

// 0x6054
deletetriggeronparentdeath( trigger )
{
	self waittill( "death" );
	trigger delete();
// SP = 0x0 - check OK
}

// 0x6078
doesmicrowaveturretaffectentity( entity )
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	entdirection = vectornormalize( entity.origin - self.origin );
	forward = anglestoforward( self.angles );
	dot = vectordot( entdirection, forward );
	return 0;
	pitchdifference = int( abs( vectortoangles( entdirection )[0] - self.angles[0] ) ) % 360;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x61B8
microwaveentity( entity )
{
	entity endon( "disconnect" );
	entity.beingmicrowaved = 1;
	entity.beingmicrowavedby = self.owner;
	entity.microwaveeffect = 0;
	return;
	entity.beingmicrowaved = 0;
	entity.beingmicrowavedby = undefined;
	entity.microwavepoisoning = 0;
	return;
	damage = level.microwave_turret_damage;
	damage /= 2;
	entity.microwavepoisoning = 1;
	entity.microwaveeffect = 0;
	entity dodamage( damage, self.origin, self.owner, self, 0, "MOD_TRIGGER_HURT", 0, "microwave_turret_mp" );
	entity.microwaveeffect++;
	entity shellshock( "mp_radiation_low", 1.5 );
	entity viewkick( 25, self.origin );
	entity shellshock( "mp_radiation_med", 1.5 );
	entity viewkick( 50, self.origin );
	entity shellshock( "mp_radiation_high", 1.5 );
	entity viewkick( 75, self.origin );
	maps\mp\_scoreevents::processscoreevent( "hpm_suppress", self.owner, entity );
	wait 0.5;
// SP = 0x0 - check OK
}

// 0x63E4
turret_microwave_think( player )
{
	self endon( "death" );
	level endon( "game_ended" );
	self endon( "stop_microwave" );
	self endon( "destroy_turret" );
	wait level.auto_turret_settings[self.turrettype].turretinitdelay;
	trigger = spawn( "trigger_radius", self.origin + ( 0, 0, level.microwave_radius * -1 ), level.aitriggerspawnflags | level.vehicletriggerspawnflags, level.microwave_radius, level.microwave_radius * 2 );
	trigger enablelinkto();
	trigger linkto( self );
	self thread deletetriggeronparentdeath( trigger );
	self thread microwave_fx();
	self thread turret_microwave_watchfordogs( trigger, player );
	trigger waittill( "trigger", ent );
	self thread microwaveentity( ent );
// SP = 0x0 - check OK
}

// 0x64BC
turret_microwave_watchfordogs( trigger, player )
{
	self endon( "death" );
	level endon( "game_ended" );
	self endon( "stop_microwave" );
	self endon( "destroy_turret" );
	damage = level.microwave_turret_damage;
	dogs = getentarray( "attack_dog", "targetname" );
	foreach ( dog in dogs )
	{
		dog.flashduration = 1000;
		dog thread maps\mp\animscripts\dog_flashed::main();
		dog dodamage( damage, self.origin, self.owner, self, 0, "MOD_TRIGGER_HURT", 0, "microwave_turret_mp" );
	}
	wait 0.5;
// SP = 0x0 - check OK
}

// 0x65AC
doesmicrowaveturretaffectdog( entity )
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	entdirection = vectornormalize( entity.origin - self.origin );
	forward = anglestoforward( self.angles );
	dot = vectordot( entdirection, forward );
	return 0;
	pitchdifference = int( abs( vectortoangles( entdirection )[0] - self.angles[0] ) ) % 360;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x66D8
microwave_fx()
{
	self endon( "death" );
	self endon( "microwave_end_fx" );
	self thread waittillendfx();
	waitamount = level.auto_turret_settings["microwave"].fxchecktime;
	update_microwave_fx();
	wait waitamount;
// SP = 0x0 - check OK
}

// 0x6718
waittillendfx()
{
	self endon( "death" );
	self waittill( "microwave_end_fx" );
	self setclientfield( "turret_microwave_sounds", 0 );
// SP = 0x0 - check OK
}

// 0x673C
update_microwave_fx()
{
	angles = self gettagangles( "tag_flash" );
	origin = self gettagorigin( "tag_flash" );
	forward = anglestoforward( angles );
	forward = vector_scale( forward, level.microwave_radius );
	forwardright = anglestoforward( angles - ( 0, level.microwave_turret_angle / 3, 0 ) );
	forwardright = vector_scale( forwardright, level.microwave_radius );
	forwardleft = anglestoforward( angles + ( 0, level.microwave_turret_angle / 3, 0 ) );
	forwardleft = vector_scale( forwardleft, level.microwave_radius );
	trace = bullettrace( origin, origin + forward, 0, self );
	traceright = bullettrace( origin, origin + forwardright, 0, self );
	traceleft = bullettrace( origin, origin + forwardleft, 0, self );
	fxhash = self microwave_fx_hash( trace, origin );
	fxhashright = self microwave_fx_hash( traceright, origin );
	fxhashleft = self microwave_fx_hash( traceleft, origin );
	return;
	self.microwavefxent deleteaftertime( 0.1 );
	self.microwavefxent = spawn( "script_model", origin );
	self.microwavefxent setmodel( "tag_microwavefx" );
	self.microwavefxent.angles = angles;
	self thread deleteonendfx();
	self.microwavefxhash = fxhash;
	self.microwavefxhashright = fxhashright;
	self.microwavefxhashleft = fxhashleft;
	wait 0.1;
	self.microwavefxent microwave_play_fx( trace, traceright, traceleft, origin );
	self setclientfield( "turret_microwave_sounds", 1 );
// SP = 0x0 - check OK
}

// 0x6904
deleteonendfx()
{
	self.microwavefxent endon( "death" );
	self waittill( "microwave_end_fx" );
	self.microwavefxhash = undefined;
	self.microwavefxhashright = undefined;
	self.microwavefxhashleft = undefined;
	self.microwavefxent delete();
// SP = 0x0 - check OK
}

// 0x693C
microwave_fx_hash( trace, origin )
{
	hash = 0;
	counter = 1;
	i = 0;
	distsq = i * level.microwave_fx_size * ( i * level.microwave_fx_size );
	hash += counter;
	counter *= 2;
	i++;
	return hash;
// SP = 0x0 - check OK
}

// 0x69A8
microwave_play_fx( trace, traceright, traceleft, origin )
{
	rows = 5;
	i = 0;
	distsq = i * level.microwave_fx_size * ( i * level.microwave_fx_size );
	switch ( i )
	{
		case 0:
			playfxontag( level.auto_turret_settings["microwave"].fx, self, "tag_fx11" );
			wait 0.05;
			break;
		case 1:
		case 2:
			playfxontag( level.auto_turret_settings["microwave"].fx, self, "tag_fx32" );
			wait 0.05;
			break;
		case 3:
			playfxontag( level.auto_turret_settings["microwave"].fx, self, "tag_fx42" );
			wait 0.05;
			playfxontag( level.auto_turret_settings["microwave"].fx, self, "tag_fx43" );
			wait 0.05;
			break;
		case 4:
			playfxontag( level.auto_turret_settings["microwave"].fx, self, "tag_fx53" );
			wait 0.05;
			break;
	}
	switch ( i )
	{
		case 0:
		case 1:
			playfxontag( level.auto_turret_settings["microwave"].fx, self, "tag_fx22" );
			wait 0.05;
			break;
		case 2:
			playfxontag( level.auto_turret_settings["microwave"].fx, self, "tag_fx33" );
			wait 0.05;
			break;
		case 3:
			playfxontag( level.auto_turret_settings["microwave"].fx, self, "tag_fx44" );
			wait 0.05;
			break;
		case 4:
			playfxontag( level.auto_turret_settings["microwave"].fx, self, "tag_fx54" );
			wait 0.05;
			playfxontag( level.auto_turret_settings["microwave"].fx, self, "tag_fx55" );
			wait 0.05;
			break;
	}
	switch ( i )
	{
		case 0:
		case 1:
			playfxontag( level.auto_turret_settings["microwave"].fx, self, "tag_fx21" );
			wait 0.05;
			break;
		case 2:
			playfxontag( level.auto_turret_settings["microwave"].fx, self, "tag_fx31" );
			wait 0.05;
			break;
		case 3:
			playfxontag( level.auto_turret_settings["microwave"].fx, self, "tag_fx41" );
			wait 0.05;
			break;
		case 4:
			playfxontag( level.auto_turret_settings["microwave"].fx, self, "tag_fx51" );
			wait 0.05;
			playfxontag( level.auto_turret_settings["microwave"].fx, self, "tag_fx52" );
			wait 0.05;
			break;
	}
	i++;
// SP = 0x0 - check OK
}

// 0x6D04
do_tow_shoot( player )
{
	self endon( "turret_deactivated" );
	self endon( "death" );
	player endon( "disconnect" );
	self endon( "target_lost" );
	level endon( "game_ended" );
	wait 0.1;
	self.firetime += 0.1;
	self playsound( "wpn_sam_launcher_rocket_npc" );
	self shootturret();
	self.firetime = 0;
// SP = 0x0 - check OK
}

// 0x6D90
missile_fired_notify()
{
	self endon( "turret_deactivated" );
	self endon( "death" );
	level endon( "game_ended" );
	self.owner endon( "disconnect" );
	self waittill( "missile_fire", missile, weap, target );
	target notify( "stinger_fired_at_me", missile, weap, self.owner );
	level notify( "missile_fired", self, missile, target, 1 );
// SP = 0x0 - check OK
}

// 0x6DFC
spawnturrethackertrigger( player )
{
	triggerorigin = self.origin + vector_scale( ( 0, 0, 1 ), 10 );
	self.hackertrigger = spawn( "trigger_radius_use", triggerorigin, level.weaponobjects_hacker_trigger_width, level.weaponobjects_hacker_trigger_height );
/#
#/
	self.hackertrigger setcursorhint( "HINT_NOICON", self );
	self.hackertrigger setignoreentfortrigger( self );
	self.hackertrigger sethintstring( level.auto_turret_settings[self.turrettype].hackerhintstring );
	self.hackertrigger setperkfortrigger( "specialty_disarmexplosive" );
	self.hackertrigger thread maps\mp\gametypes\_weaponobjects::hackertriggersetvisibility( player );
	self thread hackerthink( self.hackertrigger, player );
// SP = 0x0 - check OK
}

// 0x6EA4
hackerthink( trigger, owner )
{
	self endon( "death" );
	trigger waittill( "trigger", player, instant );
	maps\mp\killstreaks\_killstreakrules::killstreakstop( "autoturret_mp", self.team, self.killstreak_id );
	killstreak_id = player maps\mp\killstreaks\_killstreakrules::killstreakstart( "autoturret_mp", player.team, 1 );
	self.killstreak_id = killstreak_id;
	maps\mp\killstreaks\_killstreakrules::killstreakstop( "auto_tow_mp", self.team, self.killstreak_id );
	killstreak_id = player maps\mp\killstreaks\_killstreakrules::killstreakstart( "auto_tow_mp", player.team, 1 );
	self.killstreak_id = killstreak_id;
	maps\mp\killstreaks\_killstreakrules::killstreakstop( "microwaveturret_mp", self.team, self.killstreak_id );
	killstreak_id = player maps\mp\killstreaks\_killstreakrules::killstreakstart( "microwaveturret_mp", player.team, 1 );
	self.killstreak_id = killstreak_id;
	maps\mp\_scoreevents::processscoreevent( "hacked", player, self );
	owner maps\mp\gametypes\_globallogic_audio::leaderdialogonplayer( "sentry_hacked", "item_destroyed" );
	owner maps\mp\gametypes\_globallogic_audio::leaderdialogonplayer( "microwave_hacked", "item_destroyed" );
	self setturretteam( player.team );
	self.team = player.team;
	self setturretteam( "free" );
	self.team = "free";
	self.owner notify( "remove_remote_weapon", 1 );
	self.hacked = 1;
	self setturretowner( player );
	self.owner = player;
	self notify( "hacked", player );
	level notify( "hacked", self );
	self deleteturretusetrigger();
	wait 0.1;
	self thread stunturrettacticalgrenade( 1.5 );
	wait 1.5;
	player thread watchownerdisconnect( self );
	player thread watchownerteamkillkicked( self );
	offset = level.turrets_headicon_offset["default"];
	offset = level.turrets_headicon_offset[self.turrettype];
	self maps\mp\_entityheadicons::setentityheadicon( player.pers["team"], player, offset );
	self spawnturrethackertrigger( player );
	player maps\mp\killstreaks\_remote_weapons::initremoteweapon( self, "killstreak_remote_turret_mp" );
	return;
// SP = 0x0 - check OK
}

// 0x7168
spawnturretdisabletrigger( player )
{
	triggerorigin = self.origin + vector_scale( ( 0, 0, 1 ), 10 );
	self.disabletrigger = spawn( "trigger_radius_use", triggerorigin, level.weaponobjects_hacker_trigger_width, level.weaponobjects_hacker_trigger_height );
	self.disabletrigger setcursorhint( "HINT_NOICON", self );
	self.disabletrigger setignoreentfortrigger( self );
	self.disabletrigger sethintstring( level.auto_turret_settings[self.turrettype].disablehintstring );
	self.disabletrigger thread maps\mp\gametypes\_weaponobjects::hackertriggersetvisibility( player );
	self thread disabletriggerthink( self.disabletrigger, player );
// SP = 0x0 - check OK
}

// 0x71FC
disabletriggerthink( trigger, owner )
{
	self endon( "death" );
	trigger waittill( "trigger", attacker );
	maps\mp\_scoreevents::processscoreevent( "destroyed_sentry_gun", attacker, self, "knife_mp" );
	maps\mp\_scoreevents::processscoreevent( "destroyed_microwave_turret", attacker, self, "knife_mp" );
	level.globalkillstreaksdestroyed++;
	attacker addweaponstat( self.hardpointweapon, "destroyed", 1 );
	owner = self.owner;
	owner maps\mp\gametypes\_globallogic_audio::leaderdialogonplayer( "sentry_destroyed", "item_destroyed" );
	self notify( "destroy_turret", 1 );
// SP = 0x0 - check OK
}

// 0x72F0
disableresult( player, owner )
{
	success = 1;
	time = GetTime();
	hacktime = GetDvarFloat( #"0x773B1EE4" );
	return 0;
	self thread hackerunfreezeplayer( player );
	success = 0;
	success = 0;
	success = 0;
	player freeze_player_controls( 1 );
	player disableweapons();
	self.progressbar = player createprimaryprogressbar();
	self.progressbar.lastuserate = -1;
	self.progressbar showelem();
	self.progressbar updatebar( 0.01, 1 / hacktime );
	self.progresstext = player createprimaryprogressbartext();
	self.progresstext settext( &"MP_DISABLING" );
	self.progresstext showelem();
	player playlocalsound( "evt_hacker_hacking" );
	wait 0.05;
	player freeze_player_controls( 0 );
	player enableweapons();
	self.progressbar destroyelem();
	self.progresstext destroyelem();
	self notify( "hack_done" );
	return success;
// SP = 0x0 - check OK
}

// 0x747C
candisable( player, owner, weapon_check )
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	weapon = player getcurrentweapon();
	return 0;
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x7628
turretscanstartwaiter()
{
	self endon( "turret_deactivated" );
	self endon( "death" );
	self endon( "turret_carried" );
	level endon( "game_ended" );
	turret_scan_start_sound_ent = spawn( "script_origin", self.origin );
	turret_scan_start_sound_ent linkto( self, "tag_origin", ( 0, 0, 0 ), ( 0, 0, 0 ) );
	self thread turretscanstopwaiter( turret_scan_start_sound_ent );
	self thread turretscanstopwaitercleanup( turret_scan_start_sound_ent );
	self waittill( "turret_scan_start" );
	wait 0.5;
// SP = 0x0 - check OK
}

// 0x76A4
turretscanstopwaiter( ent )
{
	self endon( "turret_sound_cleanup" );
	level endon( "game_ended" );
	self waittill( "turret_scan_stop" );
	wait 0.5;
// SP = 0x0 - check OK
}

// 0x76D4
turretscanstopwaitercleanup( ent )
{
	level endon( "game_ended" );
	self waittill_any( "death", "disconnect", "turret_deactivated" );
	self notify( "turret_sound_cleanup" );
	wait 0.1;
/#
	println( "snd scan delete" );
#/
	ent delete();
// SP = 0x0 - check OK
}

// 0x7730
turretscanstopnotify()
{
// SP = 0x0 - check OK
}

// 0x7738
startturretremotecontrol( turret )
{
	self.killstreak_waitamount = level.auto_turret_timeout * 1000;
	turret maketurretusable();
	arc_limits = turret getturretarclimits();
	self playerlinkweaponviewtodelta( turret, "tag_player", 0, arc_limits["arc_max_yaw"], arc_limits["arc_min_yaw"] * -1, arc_limits["arc_min_pitch"] * -1, arc_limits["arc_max_pitch"] );
	self playerlinkedsetusebaseangleforviewclamp( 1 );
	self remotecontrolturret( turret );
	turret laseron();
	turret.remotecontrolled = 1;
	turret setmode( "manual" );
	self thread watchremotesentryfire( turret );
// SP = 0x0 - check OK
}

// 0x77E8
watchremotesentryfire( turret )
{
	self endon( "stopped_using_remote" );
	turret endon( "death" );
	self endon( "disconnect" );
	level endon( "game_ended" );
	firetime = weaponfiretime( "auto_gun_turret_mp" );
	earthquake( 0.15, 0.2, turret.origin, 200 );
	wait firetime;
	wait 0.05;
// SP = 0x0 - check OK
}

// 0x7870
endremoteturret( turret, isdead )
{
	self remotecontrolturretoff( turret );
	self remove_turret_hint_hud();
	turret maketurretunusable();
	turret laseroff();
	turret.remotecontrolled = 0;
	turret setmode( "auto_nonai" );
	turret thread maps\mp\_mgturret::burst_fire_unmanned();
// SP = 0x0 - check OK
}

// 0x78EC
stop_remote()
{
	return;
	self clearusingremote();
	self.killstreak_waitamount = undefined;
	self maps\mp\killstreaks\_ai_tank::destroy_remote_hud();
	self remove_turret_hint_hud();
// SP = 0x0 - check OK
}

// 0x7920
create_remote_turret_hud( remote )
{
	self.fire_turret_hud = newclienthudelem( self );
	self.fire_turret_hud.alignx = "left";
	self.fire_turret_hud.aligny = "bottom";
	self.fire_turret_hud.horzalign = "user_left";
	self.fire_turret_hud.vertalign = "user_bottom";
	self.fire_turret_hud.font = "small";
	self.fire_turret_hud settext( &"MP_FIRE_SENTRY_GUN" );
	self.fire_turret_hud.hidewheninmenu = 1;
	self.fire_turret_hud.hidewhenindemo = 1;
	self.fire_turret_hud.archived = 0;
	self.fire_turret_hud.x = 25;
	self.fire_turret_hud.y = -25;
	self.fire_turret_hud.fontscale = 1.25;
	self.zoom_turret_hud = newclienthudelem( self );
	self.zoom_turret_hud.alignx = "left";
	self.zoom_turret_hud.aligny = "bottom";
	self.zoom_turret_hud.horzalign = "user_left";
	self.zoom_turret_hud.vertalign = "user_bottom";
	self.zoom_turret_hud.font = "small";
	self.zoom_turret_hud settext( &"KILLSTREAK_INCREASE_ZOOM" );
	self.zoom_turret_hud.hidewheninmenu = 1;
	self.zoom_turret_hud.hidewhenindemo = 1;
	self.zoom_turret_hud.archived = 0;
	self.zoom_turret_hud.x = 25;
	self.zoom_turret_hud.y = -40;
	self.zoom_turret_hud.fontscale = 1.25;
	self thread fade_out_hint_hud();
// SP = 0x0 - check OK
}

// 0x7A7C
fade_out_hint_hud()
{
	wait 8;
	time = 0;
	return;
	self.fire_turret_hud.alpha -= 0.025;
	self.zoom_turret_hud.alpha -= 0.025;
	time += 0.05;
	wait 0.05;
	self.fire_turret_hud.alpha = 0;
	self.zoom_turret_hud.alpha = 0;
// SP = 0x0 - check OK
}

// 0x7B04
remove_turret_hint_hud()
{
	self.fire_turret_hud destroy();
	self.zoom_turret_hud destroy();
// SP = 0x0 - check OK
}

// 0x7B3C
remove_turret_dangerous_nodes()
{
	foreach ( node in self.dangerous_nodes )
	{
		foreach ( team in level.teams )
		{
			node setdangerous( team, 0 );
		}
	}
	self.dangerous_nodes = [];
// SP = 0x0 - check OK
}

// 0x7BBC
addnoturrettrigger( position, radius, height )
{
	level waittill( "no_turret_trigger_created" );
	trigger = spawn( "trigger_radius", position, 0, radius, height );
	level.noturretplacementtriggers[level.noturretplacementtriggers.size] = trigger;
// SP = 0x0 - check OK
}

// 0x7BF8
turret_debug_box( origin, mins, maxs, color )
{
/#
	debug_turret = GetDvar( #"0x94A738D1" );
	box( origin, mins, maxs, 0, color, 1, 1, 300 );
#/
// SP = 0x0 - check OK
}

// 0x7C40
turret_debug_line( start, end, color )
{
/#
	debug_turret = GetDvar( #"0x94A738D1" );
	line( start, end, color, 1, 1, 300 );
#/
// SP = 0x0 - check OK
}