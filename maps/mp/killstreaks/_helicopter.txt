// maps/mp/killstreaks/_helicopter.gsc

#include maps\mp\gametypes\_hostmigration;
#include maps\mp\_scoreevents;
#include maps\mp\_challenges;
#include maps\mp\gametypes\_damagefeedback;
#include maps\mp\gametypes\_globallogic_player;
#include maps\mp\gametypes\_weaponobjects;
#include maps\mp\killstreaks\_dogs;
#include maps\mp\gametypes\_spawning;
#include maps\mp\_heatseekingmissile;
#include maps\mp\gametypes\_tweakables;
#include maps\mp\killstreaks\_killstreaks;
#include maps\mp\killstreaks\_killstreakrules;
#include maps\mp\_treadfx;
#include maps\mp\killstreaks\_airsupport;
#include common_scripts\utility;
#include maps\mp\gametypes\_hud_util;
#include maps\mp\_utility;

#using_animtree ( "mp_vehicles" );


// 0x32C4
precachehelicopter( model, type )
{
	type = "blackhawk";
	precachemodel( model );
	level.vehicle_deathmodel[model] = model;
	precacheitem( "cobra_20mm_mp" );
	precacheitem( "cobra_20mm_comlink_mp" );
	precachestring( &"MP_DESTROYED_HELICOPTER" );
	precachestring( &"KILLSTREAK_DESTROYED_HELICOPTER_GUNNER" );
	level.cobra_missile_models = [];
	level.cobra_missile_models["cobra_Hellfire"] = "projectile_hellfire_missile";
	precachemodel( level.cobra_missile_models["cobra_Hellfire"] );
	level.heli_sound["hit"] = "evt_helicopter_hit";
	level.heli_sound["hitsecondary"] = "evt_helicopter_hit";
	level.heli_sound["damaged"] = "null";
	level.heli_sound["spinloop"] = "evt_helicopter_spin_loop";
	level.heli_sound["spinstart"] = "evt_helicopter_spin_start";
	level.heli_sound["crash"] = "evt_helicopter_midair_exp";
	level.heli_sound["missilefire"] = "wpn_hellfire_fire_npc";
	maps\mp\_treadfx::preloadtreadfx( "helicopter_player_mp" );
	maps\mp\_treadfx::preloadtreadfx( "heli_ai_mp" );
	maps\mp\_treadfx::preloadtreadfx( "heli_player_gunner_mp" );
	maps\mp\_treadfx::preloadtreadfx( "heli_guard_mp" );
	maps\mp\_treadfx::preloadtreadfx( "heli_supplydrop_mp" );
// SP = 0x0 - check OK
}

// 0x33E4
usekillstreakhelicopter( hardpointtype )
{
	return 0;
	iprintlnbold( "Need to add helicopter paths to the level" );
	return 0;
	result = self selecthelicopterlocation( hardpointtype );
	return 0;
	destination = 0;
	missilesenabled = 0;
	missilesenabled = 1;
/#
	assert( level.heli_paths.size > 0, "No non-primary helicopter paths found in map" );
#/
	random_path = randomint( level.heli_paths[destination].size );
	startnode = level.heli_paths[destination][random_path];
	protectlocation = undefined;
	armored = 0;
	protectlocation = ( level.helilocation[0], level.helilocation[1], int( maps\mp\killstreaks\_airsupport::getminimumflyheight() ) );
	armored = 0;
	startnode = getvalidprotectlocationstart( random_path, protectlocation, destination );
	killstreak_id = self maps\mp\killstreaks\_killstreakrules::killstreakstart( hardpointtype, self.team );
	return 0;
	self thread announcehelicopterinbound( hardpointtype );
	thread heli_think( self, startnode, self.team, missilesenabled, protectlocation, hardpointtype, armored, killstreak_id );
	return 1;
// SP = 0x0 - check OK
}

// 0x3540
announcehelicopterinbound( hardpointtype )
{
	team = self.team;
	self maps\mp\killstreaks\_killstreaks::playkillstreakstartdialog( hardpointtype, team, 1 );
	level.globalkillstreakscalled++;
	self addweaponstat( hardpointtype, "used", 1 );
// SP = 0x0 - check OK
}

// 0x357C
heli_path_graph()
{
	path_start = getentarray( "heli_start", "targetname" );
	path_dest = getentarray( "heli_dest", "targetname" );
	loop_start = getentarray( "heli_loop_start", "targetname" );
	gunner_loop_start = getentarray( "heli_gunner_loop_start", "targetname" );
	leave_nodes = getentarray( "heli_leave", "targetname" );
	crash_start = getentarray( "heli_crash_start", "targetname" );
/#
	assert( IsDefined( path_dest ), "Missing path_start or path_dest" );
#/
	i = 0;
	startnode_array = [];
	isprimarydest = 0;
	destnode_pointer = path_dest[i];
	destnode = getent( destnode_pointer.target, "targetname" );
	j = 0;
	todest = 0;
	currentnode = path_start[j];
	nextnode = getent( currentnode.target, "targetname" );
	todest = 1;
	debug_print3d_simple( "+", currentnode, vector_scale( ( 0, 0, -1 ), 10 ) );
	debug_line( nextnode.origin, getent( nextnode.target, "targetname" ).origin, ( 0.25, 0.5, 0.25 ), 5 );
	debug_print3d_simple( "Wait: " + currentnode.script_delay, currentnode, vector_scale( ( 0, 0, 1 ), 10 ) );
	currentnode = nextnode;
	startnode_array[startnode_array.size] = getent( path_start[j].target, "targetname" );
	isprimarydest = 1;
	j++;
/#
	assert( startnode_array.size > 0, "No path(s) to destination" );
#/
	level.heli_primary_path = startnode_array;
	level.heli_paths[level.heli_paths.size] = startnode_array;
	i++;
	i = 0;
	startnode = getent( loop_start[i].target, "targetname" );
	level.heli_loop_paths[level.heli_loop_paths.size] = startnode;
	i++;
/#
	assert( IsDefined( level.heli_loop_paths[0] ), "No helicopter loop paths found in map" );
#/
	i = 0;
	startnode = getent( gunner_loop_start[i].target, "targetname" );
	startnode.isgunnerpath = 1;
	level.heli_loop_paths[level.heli_loop_paths.size] = startnode;
	i++;
	i = 0;
	level.heli_leavenodes[level.heli_leavenodes.size] = leave_nodes[i];
	i++;
/#
	assert( IsDefined( level.heli_leavenodes[0] ), "No helicopter leave nodes found in map" );
#/
	i = 0;
	crash_start_node = getent( crash_start[i].target, "targetname" );
	level.heli_crash_paths[level.heli_crash_paths.size] = crash_start_node;
	i++;
/#
	assert( IsDefined( level.heli_crash_paths[0] ), "No helicopter crash paths found in map" );
#/
// SP = 0x0 - check OK
}

// 0x3908
init()
{
	path_start = getentarray( "heli_start", "targetname" );
	loop_start = getentarray( "heli_loop_start", "targetname" );
	thread heli_update_global_dvars();
	level.chaff_offset["attack"] = ( -130, 0, -140 );
	level.choppercomlinkfriendly = "veh_t6_air_attack_heli_mp_light";
	level.choppercomlinkenemy = "veh_t6_air_attack_heli_mp_dark";
	level.chopperregular = "veh_t6_air_attack_heli_mp_dark";
	precachehelicopter( level.chopperregular );
	precachehelicopter( level.choppercomlinkfriendly );
	precachehelicopter( level.choppercomlinkenemy );
	precachevehicle( "heli_ai_mp" );
	registerclientfield( "helicopter", "heli_comlink_bootup_anim", 1, 1, "int" );
	level.heli_paths = [];
	level.heli_loop_paths = [];
	level.heli_leavenodes = [];
	level.heli_crash_paths = [];
	level.chopper_fx["explode"]["death"] = loadfx( "vehicle/vexplosion/fx_vexplode_helicopter_exp_mp" );
	level.chopper_fx["explode"]["guard"] = loadfx( "vehicle/vexplosion/fx_vexplode_heli_sm_exp_mp" );
	level.chopper_fx["explode"]["gunner"] = loadfx( "vehicle/vexplosion/fx_vexplode_vtol_mp" );
	level.chopper_fx["explode"]["large"] = loadfx( "vehicle/vexplosion/fx_vexplode_heli_killstreak_exp_sm" );
	level.chopper_fx["damage"]["light_smoke"] = loadfx( "trail/fx_trail_heli_killstreak_engine_smoke_33" );
	level.chopper_fx["damage"]["heavy_smoke"] = loadfx( "trail/fx_trail_heli_killstreak_engine_smoke_66" );
	level.chopper_fx["smoke"]["trail"] = loadfx( "trail/fx_trail_heli_killstreak_tail_smoke" );
	level.chopper_fx["fire"]["trail"]["large"] = loadfx( "trail/fx_trail_heli_killstreak_engine_smoke" );
	level._effect["heli_comlink_light"]["friendly"] = loadfx( "light/fx_vlight_mp_attack_heli_grn" );
	level._effect["heli_comlink_light"]["enemy"] = loadfx( "light/fx_vlight_mp_attack_heli_red" );
	level.helicomlinkbootupanim = %veh_anim_future_heli_gearup_bay_open;
	return;
	heli_path_graph();
	precachelocationselector( "compass_objpoint_helicopter" );
	maps\mp\killstreaks\_killstreaks::registerkillstreak( "helicopter_comlink_mp", "helicopter_comlink_mp", "killstreak_helicopter_comlink", "helicopter_used", ::usekillstreakhelicopter, 1 );
	maps\mp\killstreaks\_killstreaks::registerkillstreakstrings( "helicopter_comlink_mp", &"KILLSTREAK_EARNED_HELICOPTER_COMLINK", &"KILLSTREAK_HELICOPTER_COMLINK_NOT_AVAILABLE", &"KILLSTREAK_HELICOPTER_COMLINK_INBOUND" );
	maps\mp\killstreaks\_killstreaks::registerkillstreakdialog( "helicopter_comlink_mp", "mpl_killstreak_heli", "kls_cobra_used", "", "kls_cobra_enemy", "", "kls_cobra_ready" );
	maps\mp\killstreaks\_killstreaks::registerkillstreakdevdvar( "helicopter_comlink_mp", "scr_givehelicopter_comlink" );
	maps\mp\killstreaks\_killstreaks::registerkillstreakaltweapon( "helicopter_comlink_mp", "cobra_20mm_comlink_mp" );
	maps\mp\killstreaks\_killstreaks::setkillstreakteamkillpenaltyscale( "helicopter_comlink_mp", 0 );
// SP = 0x0 - check OK
}

// 0x3BB8
heli_update_global_dvars()
{
	level.heli_loopmax = heli_get_dvar_int( "scr_heli_loopmax", "2" );
	level.heli_missile_rof = heli_get_dvar_int( "scr_heli_missile_rof", "2" );
	level.heli_armor = heli_get_dvar_int( "scr_heli_armor", "500" );
	level.heli_maxhealth = heli_get_dvar_int( "scr_heli_maxhealth", "1000" );
	level.heli_amored_maxhealth = heli_get_dvar_int( "scr_heli_armored_maxhealth", "1500" );
	level.heli_missile_max = heli_get_dvar_int( "scr_heli_missile_max", "20" );
	level.heli_dest_wait = heli_get_dvar_int( "scr_heli_dest_wait", "8" );
	level.heli_debug = heli_get_dvar_int( "scr_heli_debug", "0" );
	level.heli_debug_crash = heli_get_dvar_int( "scr_heli_debug_crash", "0" );
	level.heli_targeting_delay = heli_get_dvar( "scr_heli_targeting_delay", "0.6" );
	level.heli_turretreloadtime = heli_get_dvar( "scr_heli_turretReloadTime", "1.5" );
	level.heli_turretclipsize = heli_get_dvar_int( "scr_heli_turretClipSize", "20" );
	level.heli_visual_range = heli_get_dvar_int( "scr_heli_visual_range", "3500" );
	level.heli_missile_range = heli_get_dvar_int( "scr_heli_missile_range", "100000" );
	level.heli_health_degrade = heli_get_dvar_int( "scr_heli_health_degrade", "0" );
	level.heli_turret_angle_tan = heli_get_dvar_int( "scr_heli_turret_angle_tan", "1" );
	level.heli_turret_target_cone = heli_get_dvar( "scr_heli_turret_target_cone", "0.6" );
	level.heli_target_spawnprotection = heli_get_dvar_int( "scr_heli_target_spawnprotection", "5" );
	level.heli_missile_regen_time = heli_get_dvar( "scr_heli_missile_regen_time", "10" );
	level.heli_turret_spinup_delay = heli_get_dvar( "scr_heli_turret_spinup_delay", "0.7" );
	level.heli_target_recognition = heli_get_dvar( "scr_heli_target_recognition", "0.5" );
	level.heli_missile_friendlycare = heli_get_dvar_int( "scr_heli_missile_friendlycare", "512" );
	level.heli_missile_target_cone = heli_get_dvar( "scr_heli_missile_target_cone", "0.6" );
	level.heli_valid_target_cone = heli_get_dvar( "scr_heli_missile_valid_target_cone", "0.7" );
	level.heli_armor_bulletdamage = heli_get_dvar( "scr_heli_armor_bulletdamage", "0.5" );
	level.heli_attract_strength = heli_get_dvar( "scr_heli_attract_strength", "1000" );
	level.heli_attract_range = heli_get_dvar( "scr_heli_attract_range", "20000" );
	level.helicopterturretmaxangle = heli_get_dvar_int( "scr_helicopterTurretMaxAngle", "35" );
	level.heli_protect_time = heli_get_dvar( "scr_heli_protect_time", "60" );
	level.heli_protect_pos_time = heli_get_dvar( "scr_heli_protect_pos_time", "12" );
	level.heli_protect_radius = heli_get_dvar_int( "scr_heli_protect_radius", "2000" );
	level.heli_missile_reload_time = heli_get_dvar( "scr_heli_missile_reload_time", "5.0" );
	level.heli_warning_distance = heli_get_dvar_int( "scr_heli_warning_distance", "500" );
	wait 1;
// SP = 0x0 - check OK
}

// 0x3E5C
heli_get_dvar_int( dvar, def )
{
	return int( heli_get_dvar( dvar, def ) );
// SP = 0x0 - check OK
}

// 0x3E80
heli_get_dvar( dvar, def )
{
	return GetDvarFloat( dvar );
	setdvar( dvar, def );
	return def;
// SP = 0x0 - check OK
}

// 0x3EB0
spawn_helicopter( owner, origin, angles, model, targetname, target_offset, hardpointtype, killstreak_id )
{
	chopper = spawnhelicopter( owner, origin, angles, model, targetname );
	chopper.attackers = [];
	chopper.attackerdata = [];
	chopper.attackerdamage = [];
	chopper.flareattackerdamage = [];
	chopper.destroyfunc = ::destroyhelicopter;
	chopper.hardpointtype = hardpointtype;
	chopper.killstreak_id = killstreak_id;
	chopper.pilotistalking = 0;
	chopper setdrawinfrared( 1 );
	target_offset = ( 0, 0, 0 );
	target_set( chopper, target_offset );
	chopper.pilotvoicenumber = self.bcvoicenumber - 1;
	chopper.pilotvoicenumber = 3;
	owner.pilottalking = 0;
	chopper thread playpilotdialog( "a10_used", 2.5 );
	chopper thread playpilotdialog( "attackheli_approach", 2.5 );
	chopper.soundmod = "heli";
	return chopper;
// SP = 0x0 - check OK
}

// 0x3FC0
explodeoncontact( hardpointtype )
{
	self endon( "death" );
	wait 10;
	self waittill( "touch" );
	self thread heli_explode();
// SP = 0x0 - check OK
}

// 0x3FE8
getvalidprotectlocationstart( random_path, protectlocation, destination )
{
	startnode = level.heli_paths[destination][random_path];
	path_index = ( random_path + 1 ) % level.heli_paths[destination].size;
	innofly = crossesnoflyzone( protectlocation + ( 0, 0, 1 ), protectlocation );
	protectlocation = ( protectlocation[0], protectlocation[1], level.noflyzones[innofly].origin[2] + level.noflyzones[innofly].height );
	noflyzone = crossesnoflyzone( startnode.origin, protectlocation );
	startnode = level.heli_paths[destination][path_index];
	noflyzone = crossesnoflyzone( startnode.origin, protectlocation );
	path_index = ( path_index + 1 ) % level.heli_paths[destination].size;
	return level.heli_paths[destination][path_index];
// SP = 0x0 - check OK
}

// 0x40C8
getvalidrandomleavenode( start )
{
	random_leave_node = randomint( level.heli_leavenodes.size );
	leavenode = level.heli_leavenodes[random_leave_node];
	path_index = ( random_leave_node + 1 ) % level.heli_leavenodes.size;
	noflyzone = crossesnoflyzone( leavenode.origin, start );
	leavenode = level.heli_leavenodes[path_index];
	noflyzone = crossesnoflyzone( leavenode.origin, start );
	path_index = ( path_index + 1 ) % level.heli_leavenodes.size;
	return level.heli_leavenodes[path_index];
// SP = 0x0 - check OK
}

// 0x415C
getvalidrandomcrashnode( start )
{
	random_leave_node = randomint( level.heli_crash_paths.size );
	leavenode = level.heli_crash_paths[random_leave_node];
	path_index = ( random_leave_node + 1 ) % level.heli_crash_paths.size;
	noflyzone = crossesnoflyzone( leavenode.origin, start );
	leavenode = level.heli_crash_paths[path_index];
	noflyzone = crossesnoflyzone( leavenode.origin, start );
	path_index = ( path_index + 1 ) % level.heli_crash_paths.size;
	return level.heli_crash_paths[path_index];
// SP = 0x0 - check OK
}

// 0x41F0
heli_think( owner, startnode, heli_team, missilesenabled, protectlocation, hardpointtype, armored, killstreak_id )
{
	heliorigin = startnode.origin;
	heliangles = startnode.angles;
	choppermodelfriendly = level.choppercomlinkfriendly;
	choppermodelenemy = level.choppercomlinkenemy;
	choppermodelfriendly = level.chopperregular;
	choppermodelenemy = level.chopperregular;
	chopper = spawn_helicopter( owner, heliorigin, heliangles, "heli_ai_mp", choppermodelfriendly, vector_scale( ( 0, 0, -1 ), 100 ), hardpointtype, killstreak_id );
	chopper setenemymodel( choppermodelenemy );
	chopper thread watchforearlyleave( hardpointtype );
	target_setturretaquire( chopper, 0 );
	chopper thread samturretwatcher();
	chopper.defaultweapon = "cobra_20mm_comlink_mp";
	chopper.defaultweapon = "cobra_20mm_mp";
	chopper.requireddeathcount = owner.deathcount;
	chopper.chaff_offset = level.chaff_offset["attack"];
	minigun_snd_ent = spawn( "script_origin", chopper gettagorigin( "tag_flash" ) );
	minigun_snd_ent linkto( chopper, "tag_flash", ( 0, 0, 0 ), ( 0, 0, 0 ) );
	chopper.minigun_snd_ent = minigun_snd_ent;
	minigun_snd_ent thread autostopsound();
	chopper.team = heli_team;
	chopper setteam( heli_team );
	chopper.owner = owner;
	chopper setowner( owner );
	chopper thread heli_existance();
	level.chopper = chopper;
	chopper.reached_dest = 0;
	chopper.maxhealth = level.heli_amored_maxhealth;
	chopper.maxhealth = level.heli_maxhealth;
	chopper.rocketdamageoneshot = level.heli_maxhealth + 1;
	chopper.rocketdamagetwoshot = level.heli_maxhealth / 2 + 1;
	chopper.numflares = 1;
	chopper.numflares = 2;
	chopper.flareoffset = vector_scale( ( 0, 0, -1 ), 256 );
	chopper.waittime = level.heli_dest_wait;
	chopper.loopcount = 0;
	chopper.evasive = 0;
	chopper.health_bulletdamageble = level.heli_armor;
	chopper.health_evasive = level.heli_armor;
	chopper.health_low = chopper.maxhealth * 0.8;
	chopper.targeting_delay = level.heli_targeting_delay;
	chopper.primarytarget = undefined;
	chopper.secondarytarget = undefined;
	chopper.attacker = undefined;
	chopper.missile_ammo = level.heli_missile_max;
	chopper.currentstate = "ok";
	chopper.lastrocketfiretime = -1;
	chopper thread heli_protect( startnode, protectlocation, hardpointtype, heli_team );
	chopper setclientfield( "heli_comlink_bootup_anim", 1 );
	chopper thread heli_fly( startnode, 2, hardpointtype );
	chopper thread heli_damage_monitor( hardpointtype );
	chopper thread heli_kill_monitor( hardpointtype );
	chopper thread heli_health( hardpointtype, owner );
	chopper thread attack_targets( missilesenabled, hardpointtype );
	chopper thread heli_targeting( missilesenabled, hardpointtype );
	chopper thread heli_missile_regen();
	chopper thread maps\mp\_heatseekingmissile::missiletarget_proximitydetonateincomingmissile( "crashing", "death" );
	chopper thread create_flare_ent( vector_scale( ( 0, 0, -1 ), 100 ) );
	chopper maps\mp\gametypes\_spawning::create_helicopter_influencers( heli_team );
// SP = 0x0 - check OK
}

// 0x4548
autostopsound()
{
	self endon( "death" );
	level waittill( "game_ended" );
	self stoploopsound();
// SP = 0x0 - check OK
}

// 0x4568
heli_existance()
{
	self waittill( "leaving" );
	self maps\mp\gametypes\_spawning::remove_helicopter_influencers();
// SP = 0x0 - check OK
}

// 0x4580
create_flare_ent( offset )
{
	self.flare_ent = spawn( "script_model", self gettagorigin( "tag_origin" ) );
	self.flare_ent setmodel( "tag_origin" );
	self.flare_ent linkto( self, "tag_origin", offset );
// SP = 0x0 - check OK
}

// 0x45D0
heli_missile_regen()
{
	self endon( "death" );
	self endon( "crashing" );
	self endon( "leaving" );
	debug_print3d( "Missile Ammo: " + self.missile_ammo, ( 0.5, 0.5, 1 ), self, vector_scale( ( 0, 0, -1 ), 100 ), 0 );
	self waittill( "missile fired" );
	wait level.heli_missile_regen_time / 4;
	wait level.heli_missile_regen_time / 2;
	wait level.heli_missile_regen_time;
	self.missile_ammo++;
// SP = 0x0 - check OK
}

// 0x4678
heli_targeting( missilesenabled, hardpointtype )
{
	self endon( "death" );
	self endon( "crashing" );
	self endon( "leaving" );
	targets = [];
	targetsmissile = [];
	players = level.players;
	i = 0;
	player = players[i];
	targets[targets.size] = player;
	targetsmissile[targetsmissile.size] = player;
	i++;
	dogs = maps\mp\killstreaks\_dogs::dog_manager_get_dogs();
	foreach ( dog in dogs )
	{
		targets[targets.size] = dog;
		targetsmissile[targetsmissile.size] = dog;
	}
	tanks = getentarray( "talon", "targetname" );
	foreach ( tank in tanks )
	{
		targets[targets.size] = tank;
	}
	self.primarytarget = undefined;
	self.secondarytarget = undefined;
	debug_print_target();
	self setgoalyaw( randomint( 360 ) );
	wait self.targeting_delay;
	update_dog_threat( targets[0] );
	update_player_threat( targets[0] );
	self.primarytarget = targets[0];
	self notify( "primary acquired" );
	self.secondarytarget = undefined;
	debug_print_target();
	assignprimarytargets( targets );
	self update_missile_player_threat( targetsmissile[0] );
	self update_missile_dog_threat( targetsmissile[0] );
	self.secondarytarget = targetsmissile[0];
	self notify( "secondary acquired" );
	debug_print_target();
	assignsecondarytargets( targetsmissile );
	wait self.targeting_delay;
	debug_print_target();
// SP = 0x0 - check OK
}

// 0x4950
cantargetplayer_turret( player, hardpointtype )
{
	cantarget = 1;
	return 0;
	self check_owner( hardpointtype );
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	heli_centroid = self.origin + vector_scale( ( 0, 0, -1 ), 160 );
	heli_forward_norm = anglestoforward( self.angles );
	heli_turret_point = heli_centroid + 144 * heli_forward_norm;
	visible_amount = player sightconetrace( heli_turret_point, self );
	return 0;
	return cantarget;
// SP = 0x0 - check OK
}

// 0x4A6C
getverticaltan( startorigin, endorigin )
{
	vector = endorigin - startorigin;
	opposite = startorigin[2] - endorigin[2];
	opposite *= 1;
	adjacent = distance2d( startorigin, endorigin );
	adjacent *= 1;
	adjacent = 0.01;
	tangent = opposite / adjacent;
	return tangent;
// SP = 0x0 - check OK
}

// 0x4AE8
cantargetplayer_missile( player, hardpointtype )
{
	cantarget = 1;
	return 0;
	self check_owner( hardpointtype );
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	heli_centroid = self.origin + vector_scale( ( 0, 0, -1 ), 160 );
	heli_forward_norm = anglestoforward( self.angles );
	heli_turret_point = heli_centroid + 144 * heli_forward_norm;
	player.lasthit = 0;
	player.lasthit = self heliturretsighttrace( heli_turret_point, player, player.lasthit );
	return 0;
	return cantarget;
// SP = 0x0 - check OK
}

// 0x4C3C
cantargetdog_turret( dog )
{
	cantarget = 1;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	heli_centroid = self.origin + vector_scale( ( 0, 0, -1 ), 160 );
	heli_forward_norm = anglestoforward( self.angles );
	heli_turret_point = heli_centroid + 144 * heli_forward_norm;
	dog.lasthit = 0;
	dog.lasthit = self heliturretdogtrace( heli_turret_point, dog, dog.lasthit );
	return 0;
	return cantarget;
// SP = 0x0 - check OK
}

// 0x4D20
cantargetdog_missile( dog )
{
	cantarget = 1;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	heli_centroid = self.origin + vector_scale( ( 0, 0, -1 ), 160 );
	heli_forward_norm = anglestoforward( self.angles );
	heli_turret_point = heli_centroid + 144 * heli_forward_norm;
	dog.lasthit = 0;
	dog.lasthit = self heliturretdogtrace( heli_turret_point, dog, dog.lasthit );
	return 0;
	return cantarget;
// SP = 0x0 - check OK
}

// 0x4E04
cantargettank_turret( tank )
{
	cantarget = 1;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return cantarget;
// SP = 0x0 - check OK
}

// 0x4E7C
assignprimarytargets( targets )
{
	idx = 0;
	update_dog_threat( targets[idx] );
	update_player_threat( targets[idx] );
	idx++;
/#
	assert( targets.size >= 2, "Not enough targets to assign primary and secondary" );
#/
	highest = 0;
	second_highest = 0;
	primarytarget = undefined;
	idx = 0;
/#
	assert( IsDefined( targets[idx].threatlevel ), "Target player does not have threat level" );
#/
	highest = targets[idx].threatlevel;
	primarytarget = targets[idx];
	idx++;
/#
	assert( IsDefined( primarytarget ), "Targets exist, but none was assigned as primary" );
#/
	self.primarytarget = primarytarget;
	self notify( "primary acquired" );
// SP = 0x0 - check OK
}

// 0x4F7C
assignsecondarytargets( targets )
{
	idx = 0;
	self update_missile_player_threat( targets[idx] );
	update_missile_dog_threat( targets[idx] );
	idx++;
/#
	assert( targets.size >= 2, "Not enough targets to assign primary and secondary" );
#/
	highest = 0;
	second_highest = 0;
	primarytarget = undefined;
	secondarytarget = undefined;
	idx = 0;
/#
	assert( IsDefined( targets[idx].missilethreatlevel ), "Target player does not have threat level" );
#/
	highest = targets[idx].missilethreatlevel;
	secondarytarget = targets[idx];
	idx++;
/#
	assert( IsDefined( secondarytarget ), "1+ targets exist, but none was assigned as secondary" );
#/
	self.secondarytarget = secondarytarget;
	self notify( "secondary acquired" );
// SP = 0x0 - check OK
}

// 0x50A8
update_player_threat( player )
{
	player.threatlevel = 0;
	dist = distance( player.origin, self.origin );
	player.threatlevel = ( ( player.threatlevel + level.heli_visual_range ) - dist ) / ( level.heli_visual_range * 100 );
	player.threatlevel += 100;
	player.threatlevel += 200;
	player.threatlevel += player.score * 4;
	player.threatlevel -= player.antithreat;
	player.threatlevel = 1;
// SP = 0x0 - check OK
}

// 0x5188
update_missile_player_threat( player )
{
	player.missilethreatlevel = 0;
	dist = distance( player.origin, self.origin );
	player.missilethreatlevel = ( ( player.missilethreatlevel + level.heli_missile_range ) - dist ) / ( level.heli_missile_range * 100 );
	player.missilethreatlevel = 1;
	return;
	player.missilethreatlevel += 100;
	player.missilethreatlevel += player.score * 4;
	player.missilethreatlevel -= player.antithreat;
	player.missilethreatlevel = 1;
// SP = 0x0 - check OK
}

// 0x5260
update_dog_threat( dog )
{
	dog.threatlevel = 0;
	dist = distance( dog.origin, self.origin );
	dog.threatlevel = ( ( dog.threatlevel + level.heli_visual_range ) - dist ) / ( level.heli_visual_range * 100 );
// SP = 0x0 - check OK
}

// 0x52A8
update_missile_dog_threat( dog )
{
	dog.missilethreatlevel = 1;
// SP = 0x0 - check OK
}

// 0x52BC
heli_reset()
{
	self cleartargetyaw();
	self cleargoalyaw();
	self setspeed( 60, 25 );
	self setyawspeed( 75, 45, 45 );
	self setmaxpitchroll( 30, 30 );
	self setneargoalnotifydist( 256 );
	self setturningability( 0.9 );
// SP = 0x0 - check OK
}

// 0x532C
heli_wait( waittime )
{
	self endon( "death" );
	self endon( "crashing" );
	self endon( "evasive" );
	self thread heli_hover();
	wait waittime;
	heli_reset();
	self notify( "stop hover" );
// SP = 0x0 - check OK
}

// 0x5368
heli_hover()
{
	self endon( "death" );
	self endon( "stop hover" );
	self endon( "evasive" );
	self endon( "leaving" );
	self endon( "crashing" );
	randint = randomint( 360 );
	self setgoalyaw( self.angles[1] + randint );
// SP = 0x0 - check OK
}

// 0x53B4
heli_kill_monitor( hardpointtype )
{
	self endon( "death" );
	self endon( "crashing" );
	self endon( "leaving" );
	self.damagetaken = 0;
	self.bda = 0;
	last_kill_vo = 0;
	kill_vo_spacing = 4000;
	self waittill( "killed", victim );
/#
	println( "got killed notify" );
#/
	self.pilotistalking = 1;
	wait 1.5;
	type = "kls";
	self thread playpilotdialog( "kls_hit", 1 );
	type = "klsheli";
	self thread playpilotdialog( "klsheli_hit", 1 );
	wait 4;
	bdadialog = type + "_killn";
	bdadialog = type + "_kill1";
	bdadialog = type + "_kill2";
	bdadialog = type + "_kill3";
	bdadialog = type + "_killm";
	self thread playpilotdialog( bdadialog );
	self.bda = 0;
	last_kill_vo = GetTime();
	wait 1.5;
	self.pilotistalking = 0;
// SP = 0x0 - check OK
}

// 0x5530
heli_damage_monitor( hardpointtype )
{
	self endon( "death" );
	self endon( "crashing" );
	self.damagetaken = 0;
	last_hit_vo = 0;
	hit_vo_spacing = 6000;
	self.attackers = [];
	self.attackerdata = [];
	self.attackerdamage = [];
	self.flareattackerdamage = [];
	self waittill( "damage", damage, attacker, direction, point, type, modelname, tagname, partname, weapon );
	heli_friendlyfire = maps\mp\gametypes\_weaponobjects::friendlyfirecheck( self.owner, attacker );
	isvalidattacker = attacker.team != self.team;
	isvalidattacker = 1;
	attacker maps\mp\gametypes\_damagefeedback::updatedamagefeedback();
	damage += int( damage * level.cac_armorpiercing_data );
	damage *= level.heli_armor_bulletdamage;
	self trackassists( attacker, damage, 0 );
	self.attacker = attacker;
	switch ( weapon )
	{
		case "tow_turret_mp":
			self.damagetaken += self.rocketdamagetwoshot;
			self.damagetaken += self.rocketdamageoneshot;
			self.damagetaken += damage;
			break;
		case "xm25_mp":
			self.damagetaken += damage;
			break;
		default:
			self.damagetaken += self.rocketdamageoneshot;
			self.damagetaken += damage;
			break;
	}
	self.damagetaken += damage;
	playercontrolled = 0;
	self.xpgiven = 1;
	switch ( hardpointtype )
	{
		case "helicopter_comlink_mp":
			playercontrolled = 1;
			event = "destroyed_helicopter_gunner";
			break;
		case "helicopter_guard_mp":
			playercontrolled = 1;
			event = "destroyed_helicopter_gunner";
			break;
		case "helicopter_gunner_mp":
			event = "destroyed_helicopter_guard";
			break;
		case "helicopter_player_gunner_mp":
			event = "destroyed_helicopter_comlink";
			break;
		case "supply_drop_mp":
			event = "destroyed_helicopter_supply_drop";
			break;
	}
	maps\mp\_challenges::destroyedhelicopter( attacker, weapon, type, playercontrolled );
	maps\mp\_challenges::destroyedaircraft( attacker, weapon );
	maps\mp\_scoreevents::processscoreevent( event, attacker, self.owner, weapon );
	attacker maps\mp\_challenges::addflyswatterstat( weapon, self );
	attacker destroyedplayercontrolledaircraft();
	attacker addweaponstat( weapon, "destroyed_controlled_killstreak", 1 );
	weaponstatname = "destroyed";
	switch ( weapon )
	{
		case "auto_tow_mp":
		case "tow_turret_drop_mp":
		case "tow_turret_mp":
			weaponstatname = "kills";
			break;
	}
	attacker addweaponstat( weapon, weaponstatname, 1 );
	killstreakreference = undefined;
	switch ( hardpointtype )
	{
		case "helicopter_comlink_mp":
			killstreakreference = "killstreak_helicopter_gunner";
			break;
		case "helicopter_guard_mp":
			killstreakreference = "killstreak_helicopter_player_gunner";
			break;
		case "helicopter_gunner_mp":
			killstreakreference = "killstreak_helicopter_player_firstperson";
			break;
		case "helicopter_mp":
		case "helicopter_player_firstperson_mp":
		case "helicopter_player_gunner_mp":
			killstreakreference = "killstreak_helicopter_comlink";
			break;
		case "helicopter_x2_mp":
			killstreakreference = "killstreak_supply_drop";
			break;
		case "supply_drop_mp":
			killstreakreference = "killstreak_helicopter_guard";
	}
	level.globalkillstreaksdestroyed++;
	attacker addweaponstat( hardpointtype, "destroyed", 1 );
	notifystring = &"KILLSTREAK_DESTROYED_HELICOPTER";
	notifystring = &"KILLSTREAK_DESTROYED_HELICOPTER_GUNNER";
	self.owner sendkillstreakdamageevent( 600 );
	i = 0;
	level.players[i] luinotifyevent( &"player_callout", 2, notifystring, attacker.entnum );
	i++;
	j = 0;
	player = self.attackers[j];
	flare_done = self.flareattackerdamage[player.clientid];
	maps\mp\_scoreevents::processscoreevent( "aircraft_flare_assist", player );
	damage_done = self.attackerdamage[player.clientid];
	player thread processcopterassist( self, damage_done );
	j++;
	self.attackers = [];
	attacker notify( "destroyed_helicopter" );
	target_remove( self );
	self.owner playlocalsound( level.heli_vo[self.team]["hit"] );
	last_hit_vo = GetTime();
// SP = 0x0 - check OK
}

// 0x5B18
trackassists( attacker, damage, isflare )
{
	self.attackerdamage[attacker.clientid] = damage;
	self.attackers[self.attackers.size] = attacker;
	self.attackerdata[attacker.clientid] = 0;
	self.attackerdamage[attacker.clientid] += damage;
	self.flareattackerdamage[attacker.clientid] = 1;
	self.flareattackerdamage[attacker.clientid] = 0;
// SP = 0x0 - check OK
}

// 0x5BAC
heli_health( hardpointtype, player, playernotify )
{
	self endon( "death" );
	self endon( "crashing" );
	self.currentstate = "ok";
	self.laststate = "ok";
	self setdamagestage( 3 );
	damagestate = 3;
	self waittill( "damage", damage, attacker, direction, point, type, modelname, tagname, partname, weapon );
	wait 0.05;
	damagestate = 0;
	self setdamagestage( damagestate );
	self thread heli_crash( hardpointtype, player, playernotify );
	playfxontag( level.chopper_fx["damage"]["heavy_smoke"], self, "tag_origin" );
	playfxontag( level.chopper_fx["damage"]["heavy_smoke"], self, "tag_main_rotor" );
	damagestate = 1;
	self.currentstate = "heavy smoke";
	self.evasive = 1;
	self notify( "damage state" );
	playfxontag( level.chopper_fx["damage"]["light_smoke"], self, "tag_origin" );
	playfxontag( level.chopper_fx["damage"]["light_smoke"], self, "tag_main_rotor" );
	damagestate = 2;
	self.currentstate = "light smoke";
	self notify( "damage state" );
	debug_print3d_simple( "Armor: " + ( level.heli_armor - self.damagetaken ), self, vector_scale( ( 0, 0, 1 ), 100 ), 20 );
	debug_print3d_simple( "Health: " + ( self.maxhealth - self.damagetaken ), self, vector_scale( ( 0, 0, 1 ), 100 ), 20 );
// SP = 0x0 - check OK
}

// 0x5DA8
heli_evasive( hardpointtype )
{
	self notify( "evasive" );
	self.evasive = 1;
	loop_startnode = level.heli_loop_paths[0];
	gunnerpathfound = 1;
	gunnerpathfound = 0;
	i = 0;
	loop_startnode = level.heli_loop_paths[i];
	gunnerpathfound = 1;
	i++;
/#
	assert( gunnerpathfound, "No chopper gunner loop paths found in map" );
#/
	startwait = 2;
	startwait = 0;
	self thread heli_fly( loop_startnode, startwait, hardpointtype );
// SP = 0x0 - check OK
}

// 0x5E64
notify_player( player, playernotify, delay )
{
	return;
	return;
	player endon( "disconnect" );
	player endon( playernotify );
	wait delay;
	player notify( playernotify );
// SP = 0x0 - check OK
}

// 0x5E94
play_going_down_vo( delay )
{
	self.owner endon( "disconnect" );
	self endon( "death" );
	wait delay;
	self playpilotdialog( "attackheli_down" );
// SP = 0x0 - check OK
}

// 0x5EC0
heli_crash( hardpointtype, player, playernotify )
{
	self endon( "death" );
	self notify( "crashing" );
	self maps\mp\gametypes\_spawning::remove_helicopter_influencers();
	self stoploopsound( 0 );
	self.minigun_snd_ent stoploopsound();
	self.alarm_snd_ent stoploopsound();
	crashtypes = [];
	crashtypes[0] = "crashOnPath";
	crashtypes[1] = "spinOut";
	crashtype = crashtypes[randomint( 2 )];
	crashtype = self.crashtype;
/#
	switch ( level.heli_debug_crash )
	{
		case 1:
			crashtype = "explode";
			break;
		case 2:
			crashtype = "crashOnPath";
			break;
		case 3:
			crashtype = "spinOut";
			break;
		default:
	}
#/
	switch ( crashtype )
	{
		case "crashOnPath":
			thread notify_player( player, playernotify, 0 );
			self thread heli_explode();
			break;
		case "explode":
			self thread play_going_down_vo( 0.5 );
			thread notify_player( player, playernotify, 4 );
			self clear_client_flags();
			self thread crashonnearestcrashpath( hardpointtype );
			break;
		case "spinOut":
			self thread play_going_down_vo( 0.5 );
			thread notify_player( player, playernotify, 4 );
			self clear_client_flags();
			heli_reset();
			heli_speed = 30 + randomint( 50 );
			heli_accel = 10 + randomint( 25 );
			leavenode = getvalidrandomcrashnode( self.origin );
			self setspeed( heli_speed, heli_accel );
			self setvehgoalpos( leavenode.origin, 0 );
			rateofspin = 45 + randomint( 90 );
			thread heli_secondary_explosions();
			self thread heli_spin( rateofspin );
			self waittill_any_timeout( randomintrange( 4, 6 ), "near_goal" );
			player notify( playernotify );
			self thread heli_explode();
			break;
	}
	self thread explodeoncontact( hardpointtype );
	time = randomintrange( 4, 6 );
	self thread waitthenexplode( time );
// SP = 0x0 - check OK
}

// 0x6154
damagedrotorfx()
{
	self endon( "death" );
	self setrotorspeed( 0.6 );
// SP = 0x0 - check OK
}

// 0x6170
waitthenexplode( time )
{
	self endon( "death" );
	wait time;
	self thread heli_explode();
// SP = 0x0 - check OK
}

// 0x6190
crashonnearestcrashpath( hardpointtype )
{
	crashpathdistance = -1;
	crashpath = level.heli_crash_paths[0];
	i = 0;
	currentdistance = distance( self.origin, level.heli_crash_paths[i].origin );
	crashpathdistance = currentdistance;
	crashpath = level.heli_crash_paths[i];
	i++;
	heli_speed = 30 + randomint( 50 );
	heli_accel = 10 + randomint( 25 );
	self setspeed( heli_speed, heli_accel );
	thread heli_secondary_explosions();
	self thread heli_fly( crashpath, 0, hardpointtype );
	rateofspin = 45 + randomint( 90 );
	self thread heli_spin( rateofspin );
	self waittill( "path start" );
	self waittill( "destination reached" );
	self thread heli_explode();
// SP = 0x0 - check OK
}

// 0x6284
heli_secondary_explosions()
{
	self endon( "death" );
	playfxontag( level.chopper_fx["explode"]["large"], self, "tag_engine_left" );
	self playsound( level.heli_sound["hit"] );
	self thread trail_fx( level.chopper_fx["smoke"]["trail"], "tag_engine_right", "stop tail smoke" );
	self thread trail_fx( level.chopper_fx["smoke"]["trail"], "tail_rotor_jnt", "stop tail smoke" );
	self setdamagestage( 0 );
	self thread trail_fx( level.chopper_fx["fire"]["trail"]["large"], "tag_engine_left", "stop body fire" );
	wait 3;
	return;
	playfxontag( level.chopper_fx["explode"]["large"], self, "tag_engine_left" );
	self playsound( level.heli_sound["hitsecondary"] );
// SP = 0x0 - check OK
}

// 0x6384
heli_spin( speed )
{
	self endon( "death" );
	self thread spinsoundshortly();
	self setyawspeed( speed, speed / 3, speed / 3 );
	self settargetyaw( self.angles[1] + speed * 0.9 );
	wait 1;
// SP = 0x0 - check OK
}

// 0x63E4
spinsoundshortly()
{
	self endon( "death" );
	wait 0.25;
	self stoploopsound();
	wait 0.05;
	self playloopsound( level.heli_sound["spinloop"] );
	wait 0.05;
	self playsound( level.heli_sound["spinstart"] );
// SP = 0x0 - check OK
}

// 0x643C
trail_fx( trail_fx, trail_tag, stop_notify )
{
	playfxontag( trail_fx, self, trail_tag );
// SP = 0x0 - check OK
}

// 0x6458
destroyhelicopter()
{
	team = self.team;
	self maps\mp\gametypes\_spawning::remove_helicopter_influencers();
	self.interior_model delete();
	self.interior_model = undefined;
	self.minigun_snd_ent stoploopsound();
	self.minigun_snd_ent delete();
	self.minigun_snd_ent = undefined;
	self.alarm_snd_ent delete();
	self.alarm_snd_ent = undefined;
	self.flare_ent delete();
	self.flare_ent = undefined;
	self delete();
	maps\mp\killstreaks\_killstreakrules::killstreakstop( self.hardpointtype, team, self.killstreak_id );
// SP = 0x0 - check OK
}

// 0x6510
heli_explode()
{
	self death_notify_wrapper();
	forward = self.origin + vector_scale( ( 0, 0, 1 ), 100 ) - self.origin;
	playfx( level.chopper_fx["explode"]["guard"], self.origin, forward );
	playfx( level.chopper_fx["explode"]["gunner"], self.origin, forward );
	playfx( level.chopper_fx["explode"]["death"], self.origin, forward );
	self playsound( level.heli_sound["crash"] );
	wait 0.1;
/#
	assert( IsDefined( self.destroyfunc ) );
#/
	self [[self.destroyfunc]]();
// SP = 0x0 - check OK
}

// 0x65F8
clear_client_flags()
{
// SP = 0x0 - check OK
}

// 0x6600
heli_leave( hardpointtype )
{
	self notify( "desintation reached" );
	self notify( "leaving" );
	self thread playpilotdialog( "a10_leave", 2.5 );
	self thread playpilotdialog( "attackheli_leave", 2.5 );
	self clear_client_flags();
	leavenode = getvalidrandomleavenode( self.origin );
	heli_reset();
	self clearlookatent();
	exitangles = vectortoangles( leavenode.origin - self.origin );
	self setgoalyaw( exitangles[1] );
	wait 1.5;
	return;
	self setspeed( 180, 65 );
	self setvehgoalpos( self.origin + leavenode.origin - self.origin / 2 + vector_scale( ( 0, 0, 1 ), 1000 ) );
	self waittill( "near_goal" );
	self setvehgoalpos( leavenode.origin, 1 );
	self waittillmatch( "goal" );
	return;
	self stoploopsound( 1 );
	self death_notify_wrapper();
	self.alarm_snd_ent stoploopsound();
	self.alarm_snd_ent delete();
	self.alarm_snd_ent = undefined;
	target_remove( self );
/#
	assert( IsDefined( self.destroyfunc ) );
#/
	self [[self.destroyfunc]]();
// SP = 0x0 - check OK
}

// 0x6778
heli_fly( currentnode, startwait, hardpointtype )
{
	self endon( "death" );
	self endon( "leaving" );
	self notify( "flying" );
	self endon( "flying" );
	self endon( "abandoned" );
	self.reached_dest = 0;
	heli_reset();
	pos = self.origin;
	wait startwait;
	nextnode = getent( currentnode.target, "targetname" );
/#
	assert( IsDefined( nextnode ), "Next node in path is undefined, but has targetname" );
#/
	pos = nextnode.origin + vector_scale( ( 0, 0, 1 ), 30 );
	heli_speed = currentnode.script_airspeed;
	heli_accel = currentnode.script_accel;
	heli_speed = 30 + randomint( 20 );
	heli_accel = 10 + randomint( 5 );
	heli_speed *= self.pathspeedscale;
	heli_accel *= self.pathspeedscale;
	stop = 1;
	stop = 0;
	debug_line( currentnode.origin, nextnode.origin, ( 1, 0.5, 0.5 ), 200 );
	self setspeed( heli_speed, heli_accel );
	self setvehgoalpos( pos, stop );
	self waittill( "near_goal" );
	self notify( "path start" );
	stop = 1;
	self setspeed( heli_speed, heli_accel );
	self setvehgoalpos( pos, stop );
	self waittill( "near_goal" );
	self notify( "path start" );
	self setgoalyaw( nextnode.angles[1] );
	self waittillmatch( "goal" );
	return;
	heli_wait( nextnode.script_delay );
	index = 0;
	self.loopcount++;
	index++;
	self thread heli_leave( hardpointtype );
	return;
	currentnode = nextnode;
	self setgoalyaw( currentnode.angles[1] );
	self.reached_dest = 1;
	self notify( "destination reached" );
	heli_wait( self.waittime );
	self thread heli_evasive( hardpointtype );
// SP = 0x0 - check OK
}

// 0x6A38
heli_random_point_in_radius( protectdest, nodeheight )
{
	min_distance = int( level.heli_protect_radius * 0.2 );
	direction = randomintrange( 0, 360 );
	distance = randomintrange( min_distance, level.heli_protect_radius );
	x = cos( direction );
	y = sin( direction );
	x *= distance;
	y *= distance;
	return ( protectdest[0] + x, protectdest[1] + y, nodeheight );
// SP = 0x0 - check OK
}

// 0x6AC0
heli_get_protect_spot( protectdest, nodeheight )
{
	protect_spot = heli_random_point_in_radius( protectdest, nodeheight );
	tries = 10;
	noflyzone = crossesnoflyzone( protectdest, protect_spot );
	protect_spot = heli_random_point_in_radius( protectdest, nodeheight );
	tries--;
	noflyzone = crossesnoflyzone( protectdest, protect_spot );
	noflyzoneheight = getnoflyzoneheightcrossed( protectdest, protect_spot, nodeheight );
	return ( protect_spot[0], protect_spot[1], noflyzoneheight );
// SP = 0x0 - check OK
}

// 0x6B48
wait_or_waittill( time, msg1, msg2 )
{
	self endon( msg1 );
	self endon( msg2 );
	wait time;
	return 1;
// SP = 0x0 - check OK
}

// 0x6B64
set_heli_speed_normal()
{
	self setmaxpitchroll( 30, 30 );
	heli_speed = 30 + randomint( 20 );
	heli_accel = 10 + randomint( 5 );
	self setspeed( heli_speed, heli_accel );
	self setyawspeed( 75, 45, 45 );
// SP = 0x0 - check OK
}

// 0x6BBC
set_heli_speed_evasive()
{
	self setmaxpitchroll( 30, 90 );
	heli_speed = 50 + randomint( 20 );
	heli_accel = 30 + randomint( 5 );
	self setspeed( heli_speed, heli_accel );
	self setyawspeed( 100, 75, 75 );
// SP = 0x0 - check OK
}

// 0x6C14
set_heli_speed_hover()
{
	self setmaxpitchroll( 0, 90 );
	self setspeed( 20, 10 );
	self setyawspeed( 55, 25, 25 );
// SP = 0x0 - check OK
}

// 0x6C48
is_targeted()
{
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x6C78
heli_mobilespawn( protectdest )
{
	self endon( "death" );
	self notify( "flying" );
	self endon( "flying" );
	self endon( "abandoned" );
	iprintlnbold( "PROTECT ORIGIN: (" + protectdest[0] + "," + protectdest[1] + "," + protectdest[2] + ")\n" );
	heli_reset();
	self sethoverparams( 50, 100, 50 );
	wait 2;
	set_heli_speed_normal();
	self setvehgoalpos( protectdest, 1 );
	self waittill( "near_goal" );
	set_heli_speed_hover();
// SP = 0x0 - check OK
}

// 0x6D08
heli_protect( startnode, protectdest, hardpointtype, heli_team )
{
	self endon( "death" );
	self notify( "flying" );
	self endon( "flying" );
	self endon( "abandoned" );
	self.reached_dest = 0;
	heli_reset();
	self sethoverparams( 50, 100, 50 );
	wait 2;
	currentdest = protectdest;
	nodeheight = protectdest[2];
	nextnode = startnode;
	heightoffset = 0;
	heightoffset = 800;
	protectdest = ( protectdest[0], protectdest[1], nodeheight );
	noflyzoneheight = getnoflyzoneheight( protectdest );
	protectdest = ( protectdest[0], protectdest[1], noflyzoneheight + heightoffset );
	currentdest = protectdest;
	starttime = GetTime();
	endtime = starttime + level.heli_protect_time * 1000;
	self setspeed( 150, 80 );
	self setvehgoalpos( self.origin + currentdest - self.origin / 3 + vector_scale( ( 0, 0, 1 ), 1000 ) );
	self waittill( "near_goal" );
	heli_speed = 30 + randomint( 20 );
	heli_accel = 10 + randomint( 5 );
	self thread updatetargetyaw();
	mapenter = 1;
	stop = 1;
	self updatespeed();
	mapenter = 0;
	self setvehgoalpos( currentdest, stop );
	self thread updatespeedonlock();
	self waittill_any( "near_goal", "locking on" );
	maps\mp\gametypes\_hostmigration::waittillhostmigrationdone();
	self notify( "path start" );
	waittillframeend;
	time = level.heli_protect_pos_time;
	time = 2;
	set_heli_speed_hover();
	wait_or_waittill( time, "locking on", "damage state" );
	prevdest = currentdest;
	currentdest = heli_get_protect_spot( protectdest, nodeheight );
	noflyzoneheight = getnoflyzoneheight( currentdest );
	currentdest = ( currentdest[0], currentdest[1], noflyzoneheight + heightoffset );
	noflyzones = crossesnoflyzones( prevdest, currentdest );
	currentdest = prevdest;
	self thread heli_leave( hardpointtype );
// SP = 0x0 - check OK
}

// 0x6F50
updatespeedonlock()
{
	self endon( "death" );
	self endon( "crashing" );
	self endon( "leaving" );
	self waittill_any( "near_goal", "locking on" );
	self updatespeed();
// SP = 0x0 - check OK
}

// 0x6F88
updatespeed()
{
	set_heli_speed_evasive();
	set_heli_speed_normal();
// SP = 0x0 - check OK
}

// 0x6FC4
updatetargetyaw()
{
	self notify( "endTargetYawUpdate" );
	self endon( "death" );
	self endon( "crashing" );
	self endon( "leaving" );
	self endon( "endTargetYawUpdate" );
	yaw = get2dyaw( self.origin, self.primarytarget.origin );
	self settargetyaw( yaw );
	wait 1;
// SP = 0x0 - check OK
}

// 0x7024
fire_missile( smissiletype, ishots, etarget )
{
	ishots = 1;
/#
	assert( self.health > 0 );
#/
	weaponname = undefined;
	weaponshoottime = undefined;
	tags = [];
	switch ( smissiletype )
	{
		case "ffar":
			weaponname = "hind_FFAR_mp";
			tags[0] = "tag_store_r_2";
			break;
		default:
/#
			assertmsg( "Invalid missile type specified. Must be ffar" );
#/
			break;
	}
/#
	assert( IsDefined( weaponname ) );
#/
/#
	assert( tags.size > 0 );
#/
	weaponshoottime = weaponfiretime( weaponname );
/#
	assert( IsDefined( weaponshoottime ) );
#/
	self setvehweapon( weaponname );
	nextmissiletag = -1;
	i = 0;
	nextmissiletag++;
	nextmissiletag = 0;
	emissile = self fireweapon( tags[nextmissiletag], etarget );
	emissile = self fireweapon( tags[nextmissiletag] );
	emissile.killcament = self;
	self.lastrocketfiretime = GetTime();
	wait weaponshoottime;
	i++;
// SP = 0x0 - check OK
}

// 0x7164
check_owner( hardpointtype )
{
	self notify( "abandoned" );
	self thread heli_leave( hardpointtype );
// SP = 0x0 - check OK
}

// 0x71A8
attack_targets( missilesenabled, hardpointtype )
{
	self thread attack_primary( hardpointtype );
	self thread attack_secondary( hardpointtype );
// SP = 0x0 - check OK
}

// 0x71D0
attack_secondary( hardpointtype )
{
	self endon( "death" );
	self endon( "crashing" );
	self endon( "leaving" );
	self.secondarytarget.antithreat = undefined;
	self.missiletarget = self.secondarytarget;
	antithreat = 0;
	self thread missile_support( self.missiletarget, level.heli_missile_rof, 1, undefined );
	antithreat += 100;
	self.missiletarget.antithreat = antithreat;
	wait level.heli_missile_rof;
	self.missiletarget.antithreat = undefined;
	self waittill( "secondary acquired" );
	self check_owner( hardpointtype );
// SP = 0x0 - check OK
}

// 0x72C4
turret_target_check( turrettarget, attackangle )
{
	targetyaw = get2dyaw( self.origin, turrettarget.origin );
	chopperyaw = self.angles[1];
	targetyaw *= -1;
	targetyaw = int( targetyaw ) % 360;
	chopperyaw *= -1;
	chopperyaw = int( chopperyaw ) % 360;
	difference = chopperyaw - targetyaw;
	difference = targetyaw - chopperyaw;
	return difference <= attackangle;
// SP = 0x0 - check OK
}

// 0x7360
target_cone_check( target, conecosine )
{
	heli2target_normal = vectornormalize( target.origin - self.origin );
	heli2forward = anglestoforward( self.angles );
	heli2forward_normal = vectornormalize( heli2forward );
	heli_dot_target = vectordot( heli2target_normal, heli2forward_normal );
	debug_print3d_simple( "Cone sight: " + heli_dot_target, self, vector_scale( ( 0, 0, -1 ), 40 ), 40 );
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x73E0
missile_valid_target_check( missiletarget )
{
	heli2target_normal = vectornormalize( missiletarget.origin - self.origin );
	heli2forward = anglestoforward( self.angles );
	heli2forward_normal = vectornormalize( heli2forward );
	heli_dot_target = vectordot( heli2target_normal, heli2forward_normal );
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x7440
missile_support( target_player, rof, instantfire, endon_notify )
{
	self endon( "death" );
	self endon( "crashing" );
	self endon( "leaving" );
	self endon( endon_notify );
	self.turret_giveup = 0;
	wait rof;
	self.turret_giveup = 1;
	self notify( "give up" );
	i = 0;
	player = level.players[i];
	debug_print3d_simple( "Missile omitted due to nearby friendly", self, vector_scale( ( 0, 0, -1 ), 80 ), 40 );
	self notify( "missile ready" );
	return;
	i++;
	player = self.owner;
	debug_print3d_simple( "Missile omitted due to nearby friendly", self, vector_scale( ( 0, 0, -1 ), 80 ), 40 );
	self notify( "missile ready" );
	return;
	self fire_missile( "ffar", 1, target_player );
	self.missile_ammo--;
	self notify( "missile fired" );
	return;
	wait rof;
	self notify( "missile ready" );
// SP = 0x0 - check OK
}

// 0x75C0
attack_primary( hardpointtype )
{
	self endon( "death" );
	self endon( "crashing" );
	self endon( "leaving" );
	level endon( "game_ended" );
	self.primarytarget.antithreat = undefined;
	self.turrettarget = self.primarytarget;
	antithreat = 0;
	last_pos = undefined;
	self setlookatent( self.turrettarget );
	helicopterturretmaxangle = heli_get_dvar_int( "scr_helicopterTurretMaxAngle", level.helicopterturretmaxangle );
	wait 0.1;
	self setturrettargetent( self.turrettarget, vector_scale( ( 0, 0, 1 ), 50 ) );
	self waittill( "turret_on_target" );
	maps\mp\gametypes\_hostmigration::waittillhostmigrationdone();
	self notify( "turret_on_target" );
	self thread playpilotdialog( "attackheli_target" );
	self thread turret_target_flag( self.turrettarget );
	wait level.heli_turret_spinup_delay;
	weaponshoottime = weaponfiretime( self.defaultweapon );
	self setvehweapon( self.defaultweapon );
	i = 0;
	self setturrettargetent( self.primarytarget, vector_scale( ( 0, 0, 1 ), 40 ) );
	self setturrettargetvec( self.turret_last_pos );
	self clearturrettarget();
	self setvehweapon( self.defaultweapon );
	minigun = self fireweapon( "tag_flash" );
	wait weaponshoottime;
	i++;
	self notify( "turret reloading" );
	wait level.heli_turretreloadtime;
	antithreat += 100;
	self.turrettarget.antithreat = antithreat;
	self.turrettarget.antithreat = undefined;
	self waittill( "primary acquired" );
	self check_owner( hardpointtype );
// SP = 0x0 - check OK
}

// 0x7874
turret_target_flag( turrettarget )
{
	self notify( "flag check is running" );
	self endon( "flag check is running" );
	self endon( "death" );
	self endon( "crashing" );
	self endon( "leaving" );
	self endon( "turret reloading" );
	turrettarget endon( "death" );
	turrettarget endon( "disconnect" );
	self.targetlost = 0;
	self.turret_last_pos = undefined;
	heli_centroid = self.origin + vector_scale( ( 0, 0, -1 ), 160 );
	heli_forward_norm = anglestoforward( self.angles );
	heli_turret_point = heli_centroid + 144 * heli_forward_norm;
	sight_rec = turrettarget sightconetrace( heli_turret_point, self );
	wait 0.05;
/#
	assert( IsDefined( turrettarget.origin ), "turrettarget.origin is undefined after isdefined check" );
#/
	self.turret_last_pos = turrettarget.origin + vector_scale( ( 0, 0, 1 ), 40 );
/#
	assert( IsDefined( self.turret_last_pos ), "self.turret_last_pos is undefined after setting it #1" );
#/
	self setturrettargetvec( self.turret_last_pos );
/#
	assert( IsDefined( self.turret_last_pos ), "self.turret_last_pos is undefined after setting it #2" );
#/
	debug_print3d_simple( "Turret target lost at: " + self.turret_last_pos, self, vector_scale( ( 0, 0, -1 ), 70 ), 60 );
	self.targetlost = 1;
	self.targetlost = undefined;
	self.turret_last_pos = undefined;
// SP = 0x0 - check OK
}

// 0x79C4
debug_print_target()
{
	name = "dog";
	name = self.primarytarget.name;
	primary_msg = "Primary: " + name + " : " + self.primarytarget.threatlevel;
	primary_msg = "Primary: ";
	name = "dog";
	name = self.secondarytarget.name;
	secondary_msg = "Secondary: " + name + " : " + self.secondarytarget.threatlevel;
	secondary_msg = "Secondary: ";
	frames = int( self.targeting_delay * 20 ) + 1;
	thread draw_text( primary_msg, ( 1, 0.6, 0.6 ), self, vector_scale( ( 0, 0, 1 ), 40 ), frames );
	thread draw_text( secondary_msg, ( 1, 0.6, 0.6 ), self, ( 0, 0, 0 ), frames );
// SP = 0x0 - check OK
}

// 0x7B1C
improved_sightconetrace( helicopter )
{
	heli_centroid = helicopter.origin + vector_scale( ( 0, 0, -1 ), 160 );
	heli_forward_norm = anglestoforward( helicopter.angles );
	heli_turret_point = heli_centroid + 144 * heli_forward_norm;
	debug_line( heli_turret_point, self.origin, ( 1, 1, 1 ), 5 );
	start = heli_turret_point;
	yes = 0;
	point = [];
	i = 0;
	half_height = self.origin + vector_scale( ( 0, 0, 1 ), 36 );
	tovec = start - half_height;
	tovec_angles = vectortoangles( tovec );
	forward_norm = anglestoforward( tovec_angles );
	side_norm = anglestoright( tovec_angles );
	point[point.size] = self.origin + vector_scale( ( 0, 0, 1 ), 36 );
	point[point.size] = self.origin + side_norm * vector_scale( ( 1, 1, 0 ), 15 ) + vector_scale( ( 0, 0, 1 ), 10 );
	point[point.size] = self.origin + side_norm * vector_scale( ( -1, -1, 0 ), 15 ) + vector_scale( ( 0, 0, 1 ), 10 );
	point[point.size] = point[2] + vector_scale( ( 0, 0, 1 ), 64 );
	point[point.size] = point[1] + vector_scale( ( 0, 0, 1 ), 64 );
	debug_line( point[1], point[2], ( 1, 1, 1 ), 1 );
	debug_line( point[2], point[3], ( 1, 1, 1 ), 1 );
	debug_line( point[3], point[4], ( 1, 1, 1 ), 1 );
	debug_line( point[4], point[1], ( 1, 1, 1 ), 1 );
	debug_line( start, point[i], ( randomint( 10 ) / 10, randomint( 10 ) / 10, randomint( 10 ) / 10 ), 1 );
	yes++;
	waittillframeend;
	i++;
	return yes / 5;
// SP = 0x0 - check OK
}

// 0x7D18
waittill_confirm_location()
{
	self endon( "emp_jammed" );
	self endon( "emp_grenaded" );
	self waittill( "confirm_location", location );
	return location;
// SP = 0x0 - check OK
}

// 0x7D38
selecthelicopterlocation( hardpointtype )
{
	self beginlocationcomlinkselection( "compass_objpoint_helicopter", 1500 );
	self.selectinglocation = 1;
	self thread endselectionthink();
	location = self waittill_confirm_location();
	return 0;
	return 0;
	level.helilocation = location;
	return finishhardpointlocationusage( location, ::nullcallback );
// SP = 0x0 - check OK
}

// 0x7DB4
nullcallback( arg1, arg2 )
{
	return 1;
// SP = 0x0 - check OK
}

// 0x7DC4
processcopterassist( destroyedcopter, damagedone )
{
	self endon( "disconnect" );
	destroyedcopter endon( "disconnect" );
	wait 0.05;
	return;
	return;
	assist_level = "aircraft_destruction_assist";
	assist_level_value = int( ceil( damagedone / destroyedcopter.maxhealth * 4 ) );
	assist_level_value = 3;
	assist_level = ( assist_level + "_" ) + assist_level_value * 25;
	maps\mp\_scoreevents::processscoreevent( assist_level, self );
// SP = 0x0 - check OK
}

// 0x7E5C
samturretwatcher()
{
	self endon( "death" );
	self endon( "crashing" );
	self endon( "leaving" );
	level endon( "game_ended" );
	self waittill_any( "turret_on_target", "path start", "near_goal" );
	target_setturretaquire( self, 1 );
// SP = 0x0 - check OK
}

// 0x7E9C
playpilotdialog( dialog, time, voice, shouldwait )
{
	self endon( "death" );
	level endon( "remote_end" );
	wait time;
	self.pilotvoicenumber = 0;
	voicenumber = voice;
	voicenumber = self.pilotvoicenumber;
	soundalias = level.teamprefix[self.team] + voicenumber + "_" + dialog;
	self.owner playpilottalking( shouldwait, soundalias );
// SP = 0x0 - check OK
}

// 0x7F20
playpilottalking( shouldwait, soundalias )
{
	self endon( "disconnect" );
	self endon( "joined_team" );
	self endon( "joined_spectators" );
	trycounter = 0;
	return;
	wait 1;
	trycounter++;
	self.pilottalking = 1;
	self playlocalsound( soundalias );
	wait 3;
	self.pilottalking = 0;
// SP = 0x0 - check OK
}

// 0x7F90
watchforearlyleave( hardpointtype )
{
	self endon( "heli_timeup" );
	self waittill_any( "joined_team", "disconnect" );
	self.heli thread heli_leave( hardpointtype );
	self notify( "heli_timeup" );
// SP = 0x0 - check OK
}