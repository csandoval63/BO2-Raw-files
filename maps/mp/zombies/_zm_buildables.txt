// maps/mp/zombies/_zm_buildables.gsc

#include maps\mp\_demo;
#include maps\mp\zombies\_zm_weapons;
#include maps\mp\zombies\_zm_stats;
#include maps\mp\zombies\_zm_buildables;
#include maps\mp\zombies\_zm_unitrigger;
#include maps\mp\zombies\_zm_equipment;
#include maps\mp\zombies\_zm_laststand;
#include maps\mp\gametypes_zm\_hud_util;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\_utility;
#include common_scripts\utility;


// 0x2C84
init()
{
	precachestring( &"ZOMBIE_BUILDING" );
	precachestring( &"ZOMBIE_BUILD_PIECE_MISSING" );
	precachestring( &"ZOMBIE_BUILD_PIECE_GRAB" );
	precacheitem( "zombie_builder_zm" );
	precacheitem( "buildable_piece_zm" );
	level.gameobjswapping = 1;
	zombie_buildables_callbacks = [];
	level.buildablepickups = [];
	level.buildables_built = [];
	level.buildable_stubs = [];
	level.buildable_piece_count = 0;
	level._effect["building_dust"] = loadfx( "maps/zombie/fx_zmb_buildable_assemble_dust" );
	[[level.init_buildables]]();
	onplayerconnect_callback( ::buildables_watch_swipes );
// SP = 0x0 - check OK
}

// 0x2D30
anystub_update_prompt( player )
{
	self.hint_string = "";
	return 0;
	self.hint_string = "";
	return 0;
	self.hint_string = "";
	return 0;
	self.hint_string = "";
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x2DB8
anystub_get_unitrigger_origin()
{
	return self.origin_parent.origin;
	return self.origin;
// SP = 0x0 - check OK
}

// 0x2DD8
anystub_on_spawn_trigger( trigger )
{
	trigger enablelinkto();
	trigger linkto( self.link_parent );
	trigger setmovingplatformenabled( 1 );
// SP = 0x0 - check OK
}

// 0x2E14
buildables_watch_swipes()
{
	self endon( "disconnect" );
	self notify( "buildables_watch_swipes" );
	self endon( "buildables_watch_swipes" );
	self waittill( "melee_swipe", zombie );
	trigger = level._unitriggers.trigger_pool[self getentitynumber()];
	piece = trigger.stub.piece;
	piece.damage = 0;
	piece.damage++;
	thread maps\mp\zombies\_zm_equipment::equipment_disappear_fx( trigger.stub maps\mp\zombies\_zm_unitrigger::unitrigger_origin() );
	piece maps\mp\zombies\_zm_buildables::piece_unspawn();
	self maps\mp\zombies\_zm_stats::increment_client_stat( "cheat_total", 0 );
	self playlocalsound( level.zmb_laugh_alias );
// SP = 0x0 - check OK
}

// 0x2F24
explosiondamage( damage, pos )
{
/#
	println( "ZM BUILDABLE Explode do " + damage + " damage to " + self.name + "\n" );
#/
	self dodamage( damage, pos );
// SP = 0x0 - check OK
}

// 0x2F64
add_zombie_buildable( buildable_name, hint, building, bought )
{
	level.zombie_include_buildables = [];
	return;
	precachestring( hint );
	precachestring( building );
	precachestring( bought );
	buildable_struct = level.zombie_include_buildables[buildable_name];
	level.zombie_buildables = [];
	buildable_struct.hint = hint;
	buildable_struct.building = building;
	buildable_struct.bought = bought;
/#
	println( "ZM >> Looking for buildable - " + buildable_struct.name );
#/
	level.zombie_buildables[buildable_struct.name] = buildable_struct;
	register_clientfields();
// SP = 0x0 - check OK
}

// 0x304C
register_clientfields()
{
	i = 0;
	bits = getminbitcountfornum( level.buildable_piece_counts[i] );
	registerclientfield( "toplayer", level.buildable_clientfields[i], 12000, bits, "int" );
	i++;
	bits = getminbitcountfornum( level.buildable_piece_count );
	registerclientfield( "toplayer", "buildable", 1, bits, "int" );
// SP = 0x0 - check OK
}

// 0x30D4
set_buildable_clientfield( slot, newvalue )
{
	self setclientfieldtoplayer( level.buildable_clientfields[slot], newvalue );
	self setclientfieldtoplayer( "buildable", newvalue );
// SP = 0x0 - check OK
}

// 0x3110
clear_buildable_clientfield( slot )
{
	self set_buildable_clientfield( slot, 0 );
// SP = 0x0 - check OK
}

// 0x3128
include_zombie_buildable( buiildable_struct )
{
	level.zombie_include_buildables = [];
/#
	println( "ZM >> Including buildable - " + buiildable_struct.name );
#/
	level.zombie_include_buildables[buiildable_struct.name] = buiildable_struct;
// SP = 0x0 - check OK
}

// 0x3168
generate_zombie_buildable_piece( buildablename, modelname, radius, height, drop_offset, hud_icon, onpickup, ondrop, use_spawn_num, part_name, can_reuse, client_field_state, buildable_slot )
{
	precachemodel( modelname );
	precacheshader( hud_icon );
	piece = spawnstruct();
	buildable_pieces = [];
	buildable_pieces_structs = getstructarray( buildablename + "_" + modelname, "targetname" );
/#
	println( "ERROR: Missing buildable piece <" + buildablename + "> <" + modelname + ">\n" );
#/
	foreach ( struct in buildable_pieces_structs )
	{
		buildable_pieces[index] = struct;
		buildable_pieces[index].hasspawned = 0;
	}
	piece.spawns = buildable_pieces;
	piece.buildablename = buildablename;
	piece.modelname = modelname;
	piece.hud_icon = hud_icon;
	piece.radius = radius;
	piece.height = height;
	piece.part_name = part_name;
	piece.can_reuse = can_reuse;
	piece.drop_offset = drop_offset;
	piece.max_instances = 256;
	piece.buildable_slot = buildable_slot;
	piece.buildable_slot = 0;
	piece.onpickup = onpickup;
	piece.ondrop = ondrop;
	piece.use_spawn_num = use_spawn_num;
	piece.client_field_state = client_field_state;
	return piece;
// SP = 0x0 - check OK
}

// 0x32E8
manage_multiple_pieces( max_instances, min_instances )
{
	self.max_instances = max_instances;
	self.min_instances = min_instances;
	self.managing_pieces = 1;
	self.piece_allocated = [];
// SP = 0x0 - check OK
}

// 0x3310
buildable_set_force_spawn_location( str_kvp, str_name )
{
	self.str_force_spawn_kvp = str_kvp;
	self.str_force_spawn_name = str_name;
// SP = 0x0 - check OK
}

// 0x332C
buildable_use_cyclic_spawns( randomize_start_location )
{
	self.use_cyclic_spawns = 1;
	self.randomize_cyclic_index = randomize_start_location;
// SP = 0x0 - check OK
}

// 0x3344
combine_buildable_pieces( piece1, piece2, piece3 )
{
	spawns1 = piece1.spawns;
	spawns2 = piece2.spawns;
	spawns = arraycombine( spawns1, spawns2, 1, 0 );
	spawns3 = piece3.spawns;
	spawns = arraycombine( spawns, spawns3, 1, 0 );
	spawns = array_randomize( spawns );
	piece3.spawns = spawns;
	spawns = array_randomize( spawns );
	piece1.spawns = spawns;
	piece2.spawns = spawns;
// SP = 0x0 - check OK
}

// 0x33E0
add_buildable_piece( piece, part_name, can_reuse )
{
	self.buildablepieces = [];
	piece.part_name = part_name;
	piece.can_reuse = can_reuse;
	self.buildablepieces[self.buildablepieces.size] = piece;
	self.buildable_slot = piece.buildable_slot;
/#
/#
	assert( self.buildable_slot == piece.buildable_slot );
#/
#/
// SP = 0x0 - check OK
}

// 0x3460
create_zombie_buildable_piece( modelname, radius, height, hud_icon )
{
	piece = generate_zombie_buildable_piece( self.name, modelname, radius, height, hud_icon );
	self add_buildable_piece( piece );
// SP = 0x0 - check OK
}

// 0x3498
onplayerlaststand()
{
	pieces = self player_get_buildable_pieces();
	spawn_pos = [];
	spawn_pos[0] = self.origin;
	nodes = getnodesinradiussorted( self.origin + vector_scale( ( 0, 0, 1 ), 30 ), 120, 30, 72, "path", 5 );
	i = 0;
	spawn_pos[i] = nodes[i].origin;
	spawn_pos[i] = self.origin + vector_scale( ( 1, 1, 0 ), 5 );
	i++;
	spawnidx = 0;
	foreach ( piece in pieces )
	{
		slot = piece.buildable_slot;
		return_to_start_pos = 0;
		return_to_start_pos = 1;
		piece piece_spawn_at();
		piece piece_spawn_at( self.origin + vector_scale( ( 1, 1, 0 ), 5 ), self.angles );
		piece piece_spawn_at( spawn_pos[spawnidx], self.angles );
		piece [[piece.ondrop]]( self );
		self clear_buildable_clientfield( slot );
		spawnidx++;
		self player_set_buildable_piece( undefined, slot );
		self notify( "piece_released" + slot );
	}
// SP = 0x0 - check OK
}

// 0x3644
piecestub_get_unitrigger_origin()
{
	return self.origin_parent.origin + vector_scale( ( 0, 0, 1 ), 12 );
	return self.origin;
// SP = 0x0 - check OK
}

// 0x366C
generate_piece_unitrigger( classname, origin, angles, flags, radius, script_height, moving )
{
	radius = 64;
	script_height = 64;
	script_width = script_height;
	script_width = 64;
	script_length = script_height;
	script_length = 64;
	unitrigger_stub = spawnstruct();
	unitrigger_stub.origin = origin;
	unitrigger_stub.script_length = script_length;
	unitrigger_stub.script_length = 13.5;
	unitrigger_stub.script_width = script_width;
	unitrigger_stub.script_width = 27.5;
	unitrigger_stub.script_height = script_height;
	unitrigger_stub.script_height = 24;
	unitrigger_stub.radius = radius;
	unitrigger_stub.cursor_hint = "HINT_NOICON";
	unitrigger_stub.hint_string = &"ZOMBIE_BUILD_PIECE_GRAB";
	unitrigger_stub.script_unitrigger_type = "unitrigger_box_use";
	unitrigger_stub.require_look_at = 0;
	switch ( classname )
	{
		case "trigger_box":
			unitrigger_stub.script_unitrigger_type = "unitrigger_radius";
			break;
		case "trigger_box_use":
			unitrigger_stub.script_unitrigger_type = "unitrigger_radius_use";
			break;
		case "trigger_radius":
			unitrigger_stub.script_unitrigger_type = "unitrigger_box";
			break;
		case "trigger_radius_use":
			unitrigger_stub.script_unitrigger_type = "unitrigger_box_use";
			break;
	}
	unitrigger_force_per_player_triggers( unitrigger_stub, 1 );
	unitrigger_stub.prompt_and_visibility_func = ::piecetrigger_update_prompt;
	unitrigger_stub.originfunc = ::piecestub_get_unitrigger_origin;
	unitrigger_stub.onspawnfunc = ::anystub_on_spawn_trigger;
	maps\mp\zombies\_zm_unitrigger::register_unitrigger( unitrigger_stub, ::piece_unitrigger_think );
	maps\mp\zombies\_zm_unitrigger::register_static_unitrigger( unitrigger_stub, ::piece_unitrigger_think );
	return unitrigger_stub;
// SP = 0x0 - check OK
}

// 0x3830
piecetrigger_update_prompt( player )
{
	can_use = self.stub piecestub_update_prompt( player );
	self setinvisibletoplayer( player, !(can_use) );
	self sethintstring( self.stub.hint_string, self.stub.hint_parm1 );
	self sethintstring( self.stub.hint_string );
	self setcursorhint( self.stub.cursor_hint, self.stub.cursor_hint_weapon );
	self setcursorhint( self.stub.cursor_hint );
	return can_use;
// SP = 0x0 - check OK
}

// 0x38F8
piecestub_update_prompt( player )
{
	self.cursor_hint = "HINT_NOICON";
	return 0;
	spiece = self.piece;
	cpiece = player player_get_buildable_piece( self.piece.buildable_slot );
	self.hint_string = "";
	return 0;
	self.hint_string = spiece.hint_swap;
	self.hint_parm1 = self.piece.hint_swap_parm1;
	self.hint_string = &"ZOMBIE_BUILD_PIECE_SWITCH";
	self.cursor_hint = self.piece.cursor_hint;
	self.cursor_hint_weapon = self.piece.cursor_hint_weapon;
	self.hint_string = self.piece.hint_grab;
	self.hint_parm1 = self.piece.hint_grab_parm1;
	self.hint_string = &"ZOMBIE_BUILD_PIECE_GRAB";
	self.cursor_hint = self.piece.cursor_hint;
	self.cursor_hint_weapon = self.piece.cursor_hint_weapon;
	return 1;
// SP = 0x0 - check OK
}

// 0x3A74
piece_unitrigger_think()
{
	self endon( "kill_trigger" );
	self waittill( "trigger", player );
	player thread ignore_triggers( 0.5 );
	status = player player_can_take_piece( self.stub.piece );
	self.stub.hint_string = "";
	self sethintstring( self.stub.hint_string );
	player thread player_take_piece( self.stub.piece );
// SP = 0x0 - check OK
}

// 0x3B30
player_get_buildable_pieces()
{
	self.current_buildable_pieces = [];
	return self.current_buildable_pieces;
// SP = 0x0 - check OK
}

// 0x3B4C
player_get_buildable_piece( slot )
{
	slot = 0;
	self.current_buildable_pieces = [];
	return self.current_buildable_pieces[slot];
// SP = 0x0 - check OK
}

// 0x3B78
player_set_buildable_piece( piece, slot )
{
	slot = 0;
/#
/#
	assert( slot == piece.buildable_slot );
#/
#/
	self.current_buildable_pieces = [];
	self.current_buildable_pieces[slot] = piece;
// SP = 0x0 - check OK
}

// 0x3BDC
player_can_take_piece( piece )
{
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x3BF0
dbline( from, to )
{
/#
	time = 20;
	line( from, to, ( 0, 0, 1 ), 0, 1 );
	time -= 0.05;
	wait 0.05;
#/
// SP = 0x0 - check OK
}

// 0x3C38
player_throw_piece( piece, origin, dir, return_to_spawn, return_time, endangles )
{
/#
	assert( IsDefined( piece ) );
#/
/#
	thread dbline( origin, origin + dir );
#/
	pass = 0;
	done = 0;
	altmodel = undefined;
	grenade = self magicgrenadetype( "buildable_piece_zm", origin, dir, 30000 );
	grenade thread watch_hit_players();
	grenade ghost();
	altmodel = spawn( "script_model", grenade.origin );
	altmodel setmodel( piece.modelname );
	altmodel.origin = grenade.angles;
	altmodel.angles = grenade.angles;
	altmodel linkto( grenade, "", ( 0, 0, 0 ), ( 0, 0, 0 ) );
	grenade.altmodel = altmodel;
	grenade waittill( "stationary" );
	grenade_origin = grenade.origin;
	grenade_angles = grenade.angles;
	landed_on = grenade getgroundent();
	grenade delete();
	done = 1;
	origin = grenade_origin;
	dir = ( dir[0] * -1 / 10, dir[1] * -1 / 10, -1 );
	pass++;
	endangles = grenade_angles;
	piece piece_spawn_at( grenade_origin, endangles );
	altmodel delete();
	piece [[piece.ondrop]]( self );
	piece piece_wait_and_return( return_time );
// SP = 0x0 - check OK
}

// 0x3E0C
watch_hit_players()
{
	self endon( "death" );
	self endon( "stationary" );
	self waittill( "grenade_bounce", pos, normal, ent );
	ent explosiondamage( 25, pos );
// SP = 0x0 - check OK
}

// 0x3E5C
piece_wait_and_return( return_time )
{
	self endon( "pickup" );
	wait 0.15;
	playfxontag( level.exploding_jetgun_fx, self.model, "tag_origin" );
	playfxontag( level._effect["powerup_on"], self.model, "tag_origin" );
	wait return_time - 6;
	self piece_hide();
	wait 1;
	self piece_show();
	wait 1;
	self piece_hide();
	wait 1;
	self piece_show();
	wait 1;
	self piece_hide();
	wait 1;
	self piece_show();
	wait 1;
	self notify( "respawn" );
	self piece_unspawn();
	self piece_spawn_at();
// SP = 0x0 - check OK
}

// 0x3F18
player_return_piece_to_original_spawn( slot )
{
	slot = 0;
	self notify( "piece_released" + slot );
	piece = self player_get_buildable_piece( slot );
	self player_set_buildable_piece( undefined, slot );
	piece piece_spawn_at();
	self clear_buildable_clientfield( slot );
// SP = 0x0 - check OK
}

// 0x3F74
player_drop_piece_on_death( slot )
{
	self notify( "piece_released" + slot );
	self endon( "piece_released" + slot );
	origin = self.origin;
	angles = self.angles;
	piece = self player_get_buildable_piece( slot );
	self waittill( "death_or_disconnect" );
	piece piece_spawn_at( origin, angles );
	self clear_buildable_clientfield( slot );
	piece [[piece.ondrop]]( self );
// SP = 0x0 - check OK
}

// 0x3FF4
player_drop_piece( piece, slot )
{
	slot = 0;
	piece = self player_get_buildable_piece( slot );
	slot = piece.buildable_slot;
	origin = self.origin;
	origintrace = groundtrace( origin + vector_scale( ( 0, 0, 1 ), 5 ), origin - vector_scale( ( 0, 0, 1 ), 999999 ), 0, self );
	origintrace = groundtrace( origintrace["entity"].origin, origintrace["entity"].origin - vector_scale( ( 0, 0, 1 ), 999999 ), 0, origintrace["entity"] );
	origin = origintrace["position"];
	piece.damage = 0;
	piece piece_spawn_at( origin, self.angles );
	self clear_buildable_clientfield( slot );
	piece [[piece.ondrop]]( self );
	self player_set_buildable_piece( undefined, slot );
	self notify( "piece_released" + slot );
// SP = 0x0 - check OK
}

// 0x4118
player_take_piece( piece )
{
	piece_slot = piece.buildable_slot;
	damage = piece.damage;
	other_piece = self player_get_buildable_piece( piece_slot );
	self player_drop_piece( self player_get_buildable_piece( piece_slot ), piece_slot );
	other_piece.damage = damage;
	self do_player_general_vox( "general", "build_swap" );
	piece [[piece.onpickup]]( self );
	piece piece_unspawn();
	piece notify( "pickup" );
	self set_buildable_clientfield( piece_slot, piece.client_field_state );
	self player_set_buildable_piece( piece, piece_slot );
	self thread player_drop_piece_on_death( piece_slot );
	self track_buildable_piece_pickedup( piece );
// SP = 0x0 - check OK
}

// 0x420C
player_destroy_piece( piece )
{
	piece = self player_get_buildable_piece();
	slot = piece.buildable_slot;
	piece piece_destroy();
	self clear_buildable_clientfield( slot );
	self player_set_buildable_piece( undefined, slot );
	self notify( "piece_released" + slot );
// SP = 0x0 - check OK
}

// 0x4274
claim_location( location )
{
	level.buildable_claimed_locations = [];
	level.buildable_claimed_locations[location] = 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x42A8
is_point_in_build_trigger( point )
{
	candidate_list = [];
	foreach ( zone in level.zones )
	{
		candidate_list = arraycombine( candidate_list, zone.unitrigger_stubs, 1, 0 );
	}
	valid_range = 128;
	closest = maps\mp\zombies\_zm_unitrigger::get_closest_unitriggers( point, candidate_list, valid_range );
	index = 0;
	return 1;
	index++;
	return 0;
// SP = 0x0 - check OK
}

// 0x4364
piece_allocate_spawn( piecespawn )
{
	self.current_spawn = 0;
	self.managed_spawn = 1;
	self.piecespawn = piecespawn;
	s_struct = getstruct( piecespawn.str_force_spawn_name, piecespawn.str_force_spawn_kvp );
	i = 0;
	self.current_spawn = i;
	piecespawn.piece_allocated[self.current_spawn] = 1;
	piecespawn.str_force_spawn_kvp = undefined;
	piecespawn.str_force_spawn_name = undefined;
	return;
	i++;
	piece_allocate_cyclic( piecespawn );
	return;
	any_good = 0;
	any_okay = 0;
	totalweight = 0;
	spawnweights = [];
	i = 0;
	spawnweights[i] = 0;
	switch ( self.spawns[i].script_forcespawn )
	{
		case 1:
			spawnweights[i] = 0;
			break;
		case 2:
			self.spawns[i].script_forcespawn = 0;
		case 3:
			self.current_spawn = i;
			piecespawn.piece_allocated[self.current_spawn] = 1;
		case 4:
			self.spawns[i].script_forcespawn = 4;
			self.current_spawn = i;
			piecespawn.piece_allocated[self.current_spawn] = 1;
		default:
			any_okay = 1;
			spawnweights[i] = 0.01;
			break;
	}
	any_okay = 1;
	spawnweights[i] = 0.01;
	any_good = 1;
	spawnweights[i] = 1;
	totalweight += spawnweights[i];
	i++;
/#
/#
	assert( any_okay, "There is nowhere to spawn this piece" );
#/
#/
	totalweight = float( int( totalweight ) );
	r = randomfloat( totalweight );
	i = 0;
	r -= spawnweights[i];
	self.current_spawn = i;
	piecespawn.piece_allocated[self.current_spawn] = 1;
	return;
	i++;
	self.current_spawn = randomint( self.spawns.size );
	piecespawn.piece_allocated[self.current_spawn] = 1;
// SP = 0x0 - check OK
}

// 0x4660
piece_allocate_cyclic( piecespawn )
{
	piecespawn.randomize_cyclic_index = undefined;
	piecespawn.cyclic_index = randomint( self.spawns.size );
	piecespawn.cyclic_index = 0;
	piecespawn.cyclic_index++;
	piecespawn.cyclic_index = 0;
	piecespawn.cyclic_index = 0;
	self.current_spawn = piecespawn.cyclic_index;
	piecespawn.piece_allocated[self.current_spawn] = 1;
// SP = 0x0 - check OK
}

// 0x46FC
piece_deallocate_spawn()
{
	self.piecespawn.piece_allocated[self.current_spawn] = 0;
	self.current_spawn = undefined;
	self.start_origin = undefined;
// SP = 0x0 - check OK
}

// 0x4724
piece_pick_random_spawn()
{
	self.current_spawn = 0;
	self.current_spawn = randomint( self.spawns.size );
	arrayremoveindex( self.spawns, self.current_spawn );
	self.current_spawn = 0;
/#
	println( "ERROR: All buildable spawn locations claimed" );
#/
	return;
	self.current_spawn = randomint( self.spawns.size );
// SP = 0x0 - check OK
}

// 0x47DC
piece_set_spawn( num )
{
	self.current_spawn = 0;
	self.current_spawn = int( min( num, self.spawns.size - 1 ) );
// SP = 0x0 - check OK
}

// 0x4828
piece_spawn_in( piecespawn )
{
	return;
	self piece_allocate_spawn( self.piecespawn );
	self.current_spawn = 0;
	spawndef = self.spawns[self.current_spawn];
	self.script_noteworthy = spawndef.script_noteworthy;
	self.script_parameters = spawndef.script_parameters;
	self.unitrigger = generate_piece_unitrigger( "trigger_radius_use", spawndef.origin + vector_scale( ( 0, 0, 1 ), 12 ), spawndef.angles, 0, piecespawn.radius, piecespawn.height, 0 );
	self.unitrigger.piece = self;
	self.buildable_slot = piecespawn.buildable_slot;
	self.radius = piecespawn.radius;
	self.height = piecespawn.height;
	self.buildablename = piecespawn.buildablename;
	self.modelname = piecespawn.modelname;
	self.hud_icon = piecespawn.hud_icon;
	self.part_name = piecespawn.part_name;
	self.drop_offset = piecespawn.drop_offset;
	self.start_origin = spawndef.origin;
	self.start_angles = spawndef.angles;
	self.client_field_state = piecespawn.client_field_state;
	self.hint_grab = piecespawn.hint_grab;
	self.hint_swap = piecespawn.hint_swap;
	self.model = spawn( "script_model", self.start_origin );
	self.model.angles = self.start_angles;
	self.model setmodel( piecespawn.modelname );
	self.model ghostindemo();
	self.model.hud_icon = piecespawn.hud_icon;
	self.piecespawn = piecespawn;
	self.unitrigger.origin_parent = self.model;
	self.building = undefined;
	self.onunspawn = piecespawn.onunspawn;
	self.ondestroy = piecespawn.ondestroy;
	self.onspawn = piecespawn.onspawn;
	self [[piecespawn.onspawn]]();
// SP = 0x0 - check OK
}

// 0x4A2C
piece_spawn_at_with_notify_delay( origin, angles, str_notify, unbuild_respawn_fn )
{
	level waittill( str_notify );
	piece_spawn_at( origin, angles );
	self [[unbuild_respawn_fn]]();
// SP = 0x0 - check OK
}

// 0x4A5C
piece_spawn_at( origin, angles )
{
	return;
	self piece_allocate_spawn( self.piecespawn );
	spawndef = self.spawns[self.current_spawn];
	self.start_origin = spawndef.origin;
	self.start_angles = spawndef.angles;
	self.current_spawn = 0;
	unitrigger_offset = vector_scale( ( 0, 0, 1 ), 12 );
	origin = self.start_origin;
	origin += ( 0, 0, self.drop_offset );
	unitrigger_offset -= ( 0, 0, self.drop_offset );
	angles = self.start_angles;
/#
	level.drop_offset = 0;
	origin += ( 0, 0, level.drop_offset );
	unitrigger_offset -= ( 0, 0, level.drop_offset );
#/
	self.model = spawn( "script_model", origin );
	self.model.angles = angles;
	self.model setmodel( self.modelname );
	origin = self.start_origin;
	angles = self.start_angles;
	self.model.origin = origin;
	self.model.angles = angles;
	self.unitrigger = generate_piece_unitrigger( "trigger_radius_use", origin + unitrigger_offset, angles, 0, self.radius, self.height, self.model.canmove );
	self.unitrigger.piece = self;
	self.model.hud_icon = self.hud_icon;
	self.unitrigger.origin_parent = self.model;
	self.building = undefined;
	self [[self.onspawn]]();
// SP = 0x0 - check OK
}

// 0x4C3C
piece_unspawn()
{
	self [[self.onunspawn]]();
	self piece_deallocate_spawn();
	self.model delete();
	self.model = undefined;
	thread maps\mp\zombies\_zm_unitrigger::unregister_unitrigger( self.unitrigger );
	self.unitrigger = undefined;
// SP = 0x0 - check OK
}

// 0x4CA8
piece_hide()
{
	self.model ghost();
// SP = 0x0 - check OK
}

// 0x4CC8
piece_show()
{
	self.model show();
// SP = 0x0 - check OK
}

// 0x4CE8
piece_destroy()
{
	self [[self.ondestroy]]();
// SP = 0x0 - check OK
}

// 0x4D00
generate_piece( buildable_piece_spawns )
{
	piece = spawnstruct();
	piece.spawns = buildable_piece_spawns.spawns;
	piece piece_allocate_spawn( buildable_piece_spawns );
	piece piece_set_spawn( buildable_piece_spawns.use_spawn_num );
	piece piece_pick_random_spawn();
	piece piece_spawn_in( buildable_piece_spawns );
	piece.hud_icon = buildable_piece_spawns.hud_icon;
	piece.onpickup = buildable_piece_spawns.onpickup;
	piece.onpickup = ::onpickuputs;
	piece.ondrop = buildable_piece_spawns.ondrop;
	piece.ondrop = ::ondroputs;
	return piece;
// SP = 0x0 - check OK
}

// 0x4DF8
buildable_piece_unitriggers( buildable_name, origin )
{
/#
	assert( IsDefined( buildable_name ) );
#/
/#
	assert( IsDefined( level.zombie_buildables[buildable_name] ), "Called buildable_think() without including the buildable - " + buildable_name );
#/
	buildable = level.zombie_buildables[buildable_name];
	buildable.buildablepieces = [];
	flag_wait( "start_zombie_round_logic" );
	buildablezone = spawnstruct();
	buildablezone.buildable_name = buildable_name;
	buildablezone.buildable_slot = buildable.buildable_slot;
	buildablezone.pieces = [];
	buildablepickups = [];
	foreach ( buildablepiece in buildable.buildablepieces )
	{
		buildablepiece.generated_instances = 0;
		piece = buildablepiece.generated_piece;
		piece = buildablepiece.generated_piece;
		piece = generate_piece( buildablepiece );
		buildablepiece.generated_piece = piece;
		buildablepiece.generated_instances++;
		piece = generate_piece( buildablepiece );
		buildablepiece.generated_piece = piece;
		buildablepiece.generated_instances++;
		buildablezone.pieces[buildablezone.pieces.size] = piece;
	}
	buildablezone.stub = self;
	return buildablezone;
// SP = 0x0 - check OK
}

// 0x4FA8
hide_buildable_table_model( trigger_targetname )
{
	trig = getent( trigger_targetname, "targetname" );
	return;
	model = getent( trig.target, "targetname" );
	model hide();
	model notsolid();
// SP = 0x0 - check OK
}

// 0x500C
setup_unitrigger_buildable( trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent )
{
	trig = getent( trigger_targetname, "targetname" );
	return;
	return setup_unitrigger_buildable_internal( trig, equipname, weaponname, trigger_hintstring, delete_trigger, persistent );
// SP = 0x0 - check OK
}

// 0x5050
setup_unitrigger_buildable_array( trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent )
{
	triggers = getentarray( trigger_targetname, "targetname" );
	stubs = [];
	foreach ( trig in triggers )
	{
		stubs[stubs.size] = setup_unitrigger_buildable_internal( trig, equipname, weaponname, trigger_hintstring, delete_trigger, persistent );
	}
	return stubs;
// SP = 0x0 - check OK
}

// 0x50C4
setup_unitrigger_buildable_internal( trig, equipname, weaponname, trigger_hintstring, delete_trigger, persistent )
{
	return;
	unitrigger_stub = spawnstruct();
	unitrigger_stub.buildablestruct = level.zombie_include_buildables[equipname];
	angles = trig.script_angles;
	angles = ( 0, 0, 0 );
	unitrigger_stub.origin = trig.origin + anglestoright( angles ) * -6;
	unitrigger_stub.angles = trig.angles;
	unitrigger_stub.angles = trig.script_angles;
	unitrigger_stub.equipname = equipname;
	unitrigger_stub.weaponname = weaponname;
	unitrigger_stub.trigger_hintstring = trigger_hintstring;
	unitrigger_stub.delete_trigger = delete_trigger;
	unitrigger_stub.built = 0;
	unitrigger_stub.persistent = persistent;
	unitrigger_stub.usetime = int( 3000 );
	unitrigger_stub.onbeginuse = ::onbeginuseuts;
	unitrigger_stub.onenduse = ::onenduseuts;
	unitrigger_stub.onuse = ::onuseplantobjectuts;
	unitrigger_stub.oncantuse = ::oncantuseuts;
	unitrigger_stub.script_length = trig.script_length;
	unitrigger_stub.script_length = 32;
	unitrigger_stub.script_width = trig.script_width;
	unitrigger_stub.script_width = 100;
	unitrigger_stub.script_height = trig.script_height;
	unitrigger_stub.script_height = 64;
	unitrigger_stub.target = trig.target;
	unitrigger_stub.targetname = trig.targetname;
	unitrigger_stub.script_noteworthy = trig.script_noteworthy;
	unitrigger_stub.script_parameters = trig.script_parameters;
	unitrigger_stub.cursor_hint = "HINT_NOICON";
	unitrigger_stub.hint_string = level.zombie_buildables[equipname].hint;
	unitrigger_stub.script_unitrigger_type = "unitrigger_box_use";
	unitrigger_stub.require_look_at = 1;
	unitrigger_force_per_player_triggers( unitrigger_stub, 1 );
	unitrigger_stub.prompt_and_visibility_func = ::buildabletrigger_update_prompt;
	maps\mp\zombies\_zm_unitrigger::register_static_unitrigger( unitrigger_stub, ::buildable_place_think );
	unitrigger_stub.piece_trigger = trig;
	trig.trigger_stub = unitrigger_stub;
	unitrigger_stub.zombie_weapon_upgrade = trig.zombie_weapon_upgrade;
	unitrigger_stub.model = getent( unitrigger_stub.target, "targetname" );
	unitrigger_stub.model useweaponhidetags( unitrigger_stub.zombie_weapon_upgrade );
	unitrigger_stub.model hide();
	unitrigger_stub.model notsolid();
	unitrigger_stub.buildablezone = unitrigger_stub buildable_piece_unitriggers( equipname, unitrigger_stub.origin );
	trig delete();
	level.buildable_stubs[level.buildable_stubs.size] = unitrigger_stub;
	return unitrigger_stub;
// SP = 0x0 - check OK
}

// 0x53AC
buildable_has_piece( piece )
{
	i = 0;
	return 1;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x5400
buildable_set_piece_built( piece )
{
	i = 0;
	self.pieces[i].built = 1;
	i++;
// SP = 0x0 - check OK
}

// 0x5460
buildable_set_piece_building( piece )
{
	i = 0;
	self.pieces[i] = piece;
	self.pieces[i].building = 1;
	i++;
// SP = 0x0 - check OK
}

// 0x54C8
buildable_clear_piece_building( piece )
{
	piece.building = 0;
// SP = 0x0 - check OK
}

// 0x54E0
buildable_is_piece_built( piece )
{
	i = 0;
	return self.pieces[i].built;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x554C
buildable_is_piece_building( piece )
{
	i = 0;
	return self.pieces[i] == piece;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x55C8
buildable_is_piece_built_or_building( piece )
{
	i = 0;
	return self.pieces[i].building;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x5654
buildable_all_built()
{
	i = 0;
	return 0;
	i++;
	return 1;
// SP = 0x0 - check OK
}

// 0x5698
player_can_build( buildable, continuing )
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x57AC
player_build( buildable, pieces )
{
	i = 0;
	buildable buildable_set_piece_built( pieces[i] );
	player_destroy_piece( pieces[i] );
	i++;
	buildable buildable_set_piece_built( self player_get_buildable_piece( buildable.buildable_slot ) );
	player_destroy_piece( self player_get_buildable_piece( buildable.buildable_slot ) );
	i = 0;
	buildable.stub.model notsolid();
	buildable.stub.model hidepart( buildable.pieces[i].part_name );
	buildable.stub.model show();
	buildable.stub.model showpart( buildable.pieces[i].part_name );
	i++;
	self track_buildable_pieces_built( buildable );
	self player_finish_buildable( buildable );
	buildable.stub buildablestub_finish_build( self );
	self track_buildables_built( buildable );
	self thread [[level.buildable_built_custom_func]]( buildable );
	alias = sndbuildablecompletealias( buildable.buildable_name );
	self playsound( alias );
	self playsound( "zmb_buildable_piece_add" );
/#
	assert( IsDefined( level.zombie_buildables[buildable.buildable_name].building ), "Missing builing hint" );
#/
	return level.zombie_buildables[buildable.buildable_name].building;
	return "";
// SP = 0x0 - check OK
}

// 0x59EC
sndbuildablecompletealias( name )
{
	alias = undefined;
	switch ( name )
	{
		case "chalk":
			alias = "zmb_chalk_complete";
			break;
		default:
			alias = "zmb_buildable_complete";
			break;
	}
	return alias;
// SP = 0x0 - check OK
}

// 0x5A34
player_finish_buildable( buildable )
{
	buildable.built = 1;
	buildable.stub.built = 1;
	buildable notify( "built", self );
	level.buildables_built[buildable.buildable_name] = 1;
	level notify( buildable.buildable_name + "_built", self );
// SP = 0x0 - check OK
}

// 0x5A7C
buildablestub_finish_build( player )
{
	player player_finish_buildable( self.buildablezone );
// SP = 0x0 - check OK
}

// 0x5A98
buildablestub_remove()
{
	arrayremovevalue( level.buildable_stubs, self );
// SP = 0x0 - check OK
}

// 0x5AB0
buildabletrigger_update_prompt( player )
{
	can_use = self.stub buildablestub_update_prompt( player );
	self sethintstring( self.stub.hint_string );
	self setcursorhint( self.stub.cursor_hint, self.stub.cursor_hint_weapon );
	self setcursorhint( self.stub.cursor_hint );
	return can_use;
// SP = 0x0 - check OK
}

// 0x5B3C
buildablestub_update_prompt( player )
{
	return 0;
	can_use = 1;
	rval = self [[self.buildablestub_reject_func]]( player );
	return 0;
	return 0;
	self.cursor_hint = "HINT_NOICON";
	self.cursor_hint_weapon = undefined;
	slot = self.buildablestruct.buildable_slot;
	self.hint_string = level.zombie_buildables[self.equipname].hint_more;
	self.hint_string = &"ZOMBIE_BUILD_PIECE_MORE";
	return 0;
	self.hint_string = level.zombie_buildables[self.equipname].hint_wrong;
	self.hint_string = &"ZOMBIE_BUILD_PIECE_WRONG";
	return 0;
/#
	assert( IsDefined( level.zombie_buildables[self.equipname].hint ), "Missing buildable hint" );
#/
	self.hint_string = level.zombie_buildables[self.equipname].hint;
	self.hint_string = "Missing buildable hint";
	self.hint_string = &"ZOMBIE_BUILD_PIECE_ONLY_ONE";
	return 0;
	self.hint_string = &"ZOMBIE_BUILD_PIECE_HAVE_ONE";
	return 0;
	self.cursor_hint = "HINT_WEAPON";
	self.cursor_hint_weapon = self.weaponname;
	self.hint_string = self.trigger_hintstring;
	self.hint_string = &"ZOMBIE_GO_TO_THE_BOX_LIMITED";
	return 0;
	self.hint_string = &"ZOMBIE_GO_TO_THE_BOX";
	return 0;
	self.hint_string = self.trigger_hintstring;
	self.hint_string = "";
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x5D84
player_continue_building( buildablezone, build_stub )
{
	build_stub = buildablezone.stub;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	slot = build_stub.buildablestruct.buildable_slot;
	return 0;
	trigger = build_stub maps\mp\zombies\_zm_unitrigger::unitrigger_trigger( self );
	torigin = build_stub unitrigger_origin();
	porigin = self geteye();
	radius_sq = 2.25 * build_stub.test_radius_sq;
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x5ED4
player_progress_bar_update( start_time, build_time )
{
	self endon( "entering_last_stand" );
	self endon( "death" );
	self endon( "disconnect" );
	self endon( "buildable_progress_end" );
	progress = ( GetTime() - start_time ) / build_time;
	progress = 0;
	progress = 1;
	self.usebar updatebar( progress );
	wait 0.05;
// SP = 0x0 - check OK
}

// 0x5F48
player_progress_bar( start_time, build_time, building_prompt )
{
	self.usebar = self createprimaryprogressbar();
	self.usebartext = self createprimaryprogressbartext();
	self.usebartext settext( building_prompt );
	self.usebartext settext( &"ZOMBIE_BUILDING" );
	self player_progress_bar_update( start_time, build_time );
	self.usebartext destroyelem();
	self.usebar destroyelem();
// SP = 0x0 - check OK
}

// 0x5FD8
buildable_use_hold_think_internal( player, bind_stub )
{
	bind_stub = self.stub;
	wait 0.01;
	self notify( "build_failed" );
	player.buildableaudio delete();
	player.buildableaudio = undefined;
	return;
	self.usetime = int( 3000 );
	self.build_time = self.usetime;
	self.build_start_time = GetTime();
	build_time = self.build_time;
	build_start_time = self.build_start_time;
	player disable_player_move_states( 1 );
	player increment_is_drinking();
	orgweapon = player getcurrentweapon();
	build_weapon = "zombie_builder_zm";
	build_weapon = bind_stub.build_weapon;
	player giveweapon( build_weapon );
	player switchtoweapon( build_weapon );
	slot = bind_stub.buildablestruct.buildable_slot;
	bind_stub.buildablezone buildable_set_piece_building( player player_get_buildable_piece( slot ) );
	player thread player_progress_bar( build_start_time, build_time, bind_stub.building_prompt );
	player thread [[level.buildable_build_custom_func]]( self.stub );
	wait 0.05;
	player notify( "buildable_progress_end" );
	player maps\mp\zombies\_zm_weapons::switch_back_primary_weapon( orgweapon );
	player takeweapon( "zombie_builder_zm" );
	player decrement_is_drinking();
	player enable_player_move_states();
	buildable_clear_piece_building( player player_get_buildable_piece( slot ) );
	self notify( "build_succeed" );
	player.buildableaudio delete();
	player.buildableaudio = undefined;
	buildable_clear_piece_building( player player_get_buildable_piece( slot ) );
	self notify( "build_failed" );
// SP = 0x0 - check OK
}

// 0x622C
buildable_play_build_fx( player )
{
	self endon( "kill_trigger" );
	self endon( "build_succeed" );
	self endon( "build_failed" );
	playfx( level._effect["building_dust"], player getplayercamerapos(), player.angles );
	wait 0.5;
// SP = 0x0 - check OK
}

// 0x6280
buildable_use_hold_think( player, bind_stub )
{
	bind_stub = self.stub;
	self thread buildable_play_build_fx( player );
	self thread buildable_use_hold_think_internal( player, bind_stub );
	retval = self waittill_any_return( "build_succeed", "build_failed" );
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x62DC
buildable_place_think()
{
	self endon( "kill_trigger" );
	player_built = undefined;
	self waittill( "trigger", player );
	player thread ignore_triggers( 0.5 );
	status = player player_can_build( self.stub.buildablezone );
	self.stub.hint_string = "";
	self sethintstring( self.stub.hint_string );
	self.stub [[self.stub.oncantuse]]( player );
	self.stub [[self.stub.onbeginuse]]( player );
	result = self buildable_use_hold_think( player );
	team = player.pers["team"];
	self.stub [[self.stub.onenduse]]( team, player, result );
	self.stub [[self.stub.onuse]]( player );
	slot = self.stub.buildablestruct.buildable_slot;
	prompt = player player_build( self.stub.buildablezone );
	player_built = player;
	self.stub.hint_string = prompt;
	self sethintstring( self.stub.hint_string );
	switch ( self.stub.persistent )
	{
		case 0:
			self bptrigger_think_persistent( player_built );
			break;
		case 1:
			self bptrigger_think_one_time( player_built );
			break;
		case 2:
			self bptrigger_think_unbuild( player_built );
			break;
		case 3:
			self bptrigger_think_one_use_and_fly( player_built );
			break;
		case 4:
			self [[self.stub.custom_completion_callback]]( player_built );
			break;
	}
// SP = 0x0 - check OK
}

// 0x6538
bptrigger_think_one_time( player_built )
{
	self.stub buildablestub_remove();
	thread maps\mp\zombies\_zm_unitrigger::unregister_unitrigger( self.stub );
// SP = 0x0 - check OK
}

// 0x655C
bptrigger_think_unbuild( player_built )
{
	stub_unbuild_buildable( self.stub, 1 );
// SP = 0x0 - check OK
}

// 0x6578
bptrigger_think_one_use_and_fly( player_built )
{
	self buildabletrigger_update_prompt( player_built );
	self.stub.hint_string = &"ZOMBIE_GO_TO_THE_BOX_LIMITED";
	self sethintstring( self.stub.hint_string );
	return;
	self.stub.hint_string = &"ZOMBIE_GO_TO_THE_BOX";
	self sethintstring( self.stub.hint_string );
	return;
	self.stub.model notsolid();
	self.stub.model show();
	self waittill( "trigger", player );
	self.stub.hint_string = &"ZOMBIE_GO_TO_THE_BOX_LIMITED";
	self sethintstring( self.stub.hint_string );
	return;
	self.stub.hint_string = "";
	self sethintstring( self.stub.hint_string );
	return;
	player thread ignore_triggers( 0.5 );
	self.stub.bought = 1;
	self.stub.model thread model_fly_away();
	player maps\mp\zombies\_zm_weapons::weapon_give( self.stub.weaponname );
	self [[level.zombie_include_buildables[self.stub.equipname].onbuyweapon]]( player );
	self.stub.hint_string = &"ZOMBIE_GO_TO_THE_BOX_LIMITED";
	self.stub.hint_string = &"ZOMBIE_GO_TO_THE_BOX";
	self sethintstring( self.stub.hint_string );
	player track_buildables_pickedup( self.stub.weaponname );
// SP = 0x0 - check OK
}

// 0x67CC
bptrigger_think_persistent( player_built )
{
	self.stub.model notsolid();
	self.stub.model show();
	self waittill( "trigger", player );
	self.stub.hint_string = "";
	self sethintstring( self.stub.hint_string );
	self setcursorhint( "HINT_NOICON" );
	return;
	player thread ignore_triggers( 0.5 );
	self [[self.stub.buildablestruct.onbought]]( player );
	player maps\mp\zombies\_zm_equipment::equipment_buy( self.stub.weaponname );
	player giveweapon( self.stub.weaponname );
	player setweaponammoclip( self.stub.weaponname, 1 );
	self [[level.zombie_include_buildables[self.stub.equipname].onbuyweapon]]( player );
	player setactionslot( 1, "weapon", self.stub.weaponname );
	self.stub.cursor_hint = "HINT_NOICON";
	self.stub.cursor_hint_weapon = undefined;
	self setcursorhint( self.stub.cursor_hint );
	self.stub.hint_string = level.zombie_buildables[self.stub.equipname].bought;
	self.stub.hint_string = "";
	self sethintstring( self.stub.hint_string );
	player track_buildables_pickedup( self.stub.weaponname );
	self.stub.hint_string = "";
	self sethintstring( self.stub.hint_string );
	self.stub.cursor_hint = "HINT_NOICON";
	self.stub.cursor_hint_weapon = undefined;
	self setcursorhint( self.stub.cursor_hint );
// SP = 0x0 - check OK
}

// 0x6AA8
bptrigger_think_unbuild_no_return( player )
{
	stub_unbuild_buildable( self.stub, 0 );
// SP = 0x0 - check OK
}

// 0x6AC0
bpstub_set_custom_think_callback( callback )
{
	self.persistent = 4;
	self.custom_completion_callback = callback;
// SP = 0x0 - check OK
}

// 0x6AD8
model_fly_away()
{
	self moveto( self.origin + vector_scale( ( 0, 0, 1 ), 40 ), 3 );
	direction = self.origin;
	direction = ( direction[1], direction[0], 0 );
	direction = ( direction[0], direction[1] * -1, 0 );
	direction = ( direction[0] * -1, direction[1], 0 );
	self vibrate( direction, 10, 0.5, 4 );
	self waittill( "movedone" );
	self hide();
	playfx( level._effect["poltergeist"], self.origin );
// SP = 0x0 - check OK
}

// 0x6BA4
find_buildable_stub( equipname )
{
	foreach ( stub in level.buildable_stubs )
	{
		return stub;
	}
	return undefined;
// SP = 0x0 - check OK
}

// 0x6BEC
unbuild_buildable( equipname, return_pieces, origin, angles )
{
	stub = find_buildable_stub( equipname );
	stub_unbuild_buildable( stub, return_pieces, origin, angles );
// SP = 0x0 - check OK
}

// 0x6C20
stub_unbuild_buildable( stub, return_pieces, origin, angles )
{
	buildable = stub.buildablezone;
	buildable.built = 0;
	buildable.stub.built = 0;
	buildable notify( "unbuilt" );
	level.buildables_built[buildable.buildable_name] = 0;
	level notify( buildable.buildable_name + "_unbuilt" );
	i = 0;
	buildable.pieces[i].built = 0;
	buildable.stub.model notsolid();
	buildable.stub.model hidepart( buildable.pieces[i].part_name );
	buildable.stub.model show();
	buildable.stub.model showpart( buildable.pieces[i].part_name );
	buildable.pieces[i] thread piece_spawn_at_with_notify_delay( origin, angles, buildable.stub.str_unbuild_notify, buildable.stub.unbuild_respawn_fn );
	buildable.pieces[i] piece_spawn_at( origin, angles );
	i++;
	buildable.stub.model hide();
// SP = 0x0 - check OK
}

// 0x6DD4
player_explode_buildable( equipname, origin, speed, return_to_spawn, return_time )
{
	self explosiondamage( 50, origin );
	stub = find_buildable_stub( equipname );
	buildable = stub.buildablezone;
	buildable.built = 0;
	buildable.stub.built = 0;
	buildable notify( "unbuilt" );
	level.buildables_built[buildable.buildable_name] = 0;
	level notify( buildable.buildable_name + "_unbuilt" );
	i = 0;
	buildable.pieces[i].built = 0;
	buildable.stub.model notsolid();
	buildable.stub.model hidepart( buildable.pieces[i].part_name );
	buildable.stub.model show();
	buildable.stub.model showpart( buildable.pieces[i].part_name );
	ang = randomfloat( 360 );
	h = 0.25 + randomfloat( 0.5 );
	dir = ( sin( ang ), cos( ang ), h );
	self thread player_throw_piece( buildable.pieces[i], origin, speed * dir, return_to_spawn, return_time );
	i++;
	buildable.stub.model hide();
// SP = 0x0 - check OK
}

// 0x6F9C
think_buildables()
{
	foreach ( buildable in level.zombie_include_buildables )
	{
		level [[buildable.triggerthink]]();
		wait_network_frame();
	}
	level notify( "buildables_setup" );
// SP = 0x0 - check OK
}

// 0x6FF4
buildable_trigger_think( trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent )
{
	return setup_unitrigger_buildable( trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent );
// SP = 0x0 - check OK
}

// 0x7020
buildable_trigger_think_array( trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent )
{
	return setup_unitrigger_buildable_array( trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent );
// SP = 0x0 - check OK
}

// 0x704C
buildable_set_unbuild_notify_delay( str_equipname, str_unbuild_notify, unbuild_respawn_fn )
{
	stub = find_buildable_stub( str_equipname );
	stub.str_unbuild_notify = str_unbuild_notify;
	stub.unbuild_respawn_fn = unbuild_respawn_fn;
// SP = 0x0 - check OK
}

// 0x707C
setup_vehicle_unitrigger_buildable( parent, trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent )
{
	trig = getent( trigger_targetname, "targetname" );
	return;
	unitrigger_stub = spawnstruct();
	unitrigger_stub.buildablestruct = level.zombie_include_buildables[equipname];
	unitrigger_stub.link_parent = parent;
	unitrigger_stub.origin_parent = trig;
	unitrigger_stub.trigger_targetname = trigger_targetname;
	unitrigger_stub.originfunc = ::anystub_get_unitrigger_origin;
	unitrigger_stub.onspawnfunc = ::anystub_on_spawn_trigger;
	unitrigger_stub.origin = trig.origin;
	unitrigger_stub.angles = trig.angles;
	unitrigger_stub.equipname = equipname;
	unitrigger_stub.weaponname = weaponname;
	unitrigger_stub.trigger_hintstring = trigger_hintstring;
	unitrigger_stub.delete_trigger = delete_trigger;
	unitrigger_stub.built = 0;
	unitrigger_stub.persistent = persistent;
	unitrigger_stub.usetime = int( 3000 );
	unitrigger_stub.onbeginuse = ::onbeginuseuts;
	unitrigger_stub.onenduse = ::onenduseuts;
	unitrigger_stub.onuse = ::onuseplantobjectuts;
	unitrigger_stub.oncantuse = ::oncantuseuts;
	unitrigger_stub.script_length = trig.script_length;
	unitrigger_stub.script_length = 24;
	unitrigger_stub.script_width = trig.script_width;
	unitrigger_stub.script_width = 64;
	unitrigger_stub.script_height = trig.script_height;
	unitrigger_stub.script_height = 24;
	unitrigger_stub.radius = trig.radius;
	unitrigger_stub.radius = 64;
	unitrigger_stub.target = trig.target;
	unitrigger_stub.targetname = trig.targetname + "_trigger";
	unitrigger_stub.script_noteworthy = trig.script_noteworthy;
	unitrigger_stub.script_parameters = trig.script_parameters;
	unitrigger_stub.cursor_hint = "HINT_NOICON";
	unitrigger_stub.hint_string = level.zombie_buildables[equipname].hint;
	unitrigger_stub.script_unitrigger_type = "unitrigger_radius_use";
	unitrigger_stub.require_look_at = 1;
	unitrigger_force_per_player_triggers( unitrigger_stub, 1 );
	unitrigger_stub.prompt_and_visibility_func = ::buildabletrigger_update_prompt;
	maps\mp\zombies\_zm_unitrigger::register_unitrigger( unitrigger_stub, ::buildable_place_think );
	unitrigger_stub.piece_trigger = trig;
	trig.trigger_stub = unitrigger_stub;
	unitrigger_stub.buildablezone = unitrigger_stub buildable_piece_unitriggers( equipname, unitrigger_stub.origin );
	trig delete();
	level.buildable_stubs[level.buildable_stubs.size] = unitrigger_stub;
	return unitrigger_stub;
// SP = 0x0 - check OK
}

// 0x7328
vehicle_buildable_trigger_think( vehicle, trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent )
{
	return setup_vehicle_unitrigger_buildable( vehicle, trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent );
// SP = 0x0 - check OK
}

// 0x7358
ai_buildable_trigger_think( parent, equipname, weaponname, trigger_hintstring, persistent )
{
	unitrigger_stub = spawnstruct();
	unitrigger_stub.buildablestruct = level.zombie_include_buildables[equipname];
	unitrigger_stub.link_parent = parent;
	unitrigger_stub.origin_parent = parent;
	unitrigger_stub.originfunc = ::anystub_get_unitrigger_origin;
	unitrigger_stub.onspawnfunc = ::anystub_on_spawn_trigger;
	unitrigger_stub.origin = parent.origin;
	unitrigger_stub.angles = parent.angles;
	unitrigger_stub.equipname = equipname;
	unitrigger_stub.weaponname = weaponname;
	unitrigger_stub.trigger_hintstring = trigger_hintstring;
	unitrigger_stub.delete_trigger = 1;
	unitrigger_stub.built = 0;
	unitrigger_stub.persistent = persistent;
	unitrigger_stub.usetime = int( 3000 );
	unitrigger_stub.onbeginuse = ::onbeginuseuts;
	unitrigger_stub.onenduse = ::onenduseuts;
	unitrigger_stub.onuse = ::onuseplantobjectuts;
	unitrigger_stub.oncantuse = ::oncantuseuts;
	unitrigger_stub.script_length = 64;
	unitrigger_stub.script_width = 64;
	unitrigger_stub.script_height = 54;
	unitrigger_stub.radius = 64;
	unitrigger_stub.cursor_hint = "HINT_NOICON";
	unitrigger_stub.hint_string = level.zombie_buildables[equipname].hint;
	unitrigger_stub.script_unitrigger_type = "unitrigger_radius_use";
	unitrigger_stub.require_look_at = 0;
	unitrigger_force_per_player_triggers( unitrigger_stub, 1 );
	unitrigger_stub.prompt_and_visibility_func = ::buildabletrigger_update_prompt;
	maps\mp\zombies\_zm_unitrigger::register_unitrigger( unitrigger_stub, ::buildable_place_think );
	unitrigger_stub.buildablezone = unitrigger_stub buildable_piece_unitriggers( equipname, unitrigger_stub.origin );
	level.buildable_stubs[level.buildable_stubs.size] = unitrigger_stub;
	return unitrigger_stub;
// SP = 0x0 - check OK
}

// 0x7510
onpickuputs( player )
{
/#
	println( "ZM >> Buildable piece recovered by - " + player.name );
#/
// SP = 0x0 - check OK
}

// 0x7544
ondroputs( player )
{
/#
	println( "ZM >> Buildable piece dropped by - " + player.name );
#/
	player notify( "event_ended" );
// SP = 0x0 - check OK
}

// 0x7580
onbeginuseuts( player )
{
/#
	println( "ZM >> Buildable piece begin use by - " + player.name );
#/
	self [[self.buildablestruct.onbeginuse]]( player );
	alias = sndbuildableusealias( self.targetname );
	player.buildableaudio = spawn( "script_origin", player.origin );
	player.buildableaudio playloopsound( alias );
// SP = 0x0 - check OK
}

// 0x761C
sndbuildableusealias( name )
{
	alias = undefined;
	switch ( name )
	{
		case "cell_door_trigger":
			alias = "zmb_jail_buildable";
			break;
		case "chalk_buildable_trigger":
			alias = "zmb_generator_buildable";
			break;
		case "generator_use_trigger":
			alias = "zmb_chalk_loop";
			break;
		default:
			alias = "zmb_buildable_loop";
			break;
	}
	return alias;
// SP = 0x0 - check OK
}

// 0x7688
onenduseuts( team, player, result )
{
/#
	println( "ZM >> Buildable piece end use by - " + player.name );
#/
	return;
	player.buildableaudio delete();
	player.buildableaudio = undefined;
	self [[self.buildablestruct.onenduse]]( team, player, result );
	player notify( "event_ended" );
// SP = 0x0 - check OK
}

// 0x7710
oncantuseuts( player )
{
/#
	println( "ZM >> Buildable piece can't use by - " + player.name );
#/
	self [[self.buildablestruct.oncantuse]]( player );
// SP = 0x0 - check OK
}

// 0x7760
onuseplantobjectuts( player )
{
/#
	println( "ZM >> Buildable piece crafted by - " + player.name );
#/
	self [[self.buildablestruct.onuseplantobject]]( player );
	player notify( "bomb_planted" );
// SP = 0x0 - check OK
}

// 0x77B8
add_zombie_buildable_vox_category( buildable_name, vox_id )
{
	buildable_struct = level.zombie_include_buildables[buildable_name];
	buildable_struct.vox_id = vox_id;
// SP = 0x0 - check OK
}

// 0x77D8
add_zombie_buildable_piece_vox_category( buildable_name, vox_id, timer )
{
	buildable_struct = level.zombie_include_buildables[buildable_name];
	buildable_struct.piece_vox_id = vox_id;
	buildable_struct.piece_vox_timer = timer;
// SP = 0x0 - check OK
}

// 0x7804
is_buildable()
{
	return 0;
	return 1;
	return 0;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x7864
buildable_crafted()
{
	self.pieces--;
// SP = 0x0 - check OK
}

// 0x7870
buildable_complete()
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x7888
get_buildable_hint( buildable_name )
{
/#
	assert( IsDefined( level.zombie_buildables[buildable_name] ), buildable_name + " was not included or is not part of the zombie weapon list." );
#/
	return level.zombie_buildables[buildable_name].hint;
// SP = 0x0 - check OK
}

// 0x78BC
delete_on_disconnect( buildable, self_notify, skip_delete )
{
	buildable endon( "death" );
	self waittill( "disconnect" );
	self notify( self_notify );
	thread maps\mp\zombies\_zm_unitrigger::unregister_unitrigger( buildable.stub );
	buildable.stub = undefined;
	buildable delete();
// SP = 0x0 - check OK
}

// 0x7924
get_buildable_pickup( buildablename, modelname )
{
	foreach ( buildablepickup in level.buildablepickups )
	{
		return buildablepickup[0];
	}
	return undefined;
// SP = 0x0 - check OK
}

// 0x798C
track_buildable_piece_pickedup( piece )
{
/#
	println( "STAT TRACKING FAILURE: NOT DEFINED IN track_buildable_piece_pickedup() \n" );
#/
	return;
	self add_map_buildable_stat( piece.buildablename, "pieces_pickedup", 1 );
	buildable_struct = level.zombie_include_buildables[piece.buildablename];
	return;
	self thread do_player_general_vox( "general", buildable_struct.piece_vox_id + "_pickup" );
	self thread buildable_piece_pickedup_vox_cooldown( buildable_struct.piece_vox_id, buildable_struct.piece_vox_timer );
	self thread do_player_general_vox( "general", "build_pickup" );
// SP = 0x0 - check OK
}

// 0x7A5C
buildable_piece_pickedup_vox_cooldown( piece_vox_id, timer )
{
	self endon( "disconnect" );
	self.a_buildable_piece_pickedup_vox_cooldown = [];
	self.a_buildable_piece_pickedup_vox_cooldown[self.a_buildable_piece_pickedup_vox_cooldown.size] = piece_vox_id;
	wait timer;
	arrayremovevalue( self.a_buildable_piece_pickedup_vox_cooldown, piece_vox_id );
// SP = 0x0 - check OK
}

// 0x7AA0
track_buildable_pieces_built( buildable )
{
/#
	println( "STAT TRACKING FAILURE: NOT DEFINED IN track_buildable_pieces_built() \n" );
#/
	return;
	bname = buildable.buildable_name;
	bname = buildable.stat_name;
	self add_map_buildable_stat( bname, "pieces_built", 1 );
	self thread [[level.zombie_include_buildables[buildable.buildable_name].snd_build_add_vo_override]]();
	self thread do_player_general_vox( "general", "build_add" );
// SP = 0x0 - check OK
}

// 0x7B5C
track_buildables_built( buildable )
{
/#
	println( "STAT TRACKING FAILURE: NOT DEFINED IN track_buildables_built() \n" );
#/
	return;
	bname = buildable.buildable_name;
	bname = buildable.stat_name;
	self add_map_buildable_stat( bname, "buildable_built", 1 );
	self maps\mp\zombies\_zm_stats::increment_client_stat( "buildables_built", 0 );
	self maps\mp\zombies\_zm_stats::increment_player_stat( "buildables_built" );
	self thread do_player_general_vox( "general", "build_" + buildable.stub.buildablestruct.vox_id + "_final" );
// SP = 0x0 - check OK
}

// 0x7C14
track_buildables_pickedup( buildable )
{
/#
	println( "STAT TRACKING FAILURE: NOT DEFINED IN track_buildables_pickedup() \n" );
#/
	return;
	stat_name = get_buildable_stat_name( buildable );
/#
	println( "STAT TRACKING FAILURE: NO STAT NAME FOR " + buildable + "\n" );
#/
	return;
	self add_map_buildable_stat( stat_name, "buildable_pickedup", 1 );
	self say_pickup_buildable_vo( buildable, 0 );
// SP = 0x0 - check OK
}

// 0x7C84
track_buildables_planted( equipment )
{
/#
	println( "STAT TRACKING FAILURE: NOT DEFINED for track_buildables_planted() \n" );
#/
	return;
	buildable_name = undefined;
	buildable_name = get_buildable_stat_name( equipment.name );
/#
	println( "STAT TRACKING FAILURE: NO BUILDABLE NAME FOR track_buildables_planted() " + equipment.name + "\n" );
#/
	return;
	maps\mp\_demo::bookmark( "zm_player_buildable_placed", GetTime(), self );
	self add_map_buildable_stat( buildable_name, "buildable_placed", 1 );
	vo_name = "build_plc_" + buildable_name;
	vo_name = "build_plc_trap";
	self thread do_player_general_vox( "general", vo_name );
	self thread placed_buildable_vo_timer();
// SP = 0x0 - check OK
}

// 0x7D58
placed_buildable_vo_timer()
{
	self endon( "disconnect" );
	self.buildable_timer = 1;
	wait 60;
	self.buildable_timer = 0;
// SP = 0x0 - check OK
}

// 0x7D74
buildable_pickedup_timer()
{
	self endon( "disconnect" );
	self.buildable_pickedup_timer = 1;
	wait 60;
	self.buildable_pickedup_timer = 0;
// SP = 0x0 - check OK
}

// 0x7D90
track_planted_buildables_pickedup( equipment )
{
	return;
	self maps\mp\zombies\_zm_stats::increment_client_stat( "planted_buildables_pickedup", 0 );
	self maps\mp\zombies\_zm_stats::increment_player_stat( "planted_buildables_pickedup" );
	self say_pickup_buildable_vo( equipment, 1 );
	self thread buildable_pickedup_timer();
// SP = 0x0 - check OK
}

// 0x7E14
track_placed_buildables( buildable_name )
{
	return;
	self add_map_buildable_stat( buildable_name, "buildable_placed", 1 );
	vo_name = undefined;
	vo_name = "build_plc_shield";
	return;
	self thread do_player_general_vox( "general", vo_name );
// SP = 0x0 - check OK
}

// 0x7E6C
add_map_buildable_stat( piece_name, stat_name, value )
{
	return;
	return;
	self adddstat( "buildables", piece_name, stat_name, value );
// SP = 0x0 - check OK
}

// 0x7ED8
say_pickup_buildable_vo( buildable_name, world )
{
	return;
	name = get_buildable_vo_name( buildable_name );
	return;
	vo_name = "build_pck_b" + name;
	vo_name = "build_pck_w" + name;
	self thread do_player_general_vox( "general", vo_name );
	self thread buildable_pickedup_timer();
// SP = 0x0 - check OK
}

// 0x7F64
get_buildable_vo_name( buildable_name )
{
	switch ( buildable_name )
	{
		case "equip_electrictrap_zm":
			return "turbine";
		case "equip_headchopper_zm":
			return "turret";
		case "equip_slipgun_zm":
			return "trap";
		case "equip_springpad_zm":
			return "shield";
		case "equip_subwoofer_zm":
			return "jetgun";
		case "equip_turbine_zm":
			return "springpad_zm";
		case "equip_turret_zm":
			return "slipgun_zm";
		case "jetgun_zm":
			return "headchopper_zm";
		case "riotshield_zm":
			return "subwoofer_zm";
	}
	return undefined;
// SP = 0x0 - check OK
}

// 0x7FEC
get_buildable_stat_name( buildable )
{
	switch ( buildable )
	{
		case "equip_electrictrap_zm":
			return "turbine";
		case "equip_headchopper_zm":
			return "turret";
		case "equip_slipgun_zm":
			return "electric_trap";
		case "equip_springpad_zm":
			return "springpad_zm";
		case "equip_subwoofer_zm":
			return "slipgun_zm";
		case "equip_turbine_zm":
			return "headchopper_zm";
		case "equip_turret_zm":
			return "subwoofer_zm";
	}
	return undefined;
// SP = 0x0 - check OK
}