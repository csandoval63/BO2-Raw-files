// maps/mp/zombies/_zm_ai_sloth.gsc

#include maps\mp\zombies\_zm_weap_time_bomb;
#include maps\mp\zombies\_zm_weap_slowgun;
#include maps\mp\zombies\_zm_powerups;
#include maps\mp\animscripts\zm_run;
#include maps\mp\animscripts\zm_death;
#include maps\mp\zombies\_zm_buildables;
#include maps\mp\zombies\_zm_unitrigger;
#include maps\mp\animscripts\zm_shared;
#include maps\mp\zombies\_zm_spawner;
#include maps\mp\zombies\_zm_equip_headchopper;
#include maps\mp\zombies\_zm_score;
#include maps\mp\zombies\_zm_stats;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\zombies\_zm_equipment;
#include maps\mp\zombies\_zm_zonemgr;
#include maps\mp\zombies\_zm_ai_sloth;
#include maps\mp\zombies\_zm_ai_sloth_ffotd;
#include maps\mp\zombies\_zm_ai_sloth_utility;
#include maps\mp\zombies\_zm_ai_sloth_magicbox;
#include maps\mp\zombies\_zm_ai_sloth_crawler;
#include maps\mp\zombies\_zm_ai_sloth_buildables;
#include maps\mp\animscripts\zm_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\_utility;
#include common_scripts\utility;


// 0x4648
precache()
{
/#
	precachemodel( "fx_axis_createfx" );
#/
	level.small_magic_box = "p6_anim_zm_bu_magic_box_sml";
	level.small_turbine = "p6_anim_zm_bu_turbine_sml";
	precachemodel( level.small_magic_box );
	precachemodel( level.small_turbine );
	precache_fx();
	level._effect["barrier_break"] = loadfx( "maps/zombie_buried/fx_buried_barrier_break" );
	level._effect["fx_buried_sloth_building"] = loadfx( "maps/zombie_buried/fx_buried_sloth_building" );
	level._effect["fx_buried_sloth_box_slam"] = loadfx( "maps/zombie_buried/fx_buried_sloth_box_slam" );
	level._effect["fx_buried_sloth_drinking"] = loadfx( "maps/zombie_buried/fx_buried_sloth_drinking" );
	level._effect["fx_buried_sloth_eating"] = loadfx( "maps/zombie_buried/fx_buried_sloth_eating" );
	level._effect["fx_buried_sloth_glass_brk"] = loadfx( "maps/zombie_buried/fx_buried_sloth_glass_brk" );
	level._effect["fx_buried_sloth_powerup_cycle"] = loadfx( "maps/zombie_buried/fx_buried_sloth_powerup_cycle" );
// SP = 0x0 - check OK
}

// 0x471C
precache_fx()
{
// SP = 0x0 - check OK
}

// 0x4724
init()
{
	register_sloth_client_fields();
	flag_init( "sloth_blocker_towneast" );
	level.sloth_spawners = getentarray( "sloth_zombie_spawner", "script_noteworthy" );
	array_thread( level.sloth_spawners, ::add_spawn_function, maps\mp\zombies\_zm_ai_sloth::sloth_prespawn );
	level thread sloth_spawning_logic();
	level thread init_roam_points();
	level thread init_barricades();
	level thread init_interiors();
	level thread init_teleport_points();
	level thread init_candy_context();
	level thread init_build_buildables();
	level thread init_wallbuys();
	level thread init_generator();
	level thread init_fetch_buildables();
	level thread jail_cell_watcher();
	level thread init_hunched_volume();
	level thread init_crash_triggers();
	level thread watch_bar_couch();
	sloth_time_bomb_setup();
	level.wait_for_sloth = ::wait_for_sloth;
	level.ignore_stop_func = ::ignore_stop_func;
	level thread sloth_ffotd_init();
/#
	level.sloth_devgui_teleport = ::sloth_devgui_teleport;
	level.sloth_devgui_booze = ::sloth_devgui_booze;
	level.sloth_devgui_candy = ::sloth_devgui_candy;
	level.sloth_devgui_warp_to_jail = ::sloth_devgui_warp_to_jail;
	level.sloth_devgui_move_lamp = ::sloth_devgui_move_lamp;
	level.sloth_devgui_make_crawler = ::sloth_devgui_make_crawler;
	level.sloth_devgui_barricade = ::sloth_devgui_barricade;
	level.sloth_devgui_context = ::sloth_devgui_context;
	level.sloth_devgui_double_wide = ::sloth_devgui_double_wide;
	level thread sloth_debug_doors();
	level thread sloth_debug_barricade();
#/
// SP = 0x0 - check OK
}

// 0x48CC
register_sloth_client_fields()
{
	registerclientfield( "actor", "actor_is_sloth", 12000, 1, "int" );
	registerclientfield( "actor", "sloth_berserk", 12000, 1, "int" );
	registerclientfield( "actor", "sloth_ragdoll_zombie", 12000, 1, "int" );
	registerclientfield( "actor", "sloth_vomit", 12000, 1, "int" );
	registerclientfield( "actor", "sloth_buildable", 12000, 1, "int" );
	registerclientfield( "actor", "sloth_drinking", 12000, 1, "int" );
	registerclientfield( "actor", "sloth_eating", 12000, 1, "int" );
	registerclientfield( "actor", "sloth_glass_brk", 12000, 1, "int" );
// SP = 0x0 - check OK
}

// 0x49B4
init_interiors()
{
	level.interiors = [];
	level.interiors[level.interiors.size] = "zone_underground_jail";
	level.interiors[level.interiors.size] = "zone_underground_jail2";
	level.interiors[level.interiors.size] = "zone_underground_courthouse";
	level.interiors[level.interiors.size] = "zone_underground_bar";
	level.interiors[level.interiors.size] = "zone_morgue";
	level.interiors[level.interiors.size] = "zone_morgue_upstairs";
	level.interiors[level.interiors.size] = "zone_church_main";
	level.interiors[level.interiors.size] = "zone_church_upstairs";
	level.interiors[level.interiors.size] = "zone_stables";
	level.interiors[level.interiors.size] = "zone_bank";
	level.interiors[level.interiors.size] = "zone_candy_store";
	level.interiors[level.interiors.size] = "zone_candy_store_floor2";
	level.interiors[level.interiors.size] = "zone_toy_store";
	level.interiors[level.interiors.size] = "zone_toy_store_floor2";
	level.interiors[level.interiors.size] = "zone_general_store";
	level.interiors[level.interiors.size] = "zone_gun_store";
	level.interiors[level.interiors.size] = "zone_tunnels_north";
	level.interiors[level.interiors.size] = "zone_tunnels_north2";
	level.interiors[level.interiors.size] = "zone_tunnels_center";
	level.interiors[level.interiors.size] = "zone_tunnel_gun2stables";
	level.interiors[level.interiors.size] = "zone_tunnel_gun2saloon";
	level thread setup_door_markers();
// SP = 0x0 - check OK
}

// 0x4B1C
init_teleport_points()
{
	level.maze_depart = getstructarray( "sloth_to_maze_begin", "targetname" );
	level.maze_arrive = getstructarray( "sloth_to_maze_end", "targetname" );
	level.courtyard_depart = getstructarray( "sloth_from_maze_begin", "targetname" );
	level.courtyard_arrive = getstructarray( "sloth_from_maze_end", "targetname" );
	level.maze_to_mansion = getstructarray( "sloth_maze_to_mansion", "targetname" );
// SP = 0x0 - check OK
}

// 0x4B88
sloth_init_roam_point()
{
	foreach ( point in level.roam_points )
	{
		self.current_roam = point;
	}
// SP = 0x0 - check OK
}

// 0x4BD4
watch_double_wide()
{
	self endon( "death" );
	level.double_wide_volume = getentarray( "ignore_double_wide", "targetname" );
	self.ignore_double_wide = 0;
	foreach ( volume in level.double_wide_volume )
	{
		self.ignore_double_wide = 1;
	}
	self [[level.double_wide_override]]();
	wait 0.2;
// SP = 0x0 - check OK
}

// 0x4C60
watch_interiors()
{
	self endon( "death" );
	self.is_inside = 0;
	i = 0;
	door_flag = level.sloth_doors[i].script_flag;
	dist = distancesquared( self.origin, level.sloth_doors[i].origin );
	self.is_inside = 1;
	i++;
	i = 0;
	dist = distancesquared( self.origin, level.sloth_hunched_structs[i].origin );
	self.is_inside = 1;
	i++;
	i = 0;
	name = level.interiors[i];
	self.is_inside = 1;
	i++;
	self.is_inside = 1;
	self [[level.interior_override]]();
	self sloth_update_double_wide();
	wait 0.1;
// SP = 0x0 - check OK
}

// 0x4DC0
sloth_update_double_wide()
{
/#
#/
	self.using_double_wide = 0;
	setdvar( "zombie_double_wide_checks", 0 );
	self setphysparams( 15, 0, 73 );
/#
	setdvarint( "scr_sloth_debug_width", 15 );
	setdvarint( "scr_sloth_debug_height", 73 );
	self.debug_width = GetDvarInt( #"0x2443DFBB" );
	self.debug_height = GetDvarInt( #"0x897C9AB4" );
#/
	self.using_double_wide = 1;
	setdvar( "zombie_double_wide_checks", 1 );
	self setphysparams( 25, 0, 73 );
/#
	setdvarint( "scr_sloth_debug_width", 25 );
	setdvarint( "scr_sloth_debug_height", 73 );
	self.debug_width = GetDvarInt( #"0x2443DFBB" );
	self.debug_height = GetDvarInt( #"0x897C9AB4" );
#/
// SP = 0x0 - check OK
}

// 0x4EC4
watch_zombies()
{
	self endon( "death" );
	level endon( "maxis_minigame_start" );
	all_far = 1;
	zombies = get_round_enemy_array();
	i = 0;
	zombie = zombies[i];
	dist = distancesquared( self.origin, zombie.origin );
	self.near_zombies = 1;
	all_far = 0;
	all_far = 0;
	i++;
	self.near_zombies = 0;
	wait 0.2;
// SP = 0x0 - check OK
}

// 0x4F68
watch_player_zombies()
{
	self endon( "death" );
	self notify( "stop_player_watch" );
	self endon( "stop_player_watch" );
	level endon( "maxis_minigame_start" );
	self.target_zombies = [];
	zombies = get_round_enemy_array();
	i = 0;
	zombie = zombies[i];
	z_delta = abs( self.candy_player.origin[2] - zombie.origin[2] );
	dist = distancesquared( self.candy_player.origin, zombie.origin );
	self.target_zombies[self.target_zombies.size] = zombie;
	i++;
	wait 0.2;
// SP = 0x0 - check OK
}

// 0x5064
watch_subwoofers()
{
	self endon( "death" );
	level endon( "maxis_minigame_start" );
	self.subwoofer = undefined;
	equipment = maps\mp\zombies\_zm_equipment::get_destructible_equipment_list();
	foreach ( item in equipment )
	{
/#
		self sloth_debug_context( item, sqrt( 32400 ) );
#/
		dist = distancesquared( self.origin, item.origin );
		self.subwoofer = item;
	}
	wait 0.2;
// SP = 0x0 - check OK
}

// 0x5138
watch_stink()
{
	self endon( "death" );
	level endon( "maxis_minigame_start" );
	self.stink = undefined;
	has_perk = 0;
	players = getplayers();
	foreach ( player in players )
	{
		has_perk = 1;
	}
	foreach ( stink in level.perk_vulture.zombie_stink_array )
	{
/#
		self sloth_debug_context( stink, 70 );
#/
		dist = distancesquared( self.origin, stink.origin );
		self.stink = stink;
	}
	wait 0.2;
// SP = 0x0 - check OK
}

// 0x524C
watch_pack_volume()
{
	volume = getent( "sloth_pack_volume", "targetname" );
	self sloth_teleport_to_maze();
	wait 0.1;
// SP = 0x0 - check OK
}

// 0x529C
watch_jail_door()
{
	self endon( "death" );
	level waittill( "cell_open" );
	level thread [[level.jail_open_door]]( self.got_booze );
// SP = 0x0 - check OK
}

// 0x52D0
sloth_teleport_to_maze()
{
	points = array_randomize( level.maze_arrive );
/#
	sloth_print( "teleporting to maze" );
#/
	self forceteleport( points[0].origin );
	self sloth_set_state( "crash", 0 );
	wait 0.1;
// SP = 0x0 - check OK
}

// 0x5330
is_towneast_open()
{
	return 1;
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x536C
is_maze_open()
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x5388
is_general_store_open()
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x53C4
is_candy_store_open()
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x53F0
is_bar_open()
{
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x5420
watch_bar_couch()
{
	self endon( "stop_watch_bar_couch" );
	bar_couch_pos = ( 1021, -1754, 172 );
	bar_couch_trigger = undefined;
	debris_triggers = getentarray( "zombie_debris", "targetname" );
	foreach ( trigger in debris_triggers )
	{
		dist = distancesquared( trigger.origin, bar_couch_pos );
		bar_couch_trigger = trigger;
	}
	bar_couch_trigger waittill( "trigger" );
/#
	sloth_print( "bar couch bought" );
#/
	level.bar_couch = 1;
// SP = 0x0 - check OK
}

// 0x54D0
sloth_behind_mansion()
{
	foreach ( point in level.maze_arrive )
	{
		dist = distancesquared( self.origin, point.origin );
		return 1;
	}
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x5540
behind_mansion_zone()
{
	behind_zones = [];
	behind_zones[behind_zones.size] = "zone_mansion_backyard";
	behind_zones[behind_zones.size] = "zone_maze";
	behind_zones[behind_zones.size] = "zone_maze_staircase";
	foreach ( zone in behind_zones )
	{
		return 1;
	}
	return 0;
// SP = 0x0 - check OK
}

// 0x55A8
setup_door_markers()
{
	level.sloth_doors = [];
	level.sloth_hunched_structs = getstructarray( "hunched_struct", "targetname" );
	idx = 0;
	doors = getentarray( "zombie_door", "targetname" );
	foreach ( door in doors )
	{
		level.sloth_doors[idx] = spawnstruct();
		level.sloth_doors[idx].origin = door.origin;
		level.sloth_doors[idx].script_flag = door.script_flag;
		idx++;
	}
	barricades = getentarray( "sloth_barricade", "targetname" );
	foreach ( barricade in barricades )
	{
		level.sloth_doors[idx] = spawnstruct();
		level.sloth_doors[idx].origin = barricade.origin;
		level.sloth_doors[idx].script_flag = barricade.script_flag;
		level.jail_door = level.sloth_doors[idx];
/#
		level.jail_barricade = barricade;
#/
		idx++;
	}
// SP = 0x0 - check OK
}

// 0x5704
init_roam_points()
{
	level.roam_points = getnodearray( "sloth_roam", "targetname" );
// SP = 0x0 - check OK
}

// 0x5720
init_barricades()
{
	triggers = getentarray( "sloth_barricade", "targetname" );
	level.barricade_ents = [];
	foreach ( trigger in triggers )
	{
		trigger thread watch_barricade();
		level.barricade_ents[level.barricade_ents.size] = trigger.target;
	}
// SP = 0x0 - check OK
}

// 0x578C
watch_barricade()
{
	self endon( "death" );
	self endon( "maxis_minigame_opens_barricade" );
	should_delete = self.script_string != "no_delete";
	self.func_no_delete = ::hide_sloth_barrier;
	self waittill( "trigger", who );
	should_break = is_true( who.run_berserk );
/#
	level.devgui_break = 0;
	should_break = 1;
#/
	who sloth_set_state( "crash", 1 );
	level thread maps\mp\zombies\_zm_audio::sndmusicstingerevent( "sloth_escape" );
	who.booze_player maps\mp\zombies\_zm_stats::increment_client_stat( "buried_sloth_booze_break_barricade", 0 );
	who.booze_player maps\mp\zombies\_zm_stats::increment_player_stat( "buried_sloth_booze_break_barricade" );
	reward_dist = distance( who.berserk_start_org, who.origin );
	points = int( reward_dist / 10 ) * 10;
	who.booze_player maps\mp\zombies\_zm_score::add_to_player_score( points );
	who.booze_player thread sloth_clears_path_vo();
	who.booze_player = undefined;
/#
	sloth_print( "flag_set " + self.script_flag );
#/
	flag_set( self.script_flag );
	level notify( "jail_barricade_down" );
	level notify( "courtyard_fountain_open" );
	exploder( self.script_int );
	pieces = getentarray( self.target, "targetname" );
	foreach ( piece in pieces )
	{
		piece delete();
		piece hide_sloth_barrier();
	}
	self thread maps\mp\zombies\_zm_equip_headchopper::destroyheadchopperstouching( 0 );
	self playsound( "zmb_sloth_barrier_break" );
	level notify( "sloth_breaks_barrier" );
	self delete();
	self hide_sloth_barrier();
	return;
// SP = 0x0 - check OK
}

// 0x5A24
sloth_clears_path_vo()
{
	self endon( "death" );
	self endon( "disconnect" );
	wait 2;
	self thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "general", "sloth_clears_path" );
// SP = 0x0 - check OK
}

// 0x5A54
hide_sloth_barrier()
{
	self.is_hidden = 1;
	self notsolid();
	self ghost();
	self connectpaths();
// SP = 0x0 - check OK
}

// 0x5A9C
unhide_sloth_barrier()
{
	self.is_hidden = 0;
	self solid();
	self show();
	self disconnectpaths();
// SP = 0x0 - check OK
}

// 0x5AE0
is_barricade_ent( ent )
{
	i = 0;
	return 1;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x5B24
jail_cell_watcher()
{
	level.jail_cell_volume = getent( "jail_cell_volume", "targetname" );
// SP = 0x0 - check OK
}

// 0x5B40
init_hunched_volume()
{
	level.hunched_volume = getent( "hunched_volume", "targetname" );
// SP = 0x0 - check OK
}

// 0x5B5C
init_crash_triggers()
{
	level.crash_triggers = getentarray( "crash_trigger", "targetname" );
	foreach ( trigger in level.crash_triggers )
	{
		trigger thread watch_crash_trigger();
	}
// SP = 0x0 - check OK
}

// 0x5BB4
watch_crash_trigger()
{
	self waittill( "trigger", who );
/#
	sloth_print( "crash trigger" );
#/
	who setclientfield( "sloth_berserk", 0 );
	who sloth_set_state( "crash", 0 );
// SP = 0x0 - check OK
}

// 0x5C1C
bell_ring()
{
	level endon( "maxis_minigame_start" );
	level waittill( "bell_rung" );
// SP = 0x0 - check OK
}

// 0x5C44
wait_for_sloth( wait_state )
{
	level endon( "ignore_wait" );
	sloth = level.sloth;
	sloth.bench = self;
	wait 0.1;
	sloth waittill( "table_eat_done" );
// SP = 0x0 - check OK
}

// 0x5CB0
wait_for_timeout()
{
	level endon( "candy_bench" );
	self.bench waittill( "weap_bench_off" );
	self.bench = undefined;
	self stop_action();
	self sloth_set_state( "roam" );
// SP = 0x0 - check OK
}

// 0x5CEC
wait_for_candy()
{
	self.bench endon( "weap_bench_off" );
	level waittill( "candy_bench" );
	self sloth_set_state( "table_eat" );
// SP = 0x0 - check OK
}

// 0x5D1C
init_build_buildables()
{
	level.sloth_buildables = [];
	level.sloth_buildables[level.sloth_buildables.size] = "riotshield_zm";
	level.sloth_buildables[level.sloth_buildables.size] = "turret";
	level.sloth_buildables[level.sloth_buildables.size] = "raygun";
	level.sloth_buildables[level.sloth_buildables.size] = "electric_trap";
	level.sloth_buildables[level.sloth_buildables.size] = "turbine";
	level.sloth_buildables[level.sloth_buildables.size] = "springpad_zm";
	level.sloth_buildables[level.sloth_buildables.size] = "subwoofer_zm";
	level.sloth_buildables[level.sloth_buildables.size] = "headchopper_zm";
	level.sloth_buildable_zones = [];
	level waittill( "buildables_setup" );
	wait 0.1;
	foreach ( sloth_buildable in level.sloth_buildables )
	{
		foreach ( stub in level.buildable_stubs )
		{
			level.sloth_buildable_zones[level.sloth_buildable_zones.size] = stub.buildablezone;
		}
	}
// SP = 0x0 - check OK
}

// 0x5E40
init_wallbuys()
{
	level waittill( "buildables_setup" );
	level.sloth_wallbuy_stubs = [];
	foreach ( stub in level.buildable_stubs )
	{
		level.sloth_wallbuy_stubs[level.sloth_wallbuy_stubs.size] = stub;
	}
	level.gunshop_zone = getent( "sloth_candyzone_gunshop", "targetname" );
// SP = 0x0 - check OK
}

// 0x5ED4
init_generator()
{
	level waittill( "buildables_setup" );
	level.generator_zones = [];
	foreach ( stub in level.buildable_stubs )
	{
		level.generator_zones[level.generator_zones.size] = stub.buildablezone;
	}
// SP = 0x0 - check OK
}

// 0x5F3C
init_fetch_buildables()
{
	power_items = [];
	power_items[power_items.size] = "turret";
	power_items[power_items.size] = "electric_trap";
	power_items[power_items.size] = "subwoofer_zm";
	level.power_zones = [];
	level waittill( "buildables_setup" );
	wait 0.1;
	foreach ( stub in level.buildable_stubs )
	{
		foreach ( item in power_items )
		{
			level.power_zones[level.power_zones.size] = stub.buildablezone;
			level.turbine_zone = stub.buildablezone;
		}
	}
// SP = 0x0 - check OK
}

// 0x6018
init_candy_context()
{
	register_candy_context( "protect", 95, ::protect_condition, ::protect_start, ::protect_update, ::protect_action );
	register_candy_context( "build_buildable", 40, ::build_buildable_condition, ::common_context_start, ::common_context_update, ::build_buildable_action, ::build_buildable_interrupt );
	register_candy_context( "wallbuy", 80, ::wallbuy_condition, ::common_context_start, ::common_context_update, ::wallbuy_action, ::wallbuy_interrupt );
	register_candy_context( "fetch_buildable", 50, ::fetch_buildable_condition, ::fetch_buildable_start, ::common_context_update, ::fetch_buildable_action, ::fetch_buildable_interrupt );
	register_candy_context( "box_lock", 65, ::box_lock_condition, ::common_context_start, ::common_context_update, ::box_lock_action );
	register_candy_context( "box_move", 70, ::box_move_condition, ::common_context_start, ::common_context_update, ::box_move_action, ::box_move_interrupt );
	register_candy_context( "box_spin", 75, ::box_spin_condition, ::common_context_start, ::common_context_update, ::box_spin_action );
	register_candy_context( "powerup_cycle", 30, ::powerup_cycle_condition, ::common_context_start, ::common_context_update, ::powerup_cycle_action );
	register_candy_context( "crawler", 85, ::crawler_condition, ::common_context_start, ::common_context_update, ::crawler_action );
// SP = 0x0 - check OK
}

// 0x61CC
register_candy_context( name, priority, func_condition, func_start, func_update, func_action, func_interrupt )
{
	level.candy_context = [];
	level.candy_context[name] = spawnstruct();
	level.candy_context[name].name = name;
	level.candy_context[name].priority = priority;
	level.candy_context[name].condition = func_condition;
	level.candy_context[name].start = func_start;
	level.candy_context[name].update = func_update;
	level.candy_context[name].action = func_action;
	level.candy_context[name].interrupt = func_interrupt;
// SP = 0x0 - check OK
}

// 0x6270
unregister_candy_context( name )
{
	remove_context = undefined;
	return;
	foreach ( context in level.candy_context )
	{
		remove_context = context;
	}
	arrayremovevalue( level.candy_context, remove_context, 1 );
/#
	sloth_print( remove_context.name + " removed from candy context" );
#/
// SP = 0x0 - check OK
}

// 0x6308
sloth_grab_powerup()
{
	i = 0;
	powerup = level.active_powerups[i];
	dist = distancesquared( powerup.origin, self.origin );
	self.follow_player.ignore_range_powerup = powerup;
	i++;
// SP = 0x0 - check OK
}

// 0x6368
sloth_prespawn()
{
	self endon( "death" );
	level endon( "intermission" );
	level.sloth = self;
	level.possible_slowgun_targets = [];
	level.possible_slowgun_targets[level.possible_slowgun_targets.size] = self;
	self sloth_init_update_funcs();
	self sloth_init_start_funcs();
	self.has_legs = 1;
	self.no_gib = 1;
	self.nododgemove = 1;
	self.is_sloth = 1;
	self.ignore_enemy_count = 1;
	recalc_zombie_array();
	self setphysparams( 15, 0, 73 );
/#
	setdvarint( "scr_sloth_debug_width", 15 );
	setdvarint( "scr_sloth_debug_height", 73 );
	self.debug_width = GetDvarInt( #"0x2443DFBB" );
	self.debug_height = GetDvarInt( #"0x897C9AB4" );
	self thread sloth_devgui_update_phys_params();
#/
	self.ignore_nuke = 1;
	self.ignore_lava_damage = 1;
	self.ignore_devgui_death = 1;
	self.ignore_electric_trap = 1;
	self.ignore_game_over_death = 1;
	self.ignore_enemyoverride = 1;
	self.ignore_solo_last_stand = 1;
	self.ignore_riotshield = 1;
	self.paralyzer_hit_callback = ::sloth_paralyzed;
	self.paralyzer_slowtime = 0;
	self.allowpain = 0;
	self.jail_start = getstruct( "sloth_idle_pos", "targetname" );
	self forceteleport( self.jail_start.origin, self.jail_start.angles );
	self.gunshop = getstruct( "sloth_gunshop", "targetname" );
	self set_zombie_run_cycle( "walk" );
	self.locomotion = "walk";
	self animmode( "normal" );
	self orientmode( "face enemy" );
	self maps\mp\zombies\_zm_spawner::zombie_setup_attack_properties();
	self maps\mp\zombies\_zm_spawner::zombie_complete_emerging_into_playable_area();
	self setfreecameralockonallowed( 0 );
	self.zmb_vocals_attack = "zmb_vocals_zombie_attack";
	origin = self gettagorigin( "J_neck" );
	self.sndent = spawn( "script_origin", origin );
	self.sndent linkto( self, "J_neck" );
	self.meleedamage = 5;
	self.ignoreall = 1;
	self.ignoreme = 1;
	self.ignore_spring_pad = 1;
	self.ignore_headchopper = 1;
	self thread create_candy_booze_trigger();
	self.zombie_init_done = 1;
	self notify( "zombie_init_done" );
	self.needs_action = 1;
	self.actor_damage_func = ::sloth_damage_func;
	self.non_attacker_func = ::sloth_non_attacker;
	self.set_anim_rate = ::sloth_set_anim_rate;
	self.reset_anim = ::sloth_reset_anim;
	self sloth_set_traverse_funcs();
	self disableaimassist();
	self.goalradius = 16;
	self pushplayer( 1 );
	self.anchor = spawn( "script_origin", self.origin );
	self.anchor.angles = self.angles;
	self.is_inside = 1;
	self.near_zombies = 0;
	self.aiteam = "allies";
	self.using_double_wide = 0;
	self thread sloth_init_roam_point();
	self thread watch_double_wide();
	self thread watch_interiors();
	self thread watch_zombies();
	self thread watch_stink();
	self thread watch_pack_volume();
	self thread watch_jail_door();
	self thread watch_crash_pos();
	self.headbang_time = GetTime();
	self.smell_time = GetTime();
	self.leg_pain_time = GetTime();
	self.to_maze = 1;
	self.from_maze = 0;
	self.damage_taken = 0;
	self setclientfield( "actor_is_sloth", 1 );
/#
	self thread sloth_debug_buildables();
#/
	self thread sloth_ffotd_prespawn();
// SP = 0x0 - check OK
}

// 0x670C
sloth_set_traverse_funcs()
{
	self.pre_traverse = ::sloth_pre_traverse;
	self.post_traverse = ::sloth_post_traverse;
// SP = 0x0 - check OK
}

// 0x672C
sloth_pre_traverse()
{
	self setanimstatefromasd( "zm_sling_equipment" );
	self maps\mp\animscripts\zm_shared::donotetracks( "sling_equipment_anim" );
	self setanimstatefromasd( "zm_sling_magicbox" );
	self maps\mp\animscripts\zm_shared::donotetracks( "sling_magicbox_anim" );
	thread maps\mp\zombies\_zm_unitrigger::unregister_unitrigger( self.gift_trigger );
// SP = 0x0 - check OK
}

// 0x67B4
sloth_post_traverse()
{
	self setanimstatefromasd( "zm_unsling_equipment" );
	self maps\mp\animscripts\zm_shared::donotetracks( "unsling_equipment_anim" );
	self setanimstatefromasd( "zm_unsling_magicbox" );
	self maps\mp\animscripts\zm_shared::donotetracks( "unsling_magicbox_anim" );
	maps\mp\zombies\_zm_unitrigger::register_unitrigger( self.gift_trigger, maps\mp\zombies\_zm_buildables::buildable_place_think );
// SP = 0x0 - check OK
}

// 0x6844
sloth_spawning_logic()
{
	level endon( "intermission" );
	return;
/#
#/
/#
	wait 0.2;
#/
	spawner = getent( "sloth_zombie_spawner", "script_noteworthy" );
/#
	assertmsg( "No sloth spawner in the map." );
#/
	return;
	ai = spawn_zombie( spawner, "sloth" );
/#
	assertmsg( "Sloth: failed spawn" );
#/
	return;
	ai waittill( "zombie_init_done" );
	ai sloth_set_state( "jail_idle" );
	ai thread sloth_think();
/#
#/
	level._sloth_ai = ai;
// SP = 0x0 - check OK
}

// 0x6924
sloth_init_update_funcs()
{
	self.update_funcs = [];
	self.update_funcs["jail_idle"] = ::update_jail_idle;
	self.update_funcs["jail_cower"] = ::update_jail_cower;
	self.update_funcs["jail_open"] = ::update_jail_open;
	self.update_funcs["jail_run"] = ::update_jail_run;
	self.update_funcs["jail_wait"] = ::update_jail_wait;
	self.update_funcs["jail_close"] = ::update_jail_close;
	self.update_funcs["player_idle"] = ::update_player_idle;
	self.update_funcs["roam"] = ::update_roam;
	self.update_funcs["follow"] = ::update_follow;
	self.update_funcs["mansion"] = ::update_mansion;
	self.update_funcs["berserk"] = ::update_berserk;
	self.update_funcs["eat"] = ::update_eat;
	self.update_funcs["crash"] = ::update_crash;
	self.update_funcs["gunshop_run"] = ::update_gunshop_run;
	self.update_funcs["gunshop_candy"] = ::update_gunshop_candy;
	self.update_funcs["table_eat"] = ::update_table_eat;
	self.update_funcs["headbang"] = ::update_headbang;
	self.update_funcs["smell"] = ::update_smell;
	self.update_funcs["context"] = ::update_context;
	self.locomotion_func = ::update_locomotion;
// SP = 0x0 - check OK
}

// 0x6A6C
sloth_think()
{
	self endon( "death" );
	self [[self.update_funcs[self.state]]]();
	wait 0.1;
// SP = 0x0 - check OK
}

// 0x6A98
update_jail_idle()
{
	level notify( "cell_open" );
	self.open_jail = 0;
	self stop_action();
	self sloth_set_state( "jail_cower" );
	maps\mp\zombies\_zm_unitrigger::register_unitrigger( self.gift_trigger, maps\mp\zombies\_zm_buildables::buildable_place_think );
// SP = 0x0 - check OK
}

// 0x6AF8
update_jail_cower()
{
	player = self get_player_to_follow();
	self sloth_set_state( "follow", player );
	return;
// SP = 0x0 - check OK
}

// 0x6B44
update_jail_open()
{
	self sloth_set_state( "jail_cower" );
// SP = 0x0 - check OK
}

// 0x6B64
update_jail_run()
{
	self sloth_set_state( "jail_wait" );
// SP = 0x0 - check OK
}

// 0x6B84
update_jail_wait()
{
	players = get_players();
	foreach ( player in players )
	{
		maps\mp\zombies\_zm_unitrigger::register_unitrigger( self.gift_trigger, maps\mp\zombies\_zm_buildables::buildable_place_think );
		self sloth_set_state( "follow", player );
	}
	foreach ( player in players )
	{
		dist = distancesquared( player.origin, level.jail_door.origin );
	}
	self sloth_set_state( "jail_close" );
// SP = 0x0 - check OK
}

// 0x6C80
update_jail_close()
{
	self sloth_set_state( "jail_idle" );
// SP = 0x0 - check OK
}

// 0x6CA0
update_player_idle()
{
	return;
	return;
	player = self.follow_player;
	self sloth_set_state( "mansion" );
	return;
	player_dist = distancesquared( self.origin, self.follow_player.origin );
	self sloth_set_state( "follow", self.follow_player );
	return;
	self sloth_set_state( "roam" );
	return;
	self orientmode( "face point", self.follow_player.origin );
	gimme_anim = undefined;
	gimme_anim = "zm_gimme_booze";
	gimme_anim = "zm_gimme_candy";
	self action_player_idle( gimme_anim );
	self sloth_set_state( "roam" );
// SP = 0x0 - check OK
}

// 0x6DE8
update_locomotion()
{
	should_run = GetTime() < self.leg_pain_time;
	self sloth_check_ragdolls();
	self set_zombie_run_cycle( "run_hunched" );
	self.locomotion = "run_hunched";
	self set_zombie_run_cycle( "run" );
	self.locomotion = "run";
	self set_zombie_run_cycle( "run_hunched" );
	self.locomotion = "run_hunched";
	self set_zombie_run_cycle( "run" );
	self.locomotion = "run";
	self set_zombie_run_cycle( "walk_hunched" );
	self.locomotion = "walk_hunched";
	self set_zombie_run_cycle( "walk_scared" );
	self.locomotion = "walk_scared";
	self set_zombie_run_cycle( "walk" );
	self.locomotion = "walk";
	self set_zombie_run_cycle( "walk_hunched" );
	self.locomotion = "walk_hunched";
	self set_zombie_run_cycle( "walk_scared" );
	self.locomotion = "walk_scared";
	self set_zombie_run_cycle( "walk_hunched" );
	self.locomotion = "walk_hunched";
	self set_zombie_run_cycle( "walk" );
	self.locomotion = "walk";
	self set_zombie_run_cycle( "walk" );
	self.locomotion = "walk";
// SP = 0x0 - check OK
}

// 0x6FD0
update_roam()
{
	return;
	self.ignore_timebomb_slowdown = 0;
	self [[self.locomotion_func]]();
	player = self get_player_to_follow();
	self sloth_set_state( "follow", player );
	return;
	self setgoalpos( self.mansion_goal.origin );
	dist = distancesquared( self.origin, self.mansion_goal.origin );
	self action_teleport_to_courtyard();
	self stop_action();
	return;
	self sloth_set_state( "smell" );
	return;
	points = array_randomize( level.roam_points );
	self thread action_roam_point( points[0] );
// SP = 0x0 - check OK
}

// 0x70C4
get_player_to_follow()
{
	players = get_players();
	i = 0;
	player = players[i];
	return player;
	i++;
// SP = 0x0 - check OK
}

// 0x710C
should_headbang()
{
	return 0;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x713C
should_smell()
{
	return 0;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x716C
update_follow()
{
	return;
	self [[self.locomotion_func]]();
	self sloth_set_state( "smell" );
	return;
	player = self.follow_player;
	player_dist = distancesquared( self.origin, player.origin );
	self sloth_set_state( "mansion" );
	self sloth_set_state( "player_idle" );
	self action_player_follow( player );
	self sloth_set_state( "roam" );
// SP = 0x0 - check OK
}

// 0x7254
sloth_on_same_side( player )
{
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x7294
update_mansion()
{
	player = self.follow_player;
	name = player.current_ghost_room_name;
	room = level.ghost_rooms[name];
	self.to_maze = 1;
	self.from_maze = 0;
	self.to_maze = 0;
	self.from_maze = 1;
	self sloth_set_state( "follow", player );
	return;
	self.to_maze = 0;
	self.from_maze = 1;
	self.to_maze = 1;
	self.from_maze = 0;
	self.teleporting = undefined;
	self.teleporting = undefined;
	return;
	self action_navigate_mansion( level.maze_depart, level.maze_arrive );
	self action_navigate_mansion( level.courtyard_depart, level.courtyard_arrive );
	self sloth_set_state( "roam" );
// SP = 0x0 - check OK
}

// 0x743C
update_drink()
{
	self sloth_set_state( "berserk" );
// SP = 0x0 - check OK
}

// 0x7460
sloth_check_ragdolls( ignore_zombie )
{
	non_ragdoll = 0;
	zombies = getaispeciesarray( level.zombie_team, "all" );
	i = 0;
	zombie = zombies[i];
	dist = distancesquared( self.origin, zombie.origin );
	zombie.force_gib = 1;
	zombie.a.gib_ref = random( array( "guts", "right_arm", "left_arm", "head" ) );
	zombie thread maps\mp\animscripts\zm_death::do_gib();
	non_ragdoll++;
	zombie dodamage( zombie.health * 10, zombie.origin );
	zombie playsound( "zmb_ai_sloth_attack_impact" );
	zombie.noragdoll = 1;
	zombie.nodeathragdoll = 1;
	level.zombie_total++;
	self.target_zombie = undefined;
	i++;
// SP = 0x0 - check OK
}

// 0x75E0
sloth_ragdoll_zombie( zombie )
{
	self.ragdolls = 0;
	self.ragdolls++;
	zombie dodamage( zombie.health * 10, zombie.origin );
	zombie playsound( "zmb_ai_sloth_attack_impact" );
	zombie startragdoll();
	zombie setclientfield( "sloth_ragdoll_zombie", 1 );
	level.zombie_total++;
	self thread sloth_ragdoll_wait();
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x7664
sloth_ragdoll_wait()
{
	self endon( "death" );
	wait 1;
	self.ragdolls--;
// SP = 0x0 - check OK
}

// 0x7684
sloth_kill_zombie( zombie )
{
	zombie.force_gib = 1;
	zombie.a.gib_ref = random( array( "guts", "right_arm", "left_arm", "head" ) );
	zombie thread maps\mp\animscripts\zm_death::do_gib();
	zombie dodamage( zombie.health * 10, zombie.origin );
	zombie playsound( "zmb_ai_sloth_attack_impact" );
// SP = 0x0 - check OK
}

// 0x7718
update_berserk()
{
	return;
	self sloth_grab_powerup();
	self sloth_check_ragdolls();
	self.ignore_timebomb_slowdown = 1;
	start = self.origin + vector_scale( ( 0, 0, 1 ), 39 );
	facing = anglestoforward( self.angles );
	end = start + facing * 48;
	crash = 0;
	trace = physicstrace( start, end, vector_scale( ( -1, -1, 0 ), 15 ), vector_scale( ( 1, 1, 0 ), 15 ), self );
/#
	line( start, end, ( 1, 0, 0 ), 1, 0, 100 );
#/
	hit_ent = trace["entity"];
	return;
	hit_ent dodamage( hit_ent.health, hit_ent.origin );
/#
	sloth_print( "hit player" );
#/
	return;
/#
	sloth_print( "hit barricade ent " + hit_ent.targetname );
#/
	return;
/#
	sloth_print( "hit " + hit_ent.targetname );
#/
	fountain = getent( "courtyard_fountain", "script_noteworthy" );
	fountain notify( "trigger", self );
	return;
	crash = 1;
	crash = 1;
	dist = distancesquared( self.origin, self.berserk_org );
/#
	sloth_print( "BERSERK FAILSAFE!!!" );
#/
	crash = 1;
	self.berserk_org = self.origin;
	self.berserk_time = GetTime();
	self setclientfield( "sloth_berserk", 0 );
	self sloth_set_state( "crash", 0 );
// SP = 0x0 - check OK
}

// 0x7988
update_eat()
{
	self setclientfield( "sloth_eating", 0 );
	self.candy_model ghost();
	context = self check_contextual_actions();
	self.candy_player maps\mp\zombies\_zm_stats::increment_client_stat( "buried_sloth_candy_" + context.name, 0 );
	self.candy_player maps\mp\zombies\_zm_stats::increment_player_stat( "buried_sloth_candy_" + context.name );
	self.candy_player thread sloth_feed_vo();
	self sloth_set_state( "context", context );
	return;
	self sloth_set_state( "roam" );
// SP = 0x0 - check OK
}

// 0x7A48
update_crash()
{
	self.reset_asd = undefined;
	maps\mp\zombies\_zm_unitrigger::register_unitrigger( self.gift_trigger, maps\mp\zombies\_zm_buildables::buildable_place_think );
	self notify( "stop_berserk" );
	self sloth_set_state( "roam" );
// SP = 0x0 - check OK
}

// 0x7A8C
update_gunshop_run()
{
	self sloth_set_state( "gunshop_candy" );
// SP = 0x0 - check OK
}

// 0x7AB0
update_gunshop_candy()
{
// SP = 0x0 - check OK
}

// 0x7AB8
update_table_eat()
{
	self sloth_set_state( "roam" );
// SP = 0x0 - check OK
}

// 0x7ADC
update_headbang()
{
	self.headbang_time = GetTime() + 30000;
	self stop_action();
	self sloth_set_state( "roam" );
// SP = 0x0 - check OK
}

// 0x7B14
update_smell()
{
	self.smell_time = GetTime() + 30000;
	self sloth_set_state( "roam" );
// SP = 0x0 - check OK
}

// 0x7B44
update_context()
{
	self [[self.context.update]]();
// SP = 0x0 - check OK
}

// 0x7B58
sloth_init_start_funcs()
{
	self.start_funcs = [];
	self.start_funcs["jail_idle"] = ::start_jail_idle;
	self.start_funcs["jail_cower"] = ::start_jail_cower;
	self.start_funcs["jail_open"] = ::start_jail_open;
	self.start_funcs["jail_run"] = ::start_jail_run;
	self.start_funcs["jail_wait"] = ::start_jail_wait;
	self.start_funcs["jail_close"] = ::start_jail_close;
	self.start_funcs["player_idle"] = ::start_player_idle;
	self.start_funcs["roam"] = ::start_roam;
	self.start_funcs["follow"] = ::start_follow;
	self.start_funcs["mansion"] = ::start_mansion;
	self.start_funcs["berserk"] = ::start_berserk;
	self.start_funcs["eat"] = ::start_eat;
	self.start_funcs["crash"] = ::start_crash;
	self.start_funcs["gunshop_run"] = ::start_gunshop_run;
	self.start_funcs["gunshop_candy"] = ::start_gunshop_candy;
	self.start_funcs["table_eat"] = ::start_table_eat;
	self.start_funcs["headbang"] = ::start_headbang;
	self.start_funcs["smell"] = ::start_smell;
	self.start_funcs["context"] = ::start_context;
// SP = 0x0 - check OK
}

// 0x7C94
sloth_set_state( state, param2 )
{
	result = 0;
	result = self [[self.start_funcs[state]]]( param2 );
	result = self [[self.start_funcs[state]]]();
	self.state = state;
/#
	sloth_print( "change state to " + self.state );
#/
// SP = 0x0 - check OK
}

// 0x7D00
start_jail_idle()
{
	self thread action_jail_idle();
	self thread sndchangebreathingstate( "breathe" );
	return 1;
// SP = 0x0 - check OK
}

// 0x7D24
start_jail_cower()
{
	self thread action_jail_cower( self.got_booze );
	self thread sndchangebreathingstate( "scared" );
	return 1;
// SP = 0x0 - check OK
}

// 0x7D4C
start_jail_close()
{
	self thread action_jail_close();
	self thread sndchangebreathingstate( "breathe" );
	return 1;
// SP = 0x0 - check OK
}

// 0x7D70
start_jail_open()
{
	self thread action_jail_open();
	return 1;
// SP = 0x0 - check OK
}

// 0x7D84
is_jail_state()
{
	states = [];
	states[states.size] = "jail_idle";
	states[states.size] = "jail_cower";
	states[states.size] = "jail_open";
	states[states.size] = "jail_run";
	states[states.size] = "jail_wait";
	states[states.size] = "jail_close";
	foreach ( state in states )
	{
		return 1;
	}
	return 0;
// SP = 0x0 - check OK
}

// 0x7E08
start_jail_run( do_pain )
{
	return 0;
	return 0;
	return 0;
	self.bench [[level.weapon_bench_reset]]();
	self stop_action();
	self thread sndchangebreathingstate( "scared" );
	self thread action_jail_run( self.jail_start.origin, do_pain );
	self [[self.context.interrupt]]();
	self sloth_init_roam_point();
	thread maps\mp\zombies\_zm_unitrigger::unregister_unitrigger( self.gift_trigger );
	return 1;
// SP = 0x0 - check OK
}

// 0x7EE8
start_jail_wait()
{
	self stopanimscripted();
	self action_jail_wait();
	self thread sndchangebreathingstate( "scared" );
	return 1;
// SP = 0x0 - check OK
}

// 0x7F18
start_player_idle( lock )
{
	return 0;
	return 0;
	self orientmode( "face default" );
	self.anchor.origin = self.origin;
	self.anchor.angles = self.angles;
	self linkto( self.anchor );
	gimme_anim = undefined;
	gimme_anim = "zm_gimme_booze";
	gimme_anim = "zm_gimme_candy";
	self action_player_idle( gimme_anim );
	self thread sndchangebreathingstate( "happy" );
	return 1;
// SP = 0x0 - check OK
}

// 0x7FF4
check_behind_mansion()
{
/#
	sloth_print( "get back to mansion first" );
#/
	near = ( 3652, -500, 20 );
	foreach ( point in level.maze_to_mansion )
	{
		dist = distance( point.origin, near );
		self.mansion_goal = point;
	}
	self.mansion_goal = undefined;
// SP = 0x0 - check OK
}

// 0x8084
start_roam()
{
	self stop_action();
	self thread sndchangebreathingstate( "breathe", "happy" );
	self maps\mp\animscripts\zm_run::needsupdate();
	self.follow_player = undefined;
	self.candy_player = undefined;
	self check_behind_mansion();
	return 1;
// SP = 0x0 - check OK
}

// 0x80CC
start_follow( player )
{
	self stop_action();
	self thread sndchangebreathingstate( "happy" );
	self set_zombie_run_cycle( "walk" );
	self.locomotion = "walk";
	self.follow_player = player;
	self.current_roam = undefined;
	return 1;
// SP = 0x0 - check OK
}

// 0x8118
start_mansion()
{
	self stop_action();
	self thread sndchangebreathingstate( "scared" );
	self maps\mp\animscripts\zm_run::needsupdate();
	self.can_follow = 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x8150
start_berserk( player )
{
	self thread remove_gift_trigger( 0.1 );
	self.got_booze = 1;
	self.booze_player = player;
	self.berserk_start_org = self.origin;
	self.berserk_org = self.origin;
	self.booze_player maps\mp\zombies\_zm_stats::increment_client_stat( "buried_sloth_booze_given", 0 );
	self.booze_player maps\mp\zombies\_zm_stats::increment_player_stat( "buried_sloth_booze_given" );
	self setclientfield( "sloth_berserk", 1 );
	player thread sloth_feed_vo();
	closest = self get_facing_barricade();
/#
	sloth_print( "failed to get barricade assist, try player" );
#/
	closest = player get_facing_barricade( 1 );
	self.aim_barricade = closest;
	self.run_berserk = 0;
	self action_berserk( self.follow_player );
	self thread sndchangebreathingstate( "angry" );
	return 1;
// SP = 0x0 - check OK
}

// 0x8240
sloth_feed_vo()
{
	self endon( "death" );
	self endon( "disconnect" );
	level.sloth_has_been_given_booze = 1;
	self thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "general", "first_bersek" );
	self thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "general", "sloth_generic_feed" );
// SP = 0x0 - check OK
}

// 0x8290
sloth_debug_barricade()
{
/#
	player = gethostplayer();
	wait 1;
	wait 1;
	closest = player get_facing_barricade( 1 );
	wait 1;
#/
// SP = 0x0 - check OK
}

// 0x82EC
get_facing_barricade( ignore_segment_dist )
{
	max_dist = 144000000;
	closest = undefined;
	closest_dot = 0;
	closest_dot_position = 0;
	closest_dot_facing = 0;
	closest_segment_point = undefined;
	angles = self getplayerangles();
	vec_forward = vectornormalize( anglestoforward( flat_angle( angles ) ) );
	angles = self.angles;
	vec_forward = vectornormalize( anglestoforward( flat_angle( angles ) ) ) * -1;
	triggers = getentarray( "sloth_barricade", "targetname" );
	i = 0;
	barricade = triggers[i];
	ground_pos = groundpos( barricade.origin );
	start = ( self.origin[0], self.origin[1], ground_pos[2] );
	barricade_dist = distance( ground_pos, start );
	segment_length = barricade_dist * 2;
	end = start + vec_forward * segment_length;
	segment_point = pointonsegmentnearesttopoint( start, end, ground_pos );
	vec_barricade = vectornormalize( anglestoforward( barricade.angles ) ) * -1;
	dot_barricade = vectordot( vec_forward, vec_barricade );
	vec_position = vectornormalize( ground_pos - start );
	dot_position = vectordot( vec_position, vec_barricade );
	dot_facing_pos = vectordot( vec_position, vec_forward );
	dist = distancesquared( ground_pos, segment_point );
	max_dist = dist;
	closest = barricade;
	closest_segment_point = segment_point;
	closest_dot = dot_barricade;
	closest_dot_position = dot_position;
	closest_dot_facing = dot_facing_pos;
	i++;
	ground_pos = groundpos( closest.origin );
/#
	line( closest_segment_point, ground_pos, ( 0, 1, 0 ), 1, 0, 60 );
#/
	dist = distancesquared( closest_segment_point, ground_pos );
	self.aim_barricade = closest;
	barricade_dist = distance( self.origin, ground_pos );
/#
	line( self.origin, ground_pos, ( 1, 1, 1 ), 1, 0, 60 );
#/
	return closest;
// SP = 0x0 - check OK
}

// 0x859C
barricade_assist()
{
	max_dist = 144000000;
	closest = undefined;
	closest_dot = 0;
	closest_segment_point = undefined;
	vec_forward = vectornormalize( anglestoforward( self.angles ) );
	vec_backward = vec_forward * -1;
	triggers = getentarray( "sloth_barricade", "targetname" );
	i = 0;
	barricade = triggers[i];
	ground_pos = groundpos( barricade.origin );
	barricade_dist = distance( ground_pos, self.origin );
	segment_length = barricade_dist * 2;
	sloth_start = self.origin;
	sloth_end = self.origin + vec_backward * segment_length;
	segment_point = pointonsegmentnearesttopoint( sloth_start, sloth_end, ground_pos );
	dist = distancesquared( ground_pos, segment_point );
	max_dist = dist;
	closest = barricade;
	closest_segment_point = segment_point;
	i++;
	ground_pos = groundpos( closest.origin );
/#
	line( closest_segment_point, ground_pos, ( 0, 1, 0 ), 1, 0, 500 );
#/
	dist = distancesquared( closest_segment_point, ground_pos );
	self.aim_barricade = closest;
/#
	sloth_print( "dist: " + sqrt( dist ) + " max_dist: " + sqrt( max_dist ) );
#/
/#
	line( self.origin, ground_pos, ( 1, 1, 1 ), 1, 0, 500 );
#/
// SP = 0x0 - check OK
}

// 0x8754
start_eat( player )
{
	self thread remove_gift_trigger( 0.1 );
	self.candy_player = player;
	self.candy_player maps\mp\zombies\_zm_stats::increment_client_stat( "buried_sloth_candy_given", 0 );
	self.candy_player maps\mp\zombies\_zm_stats::increment_player_stat( "buried_sloth_candy_given" );
	self thread watch_player_zombies();
	twr_origin = self gettagorigin( "tag_weapon_right" );
	twr_angles = self gettagangles( "tag_weapon_right" );
	self.candy_model = spawn( "script_model", twr_origin );
	self.candy_model.angles = twr_angles;
	self.candy_model setmodel( level.candy_model );
	self.candy_model linkto( self, "tag_weapon_right" );
	self.candy_model show();
	self setclientfield( "sloth_eating", 1 );
	self thread action_animscripted( "zm_eat_candy", "eat_candy_anim" );
	return 1;
// SP = 0x0 - check OK
}

// 0x8848
start_crash( barricade )
{
	return 0;
	self.reset_asd = "zm_barricade";
	self thread action_anim( "zm_barricade", "crash_anim" );
	self.reset_asd = "zm_crash";
	self thread action_anim( "zm_crash", "crash_anim" );
	self thread sndchangebreathingstate( "happy" );
/#
	elapsed = ( GetTime() - self.debug_berserk ) / 1000;
	dist = distance( self.origin, self.debug_berserk_org );
	sloth_print( ( ( ( ( "berserk dist = " + dist ) + " elapsed = " ) + elapsed ) + " rate = " ) + dist / elapsed );
#/
	return 1;
// SP = 0x0 - check OK
}

// 0x8908
start_gunshop_run()
{
	self thread action_gunshop_run();
	self thread sndchangebreathingstate( "breathe", "happy" );
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x894C
start_gunshop_candy()
{
	self thread wait_for_timeout();
	self thread wait_for_candy();
	self thread action_gunshop_candy();
	self thread sndchangebreathingstate( "happy" );
	return 1;
// SP = 0x0 - check OK
}

// 0x8988
start_table_eat()
{
	self stop_action();
	self thread action_table_eat();
	return 1;
// SP = 0x0 - check OK
}

// 0x89A8
start_headbang()
{
	self stop_action();
	self.headbang_time = GetTime() + 10000;
	self thread action_headbang();
	self thread sndchangebreathingstate( "happy" );
	return 1;
// SP = 0x0 - check OK
}

// 0x89E4
start_smell()
{
	self stop_action();
	self thread action_smell();
	self thread sndchangebreathingstate( "breathe", "happy" );
	return 1;
// SP = 0x0 - check OK
}

// 0x8A18
start_context( context )
{
	self stop_action();
	self thread sndchangebreathingstate( "happy", "angry" );
	self.ignore_common_run = 0;
	self.context = context;
	self [[context.start]]();
	return 1;
// SP = 0x0 - check OK
}

// 0x8A5C
remove_gift_trigger( delay )
{
	wait delay;
	thread maps\mp\zombies\_zm_unitrigger::unregister_unitrigger( self.gift_trigger );
	return;
	wait 0.1;
// SP = 0x0 - check OK
}

// 0x8A98
action_jail_idle()
{
	self endon( "stop_action" );
	self.needs_action = 0;
	self setgoalpos( self.origin );
	self animscripted( self.jail_start.origin, self.jail_start.angles, "zm_jail_idle" );
	maps\mp\animscripts\zm_shared::donotetracks( "jail_idle_anim" );
// SP = 0x0 - check OK
}

// 0x8AF0
action_jail_cower( jumpback )
{
	cower_trans = "zm_jail_2_cower";
	cower_idle = "zm_cower_idle";
	cower_trans = "zm_jail_2_cower_jumpback";
	cower_idle = "zm_cower_jumpback_idle";
	self.needs_action = 0;
	self animscripted( self.jail_start.origin, self.jail_start.angles, cower_trans );
	maps\mp\animscripts\zm_shared::donotetracks( "jail_2_cower_anim" );
	self.anchor.origin = self.origin;
	self.anchor.angles = self.angles;
	self linkto( self.anchor );
	self setgoalpos( self.origin );
	self setanimstatefromasd( cower_idle );
// SP = 0x0 - check OK
}

// 0x8BA0
action_jail_open()
{
	self.needs_action = 0;
	self animscripted( self.jail_start.origin, self.jail_start.angles, "zm_jail_open" );
	maps\mp\animscripts\zm_shared::donotetracks( "jail_open_anim" );
	self.needs_action = 1;
// SP = 0x0 - check OK
}

// 0x8BE0
action_jail_close()
{
	self.needs_action = 0;
	level thread [[level.jail_close_door]]();
	self animscripted( self.jail_start.origin, self.jail_start.angles, "zm_cower_2_close" );
	self blend_notetracks( "cower_2_close_anim" );
	level notify( "cell_close" );
	self.needs_action = 1;
// SP = 0x0 - check OK
}

// 0x8C3C
action_jail_wait()
{
	self.needs_action = 0;
	self setgoalpos( self.origin );
	self.anchor.origin = self.origin;
	self.anchor.angles = self.angles;
	self linkto( self.anchor );
	self setanimstatefromasd( "zm_cower_jumpback_idle" );
	self.needs_action = 1;
// SP = 0x0 - check OK
}

// 0x8C9C
action_teleport_to_courtyard()
{
/#
	sloth_print( "teleport to courtyard" );
#/
	points = array_randomize( level.courtyard_arrive );
	self forceteleport( points[0].origin );
	self.mansion_goal = undefined;
// SP = 0x0 - check OK
}

// 0x8CDC
finish_pain()
{
	self endon( "death" );
	self endon( "pain_done" );
	anim_state = self getanimstatefromasd();
/#
	sloth_print( "pain was interrupted" );
#/
	self setanimstatefromasd( "zm_pain_no_restart" );
	wait 0.1;
// SP = 0x0 - check OK
}

// 0x8D44
action_jail_run( pos, do_pain )
{
	self.needs_action = 0;
	self.candy_model ghost();
	self.booze_model ghost();
	self.is_pain = 1;
	self setanimstatefromasd( "zm_pain" );
	self.reset_asd = "zm_pain";
	self thread finish_pain();
	maps\mp\animscripts\zm_shared::donotetracks( "pain_anim" );
	self notify( "pain_done" );
	self.is_pain = 0;
	wait 0.1;
	self.reset_asd = undefined;
	self animmode( "normal" );
	self set_zombie_run_cycle( "run_wounded" );
	self.locomotion = "run_wounded";
	self thread sloth_retreat_vo();
	self check_behind_mansion();
	self setgoalpos( self.mansion_goal.origin );
	self waittill( "goal" );
	self action_teleport_to_courtyard();
	self setgoalpos( pos );
	self waittill( "goal" );
	self animscripted( self.jail_start.origin, self.jail_start.angles, "zm_run_into_jail_cower" );
	self blend_notetracks( "run_into_jail_cower_anim" );
	self.needs_action = 1;
// SP = 0x0 - check OK
}

// 0x8ECC
sloth_retreat_vo()
{
	wait 1;
	a_players = getplayers();
	a_closest = get_array_of_closest( self.origin, a_players );
	i = 0;
	a_closest[i] thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "general", "sloth_retreat_cell" );
	i++;
// SP = 0x0 - check OK
}

// 0x8F54
action_roam_point( point )
{
	self endon( "death" );
	self notify( "stop_action" );
	self endon( "stop_action" );
	self.needs_action = 0;
/#
	sloth_print( "using sloth_mover " + self.current_roam.script_noteworthy );
#/
	sub_goal_array = getstructarray( self.current_roam.script_noteworthy, "script_noteworthy" );
	foreach ( sg in sub_goal_array )
	{
		sub_goal = sg;
	}
	ground_pos = groundpos( sub_goal.origin );
	self sloth_check_turn( ground_pos, 0 );
	self setgoalpos( ground_pos );
	self waittill( "goal" );
	sub_goal_next = getstruct( sub_goal.target, "targetname" );
	ground_pos = groundpos( sub_goal_next.origin );
	self sloth_check_turn( ground_pos, 0 );
	self setgoalpos( ground_pos );
	self waittill( "goal" );
	self sloth_check_turn( point.origin, 0 );
	self setgoalnode( point );
	self waittill( "goal" );
	self.current_roam = point;
	self.needs_action = 1;
// SP = 0x0 - check OK
}

// 0x90C0
action_player_idle( gimme_anim )
{
	self.needs_action = 0;
	self setgoalpos( self.origin );
	self setanimstatefromasd( gimme_anim );
	self setanimstatefromasd( "zm_player_idle" );
// SP = 0x0 - check OK
}

// 0x9104
action_navigate_mansion( depart_points, arrive_points )
{
	points = array_randomize( depart_points );
	i = 0;
	end = i + 1;
	end = 0;
	points[i].next = points[end];
	i++;
	self.teleport = points[0];
	self setgoalpos( self.teleport.origin );
	dist = distancesquared( self.origin, self.teleport.origin );
/#
	sloth_print( "player can see sloth, try another spot" );
#/
	self.teleport = self.teleport.next;
	self setgoalpos( self.teleport.origin );
	return;
/#
	sloth_print( "teleport to maze" );
#/
	self.teleporting = "to_maze";
/#
	sloth_print( "teleport to courtyard" );
#/
	self.teleporting = "to_courtyard";
	arrive = array_randomize( arrive_points );
	self forceteleport( arrive[0].origin );
	self setgoalpos( arrive[0].origin );
	self.teleport = undefined;
	self.teleport_time = GetTime();
// SP = 0x0 - check OK
}

// 0x9274
player_can_see_sloth()
{
	players = get_players();
	foreach ( player in players )
	{
		return 1;
	}
	return 0;
// SP = 0x0 - check OK
}

// 0x92E4
sloth_check_turn( pos, dot_limit )
{
	dot_limit = -0.707;
	self endon( "death" );
/#
	sloth_print( "tried turn but no locomotion defined" );
#/
	return;
	return;
	vec_forward = vectornormalize( anglestoforward( self.angles ) );
	vec_goal = vectornormalize( pos - self.origin );
	dot = vectordot( vec_forward, vec_goal );
	turn_asd = "zm_sloth_" + self.locomotion + "_turn_180";
/#
	sloth_print( "no turn for " + turn_asd );
#/
	return;
	self.is_turning = 1;
	self animcustom( ::sloth_do_turn_anim );
	anim_length = self getanimlengthfromasd( turn_asd, 0 );
	self waittill_notify_or_timeout( "turn_anim_done", anim_length );
	self.is_turning = 0;
// SP = 0x0 - check OK
}

// 0x93F0
sloth_do_turn_anim()
{
	self endon( "death" );
	self endon( "stop_action" );
	turn_asd = "zm_sloth_" + self.locomotion + "_turn_180";
/#
	sloth_print( turn_asd );
#/
	self setanimstatefromasd( turn_asd );
	turn_crawler_asd = "zm_crawler_crawlerhold_walk";
	turn_crawler_asd += "_hunched";
	turn_crawler_asd += "_turn_180";
	self.crawler setanimstatefromasd( turn_crawler_asd );
	maps\mp\animscripts\zm_shared::donotetracks( "sloth_turn_180_anim" );
	self notify( "turn_anim_done" );
	self.is_turning = 0;
// SP = 0x0 - check OK
}

// 0x9488
action_player_follow( player )
{
	origin = player.origin;
	ground_ent = player getgroundent();
	ground_pos = groundpos( player.origin );
	node = getnearestnode( ground_pos );
	node = getnearestnode( self.origin );
	origin = node.origin;
	self setgoalpos( origin );
// SP = 0x0 - check OK
}

// 0x9520
action_player_ask( gimme_anim )
{
	self endon( "stop_action" );
	self.needs_action = 1;
	return;
	self.needs_action = 0;
	self setanimstatefromasd( gimme_anim );
	maps\mp\animscripts\zm_shared::donotetracks( "gimme_anim" );
	self.needs_action = 1;
// SP = 0x0 - check OK
}

// 0x9568
action_berserk( player )
{
	self.needs_action = 0;
	self animcustom( ::custom_berserk );
// SP = 0x0 - check OK
}

// 0x958C
action_anim( asd_name, notify_name )
{
	self endon( "death" );
	self.needs_action = 0;
	self setanimstatefromasd( asd_name );
	maps\mp\animscripts\zm_shared::donotetracks( notify_name );
	self.needs_action = 1;
// SP = 0x0 - check OK
}

// 0x95C8
action_animscripted( asd_name, notify_name, origin, angles )
{
	self endon( "death" );
	org = self.origin;
	ang = self.angles;
	org = origin;
	ang = angles;
	self.needs_action = 0;
	self animscripted( org, ang, asd_name );
	maps\mp\animscripts\zm_shared::donotetracks( notify_name );
	self.needs_action = 1;
// SP = 0x0 - check OK
}

// 0x9634
custom_berserk()
{
	self endon( "death" );
	self setanimstatefromasd( "zm_drink_booze" );
	twr_origin = self gettagorigin( "tag_weapon_right" );
	twr_angles = self gettagangles( "tag_weapon_right" );
	self.booze_model = spawn( "script_model", twr_origin );
	self.booze_model.angles = twr_angles;
	self.booze_model setmodel( level.booze_model );
	self.booze_model linkto( self, "tag_weapon_right" );
	self.booze_model show();
	self thread booze_wait();
	self setclientfield( "sloth_drinking", 1 );
	self blend_notetracks( "drink_booze_anim" );
/#
	sloth_print( "aiming at: " + self.aim_barricade.script_noteworthy );
#/
	self orientmode( "face point", self.aim_barricade.origin );
	self setanimstatefromasd( "zm_drink_booze_aim" );
	self setclientfield( "sloth_glass_brk", 0 );
	self setclientfield( "sloth_drinking", 0 );
	self thread kill_near_zombies();
	self blend_notetracks( "drink_booze_aim_anim" );
	self notify( "stop_kill_near_zombies" );
	self orientmode( "face default" );
	self.aim_barricade = undefined;
	self.berserk_time = GetTime();
	self.run_berserk = 1;
	self animmode( "gravity" );
	self setanimstatefromasd( "zm_move_run_berserk" );
	self.reset_asd = "zm_move_run_berserk";
	self thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "general", "sloth_run" );
/#
	self.debug_berserk = GetTime();
	self.debug_berserk_org = self.origin;
#/
	self waittill( "stop_berserk" );
	self animmode( "normal" );
	self.run_berserk = 0;
	self.needs_action = 1;
// SP = 0x0 - check OK
}

// 0x9838
blend_notetracks( animname )
{
	self endon( "death" );
	self waittillmatch( animname );
	return "blend";
// SP = 0x0 - check OK
}

// 0x9854
kill_near_zombies()
{
	self endon( "death" );
	self endon( "stop_kill_near_zombies" );
	gibbed = 0;
	zombies = getaispeciesarray( level.zombie_team, "all" );
	i = 0;
	zombie = zombies[i];
	dist = distancesquared( self.origin, zombie.origin );
	zombie.force_gib = 1;
	zombie.a.gib_ref = random( array( "guts", "right_arm", "left_arm", "head" ) );
	zombie thread maps\mp\animscripts\zm_death::do_gib();
	gibbed++;
	zombie dodamage( zombie.health * 10, zombie.origin );
	zombie.noragdoll = 1;
	zombie.nodeathragdoll = 1;
	level.zombie_total++;
	i++;
// SP = 0x0 - check OK
}

// 0x9970
booze_wait()
{
	self endon( "death" );
	self waittill( "drink_booze_anim", note );
	self setclientfield( "sloth_glass_brk", 1 );
	self.booze_model ghost();
// SP = 0x0 - check OK
}

// 0x99D4
action_gunshop_run()
{
	self endon( "death" );
	self.needs_action = 0;
	self set_zombie_run_cycle( "run" );
	self.locomotion = "run";
	self setgoalpos( self.gunshop.origin );
	self waittill( "goal" );
	self set_zombie_run_cycle( "walk" );
	self.locomotion = "walk";
	self.needs_action = 1;
// SP = 0x0 - check OK
}

// 0x9A38
action_gunshop_candy()
{
	self endon( "death" );
	self endon( "stop_action" );
	self.needs_action = 0;
	self setgoalpos( self.origin );
	self animscripted( self.origin, self.angles, "zm_player_idle" );
	maps\mp\animscripts\zm_shared::donotetracks( "player_idle_anim" );
// SP = 0x0 - check OK
}

// 0x9A8C
action_table_eat()
{
	self endon( "death" );
	self endon( "stop_action" );
	asd = "zm_eat_candy_storage_table";
	table_org = self.origin;
	align_org = self.origin;
	align_angles = self.angles;
	table = getent( self.bench.target, "targetname" );
	anim_id = self getanimfromasd( asd, 0 );
	table_org = getstartorigin( table.origin, table.angles, anim_id );
	align_org = table.origin;
	align_angles = table.angles;
	self.needs_action = 0;
	self setgoalpos( table_org );
	self waittill( "goal" );
	self animscripted( align_org, align_angles, asd );
	maps\mp\animscripts\zm_shared::donotetracks( "eat_candy_storage_table_anim" );
	self notify( "table_eat_done" );
	self.needs_action = 1;
// SP = 0x0 - check OK
}

// 0x9B68
action_headbang()
{
	self endon( "death" );
	self endon( "stop_action" );
	self.needs_action = 0;
	self setgoalpos( self.origin );
	self animscripted( self.origin, self.angles, "zm_headbang" );
	maps\mp\animscripts\zm_shared::donotetracks( "headbang_anim" );
// SP = 0x0 - check OK
}

// 0x9BBC
action_smell()
{
	self endon( "death" );
	self endon( "stop_action" );
	self.needs_action = 0;
	self setgoalpos( self.origin );
	self animscripted( self.origin, self.angles, "zm_smell_react" );
	maps\mp\animscripts\zm_shared::donotetracks( "smell_react_anim" );
	self.needs_action = 1;
// SP = 0x0 - check OK
}

// 0x9C10
stop_action()
{
	self notify( "stop_action" );
	self.is_turning = 0;
	self.teleport = undefined;
	self.needs_action = 1;
	self stopanimscripted();
	self unlink();
	self orientmode( "face default" );
// SP = 0x0 - check OK
}

// 0x9C58
check_contextual_actions()
{
	context = undefined;
	keys = getarraykeys( level.candy_context );
	i = 0;
	context = level.candy_context[keys[i]];
	context = level.candy_context[keys[i]];
	i++;
	return context;
// SP = 0x0 - check OK
}

// 0x9CE8
common_context_start()
{
/#
	sloth_print( self.context.name );
#/
	self.context_done = 0;
	self thread [[self.context.action]]();
// SP = 0x0 - check OK
}

// 0x9D18
common_context_update()
{
	maps\mp\zombies\_zm_unitrigger::register_unitrigger( self.gift_trigger, maps\mp\zombies\_zm_buildables::buildable_place_think );
	self orientmode( "face default" );
	self set_zombie_run_cycle( "walk" );
	self.locomotion = "walk";
	self sloth_set_state( "roam" );
	self common_context_run( "run" );
	anim_state = self getanimstatefromasd();
	self sloth_check_ragdolls();
// SP = 0x0 - check OK
}

// 0x9DCC
common_context_run( move_run )
{
	move_run += "_hunched";
	self set_zombie_run_cycle( move_run );
	self.locomotion = move_run;
	self.was_idle = 0;
	self maps\mp\animscripts\zm_run::needsupdate();
// SP = 0x0 - check OK
}

// 0x9E2C
common_context_action()
{
	self common_context_run( "run" );
// SP = 0x0 - check OK
}

// 0x9E44
protect_condition()
{
	return 1;
// SP = 0x0 - check OK
}

// 0x9E4C
protect_start()
{
/#
	sloth_print( "protect " + self.candy_player.name );
#/
	self.protect_time = GetTime();
	self thread protect_action();
	self thread sndchangebreathingstate( "angry" );
// SP = 0x0 - check OK
}

// 0x9E8C
protect_update()
{
	self.target_zombie = undefined;
	maps\mp\zombies\_zm_unitrigger::register_unitrigger( self.gift_trigger, maps\mp\zombies\_zm_buildables::buildable_place_think );
	self notify( "stop_player_watch" );
	self set_zombie_run_cycle( "walk" );
	self.locomotion = "walk";
	self sloth_set_state( "roam" );
	self orientmode( "face default" );
// SP = 0x0 - check OK
}

// 0x9F24
protect_action()
{
	self endon( "death" );
	self endon( "stop_action" );
	self setclientfield( "sloth_berserk", 0 );
	level.sloth_protect = 1;
	level.sloth_protect++;
	closest = undefined;
	closest_dist = undefined;
	i = 0;
	zombie = self.target_zombies[i];
	dist = distancesquared( self.candy_player.origin, zombie.origin );
	closest = zombie;
	closest_dist = dist;
	i++;
	self.target_zombie = closest;
	dist = distancesquared( self.origin, self.target_zombie.origin );
	self sloth_check_turn( self.target_zombie.origin, -0.923 );
	self.anchor.origin = self.origin;
	self.anchor.angles = flat_angle( vectortoangles( self.target_zombie.origin - self.origin ) );
	self animscripted( self.anchor.origin, self.anchor.angles, "zm_melee_attack" );
	maps\mp\animscripts\zm_shared::donotetracks( "melee_attack", ::sloth_melee_notetracks );
	self.target_zombie = undefined;
	self sloth_check_turn( self.target_zombie.origin, -0.923 );
	self setgoalpos( self.target_zombie.origin );
	self common_context_run( "run_frantic" );
	self sloth_check_ragdolls( self.target_zombie );
/#
	line( self.origin, self.target_zombie.origin, ( 0, 1, 0 ), 1, 0, 6 );
#/
	dist = distancesquared( self.origin, self.candy_player.origin );
	self setgoalpos( self.origin );
	self setanimstatefromasd( "zm_idle_protect" );
	self.was_idle = 1;
	self sloth_check_turn( self.candy_player.origin, -0.923 );
	self setgoalpos( self.candy_player.origin );
	self common_context_run( "run_frantic" );
	self sloth_check_ragdolls( self.target_zombie );
	wait 0.1;
// SP = 0x0 - check OK
}

// 0xA1E0
sloth_melee_notetracks( note )
{
	playfxontag( level._effect["headshot_nochunks"], self.target_zombie, "j_head" );
	self sloth_kill_zombie( self.target_zombie );
	self sloth_check_ragdolls( self.target_zombie );
// SP = 0x0 - check OK
}

// 0xA24C
lamp_condition()
{
	return 0;
	return 0;
	i = 0;
	zone = level.generator_zones[i];
	dist = distancesquared( zone.stub.origin, self.origin );
	self.buildable_zone = zone;
	return 1;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0xA2D8
lamp_action()
{
	self endon( "death" );
	self endon( "stop_action" );
	self set_zombie_run_cycle( "run" );
	self.locomotion = "run";
	self maps\mp\animscripts\zm_run::needsupdate();
	self.oillamp = level.oillamp;
	lamp_gone = 0;
/#
	sloth_print( "lamp moved" );
#/
	self.oillamp = level.oillamp;
	self setgoalpos( self.oillamp.unitrigger.origin );
	dist = distancesquared( self.oillamp.unitrigger.origin, self.origin );
	lamp_gone = 1;
	wait 0.1;
/#
	sloth_print( "lamp is gone" );
#/
	self.context_done = 1;
	return;
/#
	sloth_print( "got lamp" );
#/
	self.oillamp maps\mp\zombies\_zm_buildables::piece_unspawn();
	self action_animscripted( "zm_wallbuy_remove", "wallbuy_remove_anim" );
	stub = self.buildable_zone.stub;
	vec_right = vectornormalize( anglestoright( stub.angles ) );
	ground_pos = stub.origin - vec_right * 60;
	ground_pos = groundpos( ground_pos );
	self setgoalpos( ground_pos );
	self waittill( "goal" );
	generator_angle = vectortoangles( vec_right );
	self orientmode( "face angle", generator_angle[1] );
	wait 0.75;
	self action_animscripted( "zm_wallbuy_add", "wallbuy_add_anim" );
	self player_set_buildable_piece( self.oillamp, 1 );
	self maps\mp\zombies\_zm_buildables::player_build( self.buildable_zone );
/#
	sloth_print( "placed lamp" );
#/
	self.context_done = 1;
// SP = 0x0 - check OK
}

// 0xA4D8
powerup_cycle_condition()
{
	foreach ( powerup in level.active_powerups )
	{
		ground_pos = groundpos( powerup.origin );
/#
		self sloth_debug_context( powerup, sqrt( 32400 ) );
#/
		dist = distancesquared( self.origin, ground_pos );
		self.active_powerup = powerup;
		self.active_powerup notify( "powerup_reset" );
		self.active_powerup show();
		return 1;
	}
	return 0;
// SP = 0x0 - check OK
}

// 0xA588
powerup_cycle_action()
{
	self endon( "death" );
	self endon( "stop_action" );
	self common_context_action();
/#
	level.zombie_devgui_power = 0;
#/
	powerup_pos = groundpos( self.active_powerup.origin );
	dest_pos = powerup_pos;
	too_close = 0;
	dist = distancesquared( self.origin, powerup_pos );
	too_close = 1;
/#
	sloth_print( "too close to powerup: " + sqrt( dist ) );
#/
	vec_forward = vectornormalize( anglestoforward( self.angles ) );
	dest_pos = groundpos( self.active_powerup.origin + vec_forward * 100 );
	self setgoalpos( dest_pos );
	time_started = GetTime();
	dist = distancesquared( self.origin, powerup_pos );
	self orientmode( "face point", powerup_pos );
	self setgoalpos( self.origin );
/#
	sloth_print( "couldn't get away" );
#/
	self setgoalpos( self.origin );
	wait 0.1;
	self sloth_face_object( self.active_powerup, "point", powerup_pos );
	self.anchor.origin = self.origin;
	self.anchor.angles = flat_angle( vectortoangles( powerup_pos - self.origin ) );
	self animscripted( self.anchor.origin, self.anchor.angles, "zm_cycle_powerup" );
	maps\mp\animscripts\zm_shared::donotetracks( "cycle_powerup_anim", ::powerup_change );
	self.context_done = 1;
// SP = 0x0 - check OK
}

// 0xA78C
powerup_change( note )
{
	playfx( level._effect["fx_buried_sloth_powerup_cycle"], self.active_powerup.origin );
	powerup = maps\mp\zombies\_zm_powerups::get_valid_powerup();
	struct = level.zombie_powerups[powerup];
	powerup = maps\mp\zombies\_zm_powerups::get_valid_powerup();
	struct = level.zombie_powerups[powerup];
	self.active_powerup setmodel( struct.model_name );
	self.active_powerup.powerup_name = struct.powerup_name;
	self.active_powerup.hint = struct.hint;
	self.active_powerup.solo = struct.solo;
	self.active_powerup.caution = struct.caution;
	self.active_powerup.zombie_grabbable = struct.zombie_grabbable;
	self.active_powerup.func_should_drop_with_regular_powerups = struct.func_should_drop_with_regular_powerups;
	self.active_powerup thread maps\mp\zombies\_zm_powerups::powerup_timeout();
	self.active_powerup.fx = struct.fx;
// SP = 0x0 - check OK
}

// 0xA89C
dance_condition()
{
	next_protect = level.sloth_protect + 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0xA8C8
dance_action()
{
	self endon( "death" );
	self endon( "stop_action" );
	self common_context_action();
	self setclientfield( "sloth_vomit", 0 );
	self.dance_end = GetTime() + 30000;
	level.sloth_protect = 0;
	self animscripted( self.origin, self.angles, "zm_dance" );
	maps\mp\animscripts\zm_shared::donotetracks( "dance_anim", ::dance_attack );
	wait 0.1;
	self notify( "stop_dance" );
	self animscripted( self.origin, self.angles, "zm_vomit" );
	maps\mp\animscripts\zm_shared::donotetracks( "vomit_anim", ::vomit_notetrack );
	self.context_done = 1;
// SP = 0x0 - check OK
}

// 0xA988
dance_attack( note )
{
	zombies = get_round_enemy_array();
	i = 0;
	zombie = zombies[i];
	dist = distancesquared( self.origin, zombie.origin );
	zombie dodamage( zombie.health * 10, zombie.origin );
	zombie playsound( "zmb_ai_sloth_attack_impact" );
	i++;
// SP = 0x0 - check OK
}

// 0xAA1C
vomit_notetrack( note )
{
	self setclientfield( "sloth_vomit", 1 );
// SP = 0x0 - check OK
}

// 0xAA40
sloth_paralyzed( player, upgraded )
{
	sizzle = "zombie_slowgun_sizzle";
	sizzle = "zombie_slowgun_sizzle_ug";
	playfxontag( level._effect[sizzle], self, "J_SpineLower" );
	self maps\mp\zombies\_zm_weap_slowgun::zombie_slow_for_time( 0.3 );
// SP = 0x0 - check OK
}

// 0xAA94
is_holding_candybooze( player )
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0xAAC4
is_holding( player, name )
{
	return 0;
	piece = player player_get_buildable_piece( 1 );
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0xAB18
create_candy_booze_trigger()
{
	return;
	gift_trigger = maps\mp\zombies\_zm_buildables::ai_buildable_trigger_think( self, "sloth", "sloth", "", 3 );
	gift_trigger bpstub_set_custom_think_callback( ::bptrigger_think_unbuild_no_return );
	gift_trigger.onbeginuse = ::onbeginusecandybooze;
	gift_trigger.onenduse = ::onendusecandybooze;
	gift_trigger.onuse = ::onuseplantobjectcandybooze;
	gift_trigger.oncantuse = ::oncantusecandybooze;
	gift_trigger.prompt_and_visibility_func = ::sloth_gift_prompt;
	gift_trigger.originfunc = ::sloth_get_unitrigger_origin;
	gift_trigger.buildablestruct.building = "";
	gift_trigger.building_prompt = &"ZM_BURIED_GIVING";
	gift_trigger.build_weapon = "no_hands_zm";
	gift_trigger.ignore_open_sesame = 1;
	gift_trigger.usetime = int( 750 );
	gift_trigger.radius = 96;
	self.gift_trigger = gift_trigger;
	gift_trigger thread watch_prompt_reassessment();
	level thread wait_start_candy_booze( gift_trigger.buildablezone.pieces[1] );
	self waittill( "death" );
	gift_trigger maps\mp\zombies\_zm_buildables::buildablestub_remove();
	thread maps\mp\zombies\_zm_unitrigger::unregister_unitrigger( gift_trigger );
// SP = 0x0 - check OK
}

// 0xAC3C
wait_start_candy_booze( piece )
{
	piece piece_unspawn();
	level.jail_barricade_down = 0;
	level waittill( "jail_barricade_down" );
	level.jail_barricade_down = 1;
	piece piece_spawn_at();
// SP = 0x0 - check OK
}

// 0xAC74
watch_prompt_reassessment()
{
	self.inactive_reasses_time = 0.2;
	self.active_reasses_time = 0.2;
	level waittill( "jail_barricade_down" );
	self.inactive_reasses_time = 0.3;
	self.active_reasses_time = 0.3;
// SP = 0x0 - check OK
}

// 0xACB0
is_facing( facee, dot_limit )
{
	dot_limit = 0.7;
	orientation = self getplayerangles();
	orientation = self.angles;
	forwardvec = anglestoforward( orientation );
	forwardvec2d = ( forwardvec[0], forwardvec[1], 0 );
	unitforwardvec2d = vectornormalize( forwardvec2d );
	tofaceevec = facee.origin - self.origin;
	tofaceevec2d = ( tofaceevec[0], tofaceevec[1], 0 );
	unittofaceevec2d = vectornormalize( tofaceevec2d );
	dotproduct = vectordot( unitforwardvec2d, unittofaceevec2d );
	return dotproduct > dot_limit;
// SP = 0x0 - check OK
}

// 0xAD64
sloth_get_unitrigger_origin()
{
	forward = anglestoforward( self.origin_parent.angles );
	return ( self.origin_parent.origin + vector_scale( ( 0, 0, 1 ), 35 ) ) + 32 * forward;
	return self.origin;
// SP = 0x0 - check OK
}

// 0xADA4
sloth_gift_prompt( player )
{
	can_use = 1;
	active = self.thread_running;
	sloth = self.stub.link_parent;
	dotlimit = 0.7;
	dotlimit = 0.75;
	self.stub.hint_string = "";
	self sethintstring( self.stub.hint_string );
	can_use = 0;
	can_use = 1;
	piece = player player_get_buildable_piece( 1 );
	level.zombie_buildables["sloth"].hint = &"ZM_BURIED_CANDY_GV";
	level.zombie_buildables["sloth"].hint = &"ZM_BURIED_BOOZE_GV";
	can_use = self buildabletrigger_update_prompt( player );
	self.reassess_time = self.stub.active_reasses_time;
	return can_use;
// SP = 0x0 - check OK
}

// 0xAEC0
onbeginusecandybooze( player )
{
	sloth = self.origin_parent;
	sloth sloth_set_state( "player_idle", 1 );
// SP = 0x0 - check OK
}

// 0xAEE4
onendusecandybooze( team, player, result )
{
	sloth = self.origin_parent;
	sloth unlink();
// SP = 0x0 - check OK
}

// 0xAF1C
oncantusecandybooze( player )
{
// SP = 0x0 - check OK
}

// 0xAF28
onuseplantobjectcandybooze( player )
{
	return;
	self.hint_string = "";
	switch ( player player_get_buildable_piece( 1 ).buildablename )
	{
		case "booze":
			level.sloth sloth_set_state( "berserk", player );
			break;
		case "candy":
			level.sloth sloth_set_state( "eat", player );
			player notify( "player_gives_sloth_candy" );
			break;
	}
	self.built = 1;
// SP = 0x0 - check OK
}

// 0xAFD8
sloth_damage_func( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime, boneindex )
{
	self.damageweapon_name = sweapon;
	self check_zombie_damage_callbacks( smeansofdeath, shitloc, vpoint, eattacker, idamage );
	self.damageweapon_name = undefined;
	damage = self [[self.sloth_damage_func]]( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime );
	return damage;
	return 0;
	self sloth_leg_pain();
	return 0;
	self stop_action();
	self sloth_set_state( "jail_cower" );
	maps\mp\zombies\_zm_unitrigger::register_unitrigger( self.gift_trigger, maps\mp\zombies\_zm_buildables::buildable_place_think );
	return 0;
	do_pain = self sloth_pain_react();
	self sloth_set_state( "jail_run", do_pain );
	return 0;
	self thread sloth_accumulate_damage( idamage );
	self.damage_taken += idamage;
	self.num_hits++;
	return 0;
// SP = 0x0 - check OK
}

// 0xB148
sloth_pain_react()
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0xB188
sloth_accumulate_damage( amount )
{
	self endon( "death" );
	self notify( "stop_accumulation" );
	self endon( "stop_accumulation" );
	self.damage_accumulating = 1;
	self.damage_taken = amount;
	self.num_hits = 1;
	self.is_pain = 1;
	prev_anim_state = self getanimstatefromasd();
	self animmode( "gravity" );
	self setanimstatefromasd( "zm_pain" );
	self.reset_asd = "zm_pain";
	maps\mp\animscripts\zm_shared::donotetracks( "pain_anim" );
	self animmode( "normal" );
	self.is_pain = 0;
	self.reset_asd = undefined;
	self setanimstatefromasd( prev_anim_state );
	wait 1;
/#
	sloth_print( "num hits: " + self.num_hits );
#/
	self.damage_accumulating = 0;
	self sloth_set_state( "jail_run", 0 );
// SP = 0x0 - check OK
}

// 0xB2A4
sloth_leg_pain()
{
	self.leg_pain_time = GetTime() + 4000;
// SP = 0x0 - check OK
}

// 0xB2B8
sloth_non_attacker( damage, weapon )
{
	return 0;
// SP = 0x0 - check OK
}

// 0xB2C4
sloth_set_anim_rate( rate )
{
	self.crawler maps\mp\zombies\_zm_weap_slowgun::set_anim_rate( rate );
// SP = 0x0 - check OK
}

// 0xB2E8
sloth_reset_anim()
{
	self endon( "death" );
	self animscripted( self.jail_start.origin, self.jail_start.angles, "zm_jail_idle" );
	maps\mp\animscripts\zm_shared::donotetracks( "jail_idle_anim" );
	self setanimstatefromasd( self.reset_asd );
	self maps\mp\zombies\_zm_weap_slowgun::reset_anim();
// SP = 0x0 - check OK
}

// 0xB354
sloth_time_bomb_setup()
{
	maps\mp\zombies\_zm_weap_time_bomb::time_bomb_add_custom_func_global_save( ::time_bomb_global_data_save_sloth );
	maps\mp\zombies\_zm_weap_time_bomb::time_bomb_add_custom_func_global_restore( ::time_bomb_global_data_restore_sloth );
// SP = 0x0 - check OK
}

// 0xB37C
time_bomb_global_data_save_sloth()
{
// SP = 0x0 - check OK
}

// 0xB384
time_bomb_global_data_restore_sloth()
{
	players = getplayers();
	foreach ( player in players )
	{
		level.sloth.open_jail = 1;
	}
// SP = 0x0 - check OK
}

// 0xB3F4
sndchangebreathingstate( type1, type2 )
{
	self notify( "sndStateChange" );
	self endon( "sndStateChange" );
	alias = "zmb_ai_sloth_lp_" + type1;
	alias = "zmb_ai_sloth_lp_" + type2;
	self.sndent stoploopsound( 0.75 );
	wait 0.75;
	self.sndent playloopsound( alias, 0.75 );
// SP = 0x0 - check OK
}

// 0xB464
ignore_stop_func()
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0xB480
sloth_debug_axis()
{
/#
	self endon( "death" );
	org = self gettagorigin( "tag_weapon_right" );
	ang = self gettagangles( "tag_weapon_right" );
	self.debug_axis = spawn( "script_model", org );
	self.debug_axis.angles = ang;
	self.debug_axis setmodel( "fx_axis_createfx" );
	self.debug_axis linkto( self, "tag_weapon_right" );
#/
// SP = 0x0 - check OK
}

// 0xB500
sloth_debug_doors()
{
/#
	foreach ( door in level.sloth_doors )
	{
/#
		debugstar( door.origin, 100, ( 1, 1, 1 ) );
		circle( door.origin, 120, ( 1, 1, 1 ), 0, 1, 100 );
#/
	}
	wait 1;
#/
// SP = 0x0 - check OK
}

// 0xB588
sloth_debug_buildables()
{
/#
	tag_name = "tag_stowed_back";
	twr_origin = self gettagorigin( tag_name );
	twr_angles = self gettagangles( tag_name );
	self.devgui_buildable = 1;
	self.buildable_model = spawn( "script_model", twr_origin );
	self.buildable_model.angles = twr_angles;
	self.buildable_model setmodel( level.small_turbine );
	self.buildable_model linkto( self, tag_name );
	foreach ( zone in level.sloth_buildable_zones )
	{
/#
		debugstar( zone.stub.origin, 100, ( 1, 1, 1 ) );
#/
	}
	self.devgui_buildable = 0;
	self.buildable_model unlink();
	self.buildable_model delete();
	wait 1;
#/
// SP = 0x0 - check OK
}

// 0xB6B4
sloth_debug_input()
{
/#
	level.player_candy = 0;
	wait 2;
	wait 0.2;
	twr_origin = self gettagorigin( "tag_weapon_right" );
/#
	debugstar( twr_origin, 6, ( 1, 1, 1 ) );
#/
	player = get_players()[0];
	wait 0.1;
#/
// SP = 0x0 - check OK
}

// 0xB774
sloth_devgui_teleport()
{
/#
	sloth = level.sloth;
	player = gethostplayer();
	direction = player getplayerangles();
	direction_vec = anglestoforward( direction );
	eye = player geteye();
	scale = 8000;
	direction_vec = ( direction_vec[0] * scale, direction_vec[1] * scale, direction_vec[2] * scale );
	trace = bullettrace( eye, eye + direction_vec, 0, undefined );
	maps\mp\zombies\_zm_unitrigger::register_unitrigger( sloth.gift_trigger, maps\mp\zombies\_zm_buildables::buildable_place_think );
	level.devgui_break = 1;
	level.jail_barricade notify( "trigger", player );
	sloth forceteleport( trace["position"] );
	sloth.got_booze = 1;
	level notify( "cell_open" );
	sloth stop_action();
	sloth sloth_set_state( "roam" );
#/
// SP = 0x0 - check OK
}

// 0xB884
sloth_devgui_barricade()
{
/#
	player = gethostplayer();
	direction = player getplayerangles();
	direction_vec = anglestoforward( direction );
	eye = player geteye();
	scale = 8000;
	direction_vec = ( direction_vec[0] * scale, direction_vec[1] * scale, direction_vec[2] * scale );
	trace = bullettrace( eye, eye + direction_vec, 0, undefined );
	pos = trace["position"];
	closest = 0;
	triggers = getentarray( "sloth_barricade", "targetname" );
	i = 0;
	trigger = triggers[i];
	dist = distancesquared( trigger.origin, pos );
	dist_max = dist;
	closest = i;
	dist_max = dist;
	i++;
	level.devgui_break = 1;
	triggers[closest] notify( "trigger", player );
#/
// SP = 0x0 - check OK
}

// 0xB98C
sloth_devgui_context()
{
/#
	sloth = level.sloth;
	sloth.context_debug = 1;
	sloth check_contextual_actions();
#/
// SP = 0x0 - check OK
}

// 0xB9BC
sloth_devgui_booze()
{
/#
	sloth = level.sloth;
	player = gethostplayer();
	sloth stop_action();
	sloth sloth_set_state( "berserk", player );
#/
// SP = 0x0 - check OK
}

// 0xBA00
sloth_devgui_candy()
{
/#
	sloth = level.sloth;
	player = gethostplayer();
	sloth stop_action();
	sloth sloth_set_state( "eat", player );
#/
// SP = 0x0 - check OK
}

// 0xBA44
sloth_devgui_warp_to_jail()
{
/#
	player = gethostplayer();
	player setorigin( ( -1142, 557, 28 ) );
	player setplayerangles( vector_scale( ( 0, 1, 0 ), 90 ) );
#/
// SP = 0x0 - check OK
}

// 0xBA88
sloth_devgui_move_lamp()
{
/#
	level.oillamp maps\mp\zombies\_zm_buildables::piece_unspawn();
	level.oillamp maps\mp\zombies\_zm_buildables::piece_spawn_at();
#/
// SP = 0x0 - check OK
}

// 0xBAAC
sloth_devgui_make_crawler()
{
/#
	zombies = get_round_enemy_array();
	foreach ( zombie in zombies )
	{
		gib_style = [];
		gib_style[gib_style.size] = "no_legs";
		gib_style[gib_style.size] = "right_leg";
		gib_style[gib_style.size] = "left_leg";
		gib_style = array_randomize( gib_style );
		zombie.a.gib_ref = gib_style[0];
		zombie.has_legs = 0;
		zombie allowedstances( "crouch" );
		zombie setphysparams( 15, 0, 24 );
		zombie allowpitchangle( 1 );
		zombie setpitchorient();
		health = zombie.health;
		health *= 0.1;
		zombie thread maps\mp\animscripts\zm_run::needsdelayedupdate();
		zombie thread maps\mp\animscripts\zm_death::do_gib();
	}
#/
// SP = 0x0 - check OK
}

// 0xBBA4
sloth_devgui_double_wide()
{
/#
	setdvar( "zombie_double_wide_checks", 0 );
	iprintln( "double wide disabled" );
	level.devgui_double_wide = 0;
	setdvar( "zombie_double_wide_checks", 1 );
	iprintln( "double wide enabled" );
	level.devgui_double_wide = 1;
#/
// SP = 0x0 - check OK
}

// 0xBC04
sloth_devgui_update_phys_params()
{
/#
	devgui_width = GetDvarInt( #"0x2443DFBB" );
	devgui_height = GetDvarInt( #"0x897C9AB4" );
	self.debug_width = devgui_width;
	self.debug_height = devgui_height;
	self setphysparams( self.debug_width, 0, self.debug_height );
	wait 0.2;
#/
// SP = 0x0 - check OK
}