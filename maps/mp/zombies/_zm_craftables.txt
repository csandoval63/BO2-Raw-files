// maps/mp/zombies/_zm_craftables.gsc

#include maps\mp\_demo;
#include maps\mp\zombies\_zm_weapons;
#include maps\mp\zombies\_zm_stats;
#include maps\mp\zombies\_zm_craftables;
#include maps\mp\zombies\_zm_unitrigger;
#include maps\mp\zombies\_zm_equipment;
#include maps\mp\zombies\_zm_laststand;
#include maps\mp\gametypes_zm\_hud_util;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\_utility;
#include common_scripts\utility;


// 0x2BF4
init()
{
	precachestring( &"ZOMBIE_BUILDING" );
	precachestring( &"ZOMBIE_BUILD_PIECE_MISSING" );
	precachestring( &"ZOMBIE_BUILD_PIECE_GRAB" );
	precacheitem( "zombie_builder_zm" );
	precacheitem( "buildable_piece_zm" );
	level.craftable_piece_swap_allowed = 1;
	zombie_craftables_callbacks = [];
	level.craftablepickups = [];
	level.craftables_crafted = [];
	level.a_uts_craftables = [];
	level.craftable_piece_count = 0;
	level._effect["building_dust"] = loadfx( "maps/zombie/fx_zmb_buildable_assemble_dust" );
	[[level.init_craftables]]();
	open_table = spawnstruct();
	open_table.name = "open_table";
	open_table.triggerthink = ::opentablecraftable;
	open_table.custom_craftablestub_update_prompt = ::open_craftablestub_update_prompt;
	include_zombie_craftable( open_table );
	add_zombie_craftable( "open_table", &"" );
	onplayerconnect_callback( ::craftables_watch_swipes );
// SP = 0x0 - check OK
}

// 0x2CE8
anystub_update_prompt( player )
{
	self.hint_string = "";
	return 0;
	self.hint_string = "";
	return 0;
	self.hint_string = "";
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x2D58
anystub_get_unitrigger_origin()
{
	return self.origin_parent.origin;
	return self.origin;
// SP = 0x0 - check OK
}

// 0x2D78
anystub_on_spawn_trigger( trigger )
{
	trigger enablelinkto();
	trigger linkto( self.link_parent );
	trigger setmovingplatformenabled( 1 );
// SP = 0x0 - check OK
}

// 0x2DB4
craftables_watch_swipes()
{
	self endon( "disconnect" );
	self notify( "craftables_watch_swipes" );
	self endon( "craftables_watch_swipes" );
	self waittill( "melee_swipe", zombie );
	trigger = level._unitriggers.trigger_pool[self getentitynumber()];
	piece = trigger.stub.piece;
	piece.damage = 0;
	piece.damage++;
	thread maps\mp\zombies\_zm_equipment::equipment_disappear_fx( trigger.stub maps\mp\zombies\_zm_unitrigger::unitrigger_origin() );
	piece maps\mp\zombies\_zm_craftables::piece_unspawn();
	self maps\mp\zombies\_zm_stats::increment_client_stat( "cheat_total", 0 );
	self playlocalsound( level.zmb_laugh_alias );
// SP = 0x0 - check OK
}

// 0x2EC4
explosiondamage( damage, pos )
{
/#
	println( "ZM CRAFTABLE Explode do " + damage + " damage to " + self.name + "\n" );
#/
	self dodamage( damage, pos );
// SP = 0x0 - check OK
}

// 0x2F04
make_zombie_craftable_open( str_craftable, str_model, v_angle_offset, v_origin_offset )
{
/#
	assert( IsDefined( level.zombie_craftablestubs[str_craftable] ), "Craftable " + str_craftable + " has not been added yet." );
#/
	precachemodel( str_model );
	s_craftable = level.zombie_craftablestubs[str_craftable];
	s_craftable.is_open_table = 1;
	s_craftable.str_model = str_model;
	s_craftable.v_angle_offset = v_angle_offset;
	s_craftable.v_origin_offset = v_origin_offset;
// SP = 0x0 - check OK
}

// 0x2F74
add_zombie_craftable( craftable_name, str_to_craft, str_crafting, str_taken, onfullycrafted, need_all_pieces )
{
	level.zombie_include_craftables = [];
	return;
	precachestring( str_to_craft );
	precachestring( str_crafting );
	precachestring( str_taken );
	craftable_struct = level.zombie_include_craftables[craftable_name];
	level.zombie_craftablestubs = [];
	craftable_struct.str_to_craft = str_to_craft;
	craftable_struct.str_crafting = str_crafting;
	craftable_struct.str_taken = str_taken;
	craftable_struct.onfullycrafted = onfullycrafted;
	craftable_struct.need_all_pieces = need_all_pieces;
/#
	println( "ZM >> Looking for craftable - " + craftable_struct.name );
#/
	level.zombie_craftablestubs[craftable_struct.name] = craftable_struct;
	bits = getminbitcountfornum( level.craftable_piece_count );
	registerclientfield( "toplayer", "craftable", 9000, bits, "int" );
// SP = 0x0 - check OK
}

// 0x309C
add_zombie_craftable_vox_category( craftable_name, vox_id )
{
	craftable_struct = level.zombie_include_craftables[craftable_name];
	craftable_struct.vox_id = vox_id;
// SP = 0x0 - check OK
}

// 0x30BC
include_zombie_craftable( craftablestub )
{
	level.zombie_include_craftables = [];
/#
	println( "ZM >> Including craftable - " + craftablestub.name );
#/
	level.zombie_include_craftables[craftablestub.name] = craftablestub;
// SP = 0x0 - check OK
}

// 0x30FC
generate_zombie_craftable_piece( craftablename, piecename, modelname, radius, height, drop_offset, hud_icon, onpickup, ondrop, oncrafted, use_spawn_num, tag_name, can_reuse, client_field_value, is_shared, vox_id )
{
	is_shared = 0;
	precachemodel( modelname );
	precacheshader( hud_icon );
	piecestub = spawnstruct();
	craftable_pieces = [];
	piece_alias = "";
	piecename = modelname;
	craftable_pieces_structs = getstructarray( craftablename + "_" + piecename, "targetname" );
/#
	println( "ERROR: Missing craftable piece <" + craftablename + "> <" + piecename + ">\n" );
#/
	foreach ( struct in craftable_pieces_structs )
	{
		craftable_pieces[index] = struct;
		craftable_pieces[index].hasspawned = 0;
	}
	piecestub.spawns = craftable_pieces;
	piecestub.craftablename = craftablename;
	piecestub.piecename = piecename;
	piecestub.modelname = modelname;
	piecestub.hud_icon = hud_icon;
	piecestub.radius = radius;
	piecestub.height = height;
	piecestub.tag_name = tag_name;
	piecestub.can_reuse = can_reuse;
	piecestub.drop_offset = drop_offset;
	piecestub.max_instances = 256;
	piecestub.onpickup = onpickup;
	piecestub.ondrop = ondrop;
	piecestub.oncrafted = oncrafted;
	piecestub.use_spawn_num = use_spawn_num;
	piecestub.is_shared = is_shared;
	piecestub.vox_id = vox_id;
/#
	assert( isstring( client_field_value ), "Client field value for shared item (" + piecename + ") should be a string (the name of the ClientField to use)" );
#/
	piecestub.client_field_id = client_field_value;
	piecestub.client_field_state = client_field_value;
	return piecestub;
// SP = 0x0 - check OK
}

// 0x32EC
manage_multiple_pieces( max_instances )
{
	self.max_instances = max_instances;
	self.managing_pieces = 1;
	self.piece_allocated = [];
// SP = 0x0 - check OK
}

// 0x330C
combine_craftable_pieces( piece1, piece2, piece3 )
{
	spawns1 = piece1.spawns;
	spawns2 = piece2.spawns;
	spawns = arraycombine( spawns1, spawns2, 1, 0 );
	spawns3 = piece3.spawns;
	spawns = arraycombine( spawns, spawns3, 1, 0 );
	spawns = array_randomize( spawns );
	piece3.spawns = spawns;
	spawns = array_randomize( spawns );
	piece1.spawns = spawns;
	piece2.spawns = spawns;
// SP = 0x0 - check OK
}

// 0x33A8
add_craftable_piece( piecestub, tag_name, can_reuse )
{
	self.a_piecestubs = [];
	piecestub.tag_name = tag_name;
	piecestub.can_reuse = can_reuse;
	self.a_piecestubs[self.a_piecestubs.size] = piecestub;
// SP = 0x0 - check OK
}

// 0x33F4
player_drop_piece_on_downed()
{
	self endon( "craftable_piece_released" );
	self waittill( "bled_out" );
	onplayerlaststand();
// SP = 0x0 - check OK
}

// 0x3410
onplayerlaststand()
{
	piece = self.current_craftable_piece;
	return_to_start_pos = 0;
	return_to_start_pos = 1;
	piece piece_spawn_at();
	piece piece_spawn_at( self.origin + vector_scale( ( 1, 1, 0 ), 5 ), self.angles );
	piece [[piece.ondrop]]( self );
	self setclientfieldtoplayer( "craftable", 0 );
	self.current_craftable_piece = undefined;
	self notify( "craftable_piece_released" );
// SP = 0x0 - check OK
}

// 0x34B0
piecestub_get_unitrigger_origin()
{
	return self.origin_parent.origin + vector_scale( ( 0, 0, 1 ), 12 );
	return self.origin;
// SP = 0x0 - check OK
}

// 0x34D8
generate_piece_unitrigger( classname, origin, angles, flags, radius, script_height, moving )
{
	radius = 64;
	script_height = 64;
	script_width = script_height;
	script_width = 64;
	script_length = script_height;
	script_length = 64;
	unitrigger_stub = spawnstruct();
	unitrigger_stub.origin = origin;
	unitrigger_stub.script_length = script_length;
	unitrigger_stub.script_length = 13.5;
	unitrigger_stub.script_width = script_width;
	unitrigger_stub.script_width = 27.5;
	unitrigger_stub.script_height = script_height;
	unitrigger_stub.script_height = 24;
	unitrigger_stub.radius = radius;
	unitrigger_stub.cursor_hint = "HINT_NOICON";
	unitrigger_stub.hint_string = &"ZOMBIE_BUILD_PIECE_GRAB";
	unitrigger_stub.script_unitrigger_type = "unitrigger_box_use";
	unitrigger_stub.require_look_at = 0;
	switch ( classname )
	{
		case "trigger_box":
			unitrigger_stub.script_unitrigger_type = "unitrigger_radius";
			break;
		case "trigger_box_use":
			unitrigger_stub.script_unitrigger_type = "unitrigger_radius_use";
			break;
		case "trigger_radius":
			unitrigger_stub.script_unitrigger_type = "unitrigger_box";
			break;
		case "trigger_radius_use":
			unitrigger_stub.script_unitrigger_type = "unitrigger_box_use";
			break;
	}
	unitrigger_force_per_player_triggers( unitrigger_stub, 1 );
	unitrigger_stub.prompt_and_visibility_func = ::piecetrigger_update_prompt;
	unitrigger_stub.originfunc = ::piecestub_get_unitrigger_origin;
	unitrigger_stub.onspawnfunc = ::anystub_on_spawn_trigger;
	maps\mp\zombies\_zm_unitrigger::register_unitrigger( unitrigger_stub, ::piece_unitrigger_think );
	maps\mp\zombies\_zm_unitrigger::register_static_unitrigger( unitrigger_stub, ::piece_unitrigger_think );
	return unitrigger_stub;
// SP = 0x0 - check OK
}

// 0x369C
piecetrigger_update_prompt( player )
{
	can_use = self.stub piecestub_update_prompt( player );
	self setinvisibletoplayer( player, !(can_use) );
	self sethintstring( self.stub.hint_string );
	return can_use;
// SP = 0x0 - check OK
}

// 0x36DC
piecestub_update_prompt( player )
{
	return 0;
	self.hint_string = &"ZM_CRAFTABLES_PIECE_NO_SWITCH";
	spiece = self.piece;
	cpiece = player.current_craftable_piece;
	self.hint_string = "";
	return 0;
	self.hint_string = &"ZOMBIE_BUILD_PIECE_SWITCH";
	self.hint_string = &"ZOMBIE_BUILD_PIECE_GRAB";
	return 1;
// SP = 0x0 - check OK
}

// 0x3784
piece_unitrigger_think()
{
	self endon( "kill_trigger" );
	self waittill( "trigger", player );
	player thread ignore_triggers( 0.5 );
	status = player player_can_take_piece( self.stub.piece );
	self.stub.hint_string = "";
	self sethintstring( self.stub.hint_string );
	player thread player_take_piece( self.stub.piece );
// SP = 0x0 - check OK
}

// 0x3874
player_can_take_piece( piece )
{
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x3888
dbline( from, to )
{
/#
	time = 20;
	line( from, to, ( 0, 0, 1 ), 0, 1 );
	time -= 0.05;
	wait 0.05;
#/
// SP = 0x0 - check OK
}

// 0x38D0
player_throw_piece( piece, origin, dir, return_to_spawn, return_time, endangles )
{
/#
	assert( IsDefined( piece ) );
#/
/#
	thread dbline( origin, origin + dir );
#/
	pass = 0;
	done = 0;
	altmodel = undefined;
	grenade = self magicgrenadetype( "buildable_piece_zm", origin, dir, 30000 );
	grenade thread watch_hit_players();
	grenade ghost();
	altmodel = spawn( "script_model", grenade.origin );
	altmodel setmodel( piece.modelname );
	altmodel.origin = grenade.angles;
	altmodel.angles = grenade.angles;
	altmodel linkto( grenade, "", ( 0, 0, 0 ), ( 0, 0, 0 ) );
	grenade.altmodel = altmodel;
	grenade waittill( "stationary" );
	grenade_origin = grenade.origin;
	grenade_angles = grenade.angles;
	landed_on = grenade getgroundent();
	grenade delete();
	done = 1;
	origin = grenade_origin;
	dir = ( dir[0] * -1 / 10, dir[1] * -1 / 10, -1 );
	pass++;
	endangles = grenade_angles;
	piece piece_spawn_at( grenade_origin, endangles );
	altmodel delete();
	piece [[piece.ondrop]]( self );
	piece piece_wait_and_return( return_time );
// SP = 0x0 - check OK
}

// 0x3AA4
watch_hit_players()
{
	self endon( "death" );
	self endon( "stationary" );
	self waittill( "grenade_bounce", pos, normal, ent );
	ent explosiondamage( 25, pos );
// SP = 0x0 - check OK
}

// 0x3AF4
piece_wait_and_return( return_time )
{
	self endon( "pickup" );
	wait 0.15;
	playfxontag( level.exploding_jetgun_fx, self.model, "tag_origin" );
	playfxontag( level._effect["powerup_on"], self.model, "tag_origin" );
	wait return_time - 6;
	self piece_hide();
	wait 1;
	self piece_show();
	wait 1;
	self piece_hide();
	wait 1;
	self piece_show();
	wait 1;
	self piece_hide();
	wait 1;
	self piece_show();
	wait 1;
	self notify( "respawn" );
	self piece_unspawn();
	self piece_spawn_at();
// SP = 0x0 - check OK
}

// 0x3BB0
player_return_piece_to_original_spawn()
{
	self notify( "craftable_piece_released" );
	piece = self.current_craftable_piece;
	self.current_craftable_piece = undefined;
	piece piece_spawn_at();
	self setclientfieldtoplayer( "craftable", 0 );
// SP = 0x0 - check OK
}

// 0x3BF0
player_drop_piece_on_death()
{
	self notify( "craftable_piece_released" );
	self endon( "craftable_piece_released" );
	self thread player_drop_piece_on_downed();
	origin = self.origin;
	angles = self.angles;
	piece = self.current_craftable_piece;
	self waittill( "disconnect" );
	piece piece_spawn_at( origin, angles );
	self setclientfieldtoplayer( "craftable", 0 );
// SP = 0x0 - check OK
}

// 0x3C54
player_drop_piece( piece )
{
	piece = self.current_craftable_piece;
	piece.damage = 0;
	piece piece_spawn_at( self.origin, self.angles );
	self setclientfieldtoplayer( "craftable", 0 );
	piece [[piece.ondrop]]( self );
	self.current_craftable_piece = undefined;
	self notify( "craftable_piece_released" );
// SP = 0x0 - check OK
}

// 0x3CC4
player_take_piece( piecespawn )
{
	piecestub = piecespawn.piecestub;
	damage = piecespawn.damage;
	other_piece = self.current_craftable_piece;
	self player_drop_piece( self.current_craftable_piece );
	other_piece.damage = damage;
	self do_player_general_vox( "general", "craft_swap" );
	piecespawn [[piecestub.onpickup]]( self );
	level setclientfield( piecestub.client_field_id, 1 );
	self setclientfieldtoplayer( "craftable", piecestub.client_field_state );
	piecespawn piece_unspawn();
	piecespawn notify( "pickup" );
	piecespawn.in_shared_inventory = 1;
	self.current_craftable_piece = piecespawn;
	self thread player_drop_piece_on_death();
	self track_craftable_piece_pickedup( piecespawn );
// SP = 0x0 - check OK
}

// 0x3DFC
player_destroy_piece( piece )
{
	piece = self.current_craftable_piece;
	self setclientfieldtoplayer( "craftable", 0 );
	self.current_craftable_piece = undefined;
	self notify( "craftable_piece_released" );
// SP = 0x0 - check OK
}

// 0x3E38
claim_location( location )
{
	level.craftable_claimed_locations = [];
	level.craftable_claimed_locations[location] = 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x3E6C
is_point_in_craft_trigger( point )
{
	candidate_list = [];
	foreach ( zone in level.zones )
	{
		candidate_list = arraycombine( candidate_list, zone.unitrigger_stubs, 1, 0 );
	}
	valid_range = 128;
	closest = maps\mp\zombies\_zm_unitrigger::get_closest_unitriggers( point, candidate_list, valid_range );
	index = 0;
	return 1;
	index++;
	return 0;
// SP = 0x0 - check OK
}

// 0x3F28
piece_allocate_spawn( piecestub )
{
	self.current_spawn = 0;
	self.managed_spawn = 1;
	self.piecestub = piecestub;
	any_good = 0;
	any_okay = 0;
	totalweight = 0;
	spawnweights = [];
	i = 0;
	spawnweights[i] = 0;
	any_okay = 1;
	spawnweights[i] = 0.01;
	any_good = 1;
	spawnweights[i] = 1;
	totalweight += spawnweights[i];
	i++;
/#
/#
	assert( any_okay, "There is nowhere to spawn this piece" );
#/
#/
	totalweight = float( int( totalweight ) );
	r = randomfloat( totalweight );
	i = 0;
	r -= spawnweights[i];
	self.current_spawn = i;
	piecestub.piece_allocated[self.current_spawn] = 1;
	return;
	i++;
	self.current_spawn = randomint( self.spawns.size );
	piecestub.piece_allocated[self.current_spawn] = 1;
// SP = 0x0 - check OK
}

// 0x40C0
piece_deallocate_spawn()
{
	self.piecestub.piece_allocated[self.current_spawn] = 0;
	self.current_spawn = undefined;
	self.start_origin = undefined;
// SP = 0x0 - check OK
}

// 0x40E8
piece_pick_random_spawn()
{
	self.current_spawn = 0;
	self.current_spawn = randomint( self.spawns.size );
	arrayremoveindex( self.spawns, self.current_spawn );
	self.current_spawn = 0;
/#
	println( "ERROR: All craftable spawn locations claimed" );
#/
	return;
	self.current_spawn = randomint( self.spawns.size );
// SP = 0x0 - check OK
}

// 0x41A0
piece_set_spawn( num )
{
	self.current_spawn = 0;
	self.current_spawn = int( min( num, self.spawns.size - 1 ) );
// SP = 0x0 - check OK
}

// 0x41EC
piece_spawn_in( piecestub )
{
	return;
	self piece_allocate_spawn( self.piecestub );
	self.current_spawn = 0;
	spawndef = self.spawns[self.current_spawn];
	self.unitrigger = generate_piece_unitrigger( "trigger_radius_use", spawndef.origin + vector_scale( ( 0, 0, 1 ), 12 ), spawndef.angles, 0, piecestub.radius, piecestub.height, 0 );
	self.unitrigger.piece = self;
	self.radius = piecestub.radius;
	self.height = piecestub.height;
	self.craftablename = piecestub.craftablename;
	self.piecename = piecestub.piecename;
	self.modelname = piecestub.modelname;
	self.hud_icon = piecestub.hud_icon;
	self.tag_name = piecestub.tag_name;
	self.drop_offset = piecestub.drop_offset;
	self.start_origin = spawndef.origin;
	self.start_angles = spawndef.angles;
	self.client_field_state = piecestub.client_field_state;
	self.is_shared = piecestub.is_shared;
	self.model = spawn( "script_model", self.start_origin );
	self.model.angles = self.start_angles;
	self.model setmodel( piecestub.modelname );
	self [[piecestub.onspawn]]();
	self.model ghostindemo();
	self.model.hud_icon = piecestub.hud_icon;
	self.piecestub = piecestub;
	self.unitrigger.origin_parent = self.model;
// SP = 0x0 - check OK
}

// 0x43A4
piece_spawn_at( origin, angles, use_random_start )
{
	return;
	self piece_allocate_spawn( self.piecestub );
	spawndef = self.spawns[self.current_spawn];
	self.start_origin = spawndef.origin;
	self.start_angles = spawndef.angles;
	self.current_spawn = 0;
	unitrigger_offset = vector_scale( ( 0, 0, 1 ), 12 );
	self piece_pick_random_spawn();
	spawndef = self.spawns[self.current_spawn];
	self.start_origin = spawndef.origin;
	self.start_angles = spawndef.angles;
	origin = spawndef.origin;
	angles = spawndef.angles;
	origin = self.start_origin;
	origin += ( 0, 0, self.drop_offset );
	unitrigger_offset -= ( 0, 0, self.drop_offset );
	angles = self.start_angles;
/#
	level.drop_offset = 0;
	origin += ( 0, 0, level.drop_offset );
	unitrigger_offset -= ( 0, 0, level.drop_offset );
#/
	self.model = spawn( "script_model", origin );
	self.model.angles = angles;
	self.model setmodel( self.modelname );
	origin = self.start_origin;
	angles = self.start_angles;
	self.model.origin = origin;
	self.model.angles = angles;
	self [[self.onspawn]]();
	self.unitrigger = generate_piece_unitrigger( "trigger_radius_use", origin + unitrigger_offset, angles, 0, self.radius, self.height, self.model.canmove );
	self.unitrigger.piece = self;
	self.model.hud_icon = self.hud_icon;
	self.unitrigger.origin_parent = self.model;
// SP = 0x0 - check OK
}

// 0x45D4
piece_unspawn()
{
	self piece_deallocate_spawn();
	self.model delete();
	self.model = undefined;
	thread maps\mp\zombies\_zm_unitrigger::unregister_unitrigger( self.unitrigger );
	self.unitrigger = undefined;
// SP = 0x0 - check OK
}

// 0x4630
piece_hide()
{
	self.model ghost();
// SP = 0x0 - check OK
}

// 0x4650
piece_show()
{
	self.model show();
// SP = 0x0 - check OK
}

// 0x4670
generate_piece( piecestub )
{
	piecespawn = spawnstruct();
	piecespawn.spawns = piecestub.spawns;
	piecespawn piece_allocate_spawn( piecestub );
	piecespawn piece_set_spawn( piecestub.use_spawn_num );
	piecespawn piece_pick_random_spawn();
	piecespawn piece_spawn_in( piecestub );
	piecespawn.hud_icon = piecestub.hud_icon;
	piecespawn.onpickup = piecestub.onpickup;
	piecespawn.onpickup = ::onpickuputs;
	piecespawn.ondrop = piecestub.ondrop;
	piecespawn.ondrop = ::ondroputs;
	piecespawn.oncrafted = piecestub.oncrafted;
	return piecespawn;
// SP = 0x0 - check OK
}

// 0x4780
craftable_piece_unitriggers( craftable_name, origin )
{
/#
	assert( IsDefined( craftable_name ) );
#/
/#
	assert( IsDefined( level.zombie_craftablestubs[craftable_name] ), "Called craftable_think() without including the craftable - " + craftable_name );
#/
	craftable = level.zombie_craftablestubs[craftable_name];
	craftable.a_piecestubs = [];
	flag_wait( "start_zombie_round_logic" );
	craftablespawn = spawnstruct();
	craftablespawn.craftable_name = craftable_name;
	craftablespawn.a_piecespawns = [];
	craftablepickups = [];
	foreach ( piecestub in craftable.a_piecestubs )
	{
		piecestub.generated_instances = 0;
		piece = piecestub.piecespawn;
		piece = piecestub.piecespawn;
		piece = generate_piece( piecestub );
		piecestub.piecespawn = piece;
		piecestub.generated_instances++;
		craftablespawn.a_piecespawns[craftablespawn.a_piecespawns.size] = piece;
	}
	craftablespawn.stub = self;
	return craftablespawn;
// SP = 0x0 - check OK
}

// 0x48E0
hide_craftable_table_model( trigger_targetname )
{
	trig = getent( trigger_targetname, "targetname" );
	return;
	model = getent( trig.target, "targetname" );
	model ghost();
	model notsolid();
// SP = 0x0 - check OK
}

// 0x4944
setup_unitrigger_craftable( trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent )
{
	trig = getent( trigger_targetname, "targetname" );
	return;
	return setup_unitrigger_craftable_internal( trig, equipname, weaponname, trigger_hintstring, delete_trigger, persistent );
// SP = 0x0 - check OK
}

// 0x4988
setup_unitrigger_craftable_array( trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent )
{
	triggers = getentarray( trigger_targetname, "targetname" );
	stubs = [];
	foreach ( trig in triggers )
	{
		stubs[stubs.size] = setup_unitrigger_craftable_internal( trig, equipname, weaponname, trigger_hintstring, delete_trigger, persistent );
	}
	return stubs;
// SP = 0x0 - check OK
}

// 0x49FC
setup_unitrigger_craftable_internal( trig, equipname, weaponname, trigger_hintstring, delete_trigger, persistent )
{
	return;
	unitrigger_stub = spawnstruct();
	unitrigger_stub.craftablestub = level.zombie_include_craftables[equipname];
	angles = trig.script_angles;
	angles = ( 0, 0, 0 );
	unitrigger_stub.origin = trig.origin + anglestoright( angles ) * -6;
	unitrigger_stub.angles = trig.angles;
	unitrigger_stub.angles = trig.script_angles;
	unitrigger_stub.equipname = equipname;
	unitrigger_stub.weaponname = weaponname;
	unitrigger_stub.trigger_hintstring = trigger_hintstring;
	unitrigger_stub.delete_trigger = delete_trigger;
	unitrigger_stub.crafted = 0;
	unitrigger_stub.persistent = persistent;
	unitrigger_stub.usetime = int( 3000 );
	unitrigger_stub.onbeginuse = ::onbeginuseuts;
	unitrigger_stub.onenduse = ::onenduseuts;
	unitrigger_stub.onuse = ::onuseplantobjectuts;
	unitrigger_stub.oncantuse = ::oncantuseuts;
	unitrigger_stub.script_length = trig.script_length;
	unitrigger_stub.script_length = 32;
	unitrigger_stub.script_width = trig.script_width;
	unitrigger_stub.script_width = 100;
	unitrigger_stub.script_height = trig.script_height;
	unitrigger_stub.script_height = 64;
	unitrigger_stub.target = trig.target;
	unitrigger_stub.targetname = trig.targetname;
	unitrigger_stub.script_noteworthy = trig.script_noteworthy;
	unitrigger_stub.script_parameters = trig.script_parameters;
	unitrigger_stub.cursor_hint = "HINT_NOICON";
	unitrigger_stub.hint_string = level.zombie_craftablestubs[equipname].str_to_craft;
	unitrigger_stub.script_unitrigger_type = "unitrigger_box_use";
	unitrigger_stub.require_look_at = 1;
	unitrigger_force_per_player_triggers( unitrigger_stub, 1 );
	unitrigger_stub.custom_craftablestub_update_prompt = unitrigger_stub.craftablestub.custom_craftablestub_update_prompt;
	unitrigger_stub.prompt_and_visibility_func = ::craftabletrigger_update_prompt;
	maps\mp\zombies\_zm_unitrigger::register_static_unitrigger( unitrigger_stub, ::craftable_place_think );
	unitrigger_stub.piece_trigger = trig;
	trig.trigger_stub = unitrigger_stub;
	unitrigger_stub.zombie_weapon_upgrade = trig.zombie_weapon_upgrade;
	unitrigger_stub.model = getent( unitrigger_stub.target, "targetname" );
	unitrigger_stub.model useweaponhidetags( unitrigger_stub.zombie_weapon_upgrade );
	unitrigger_stub.model ghost();
	unitrigger_stub.model notsolid();
	unitrigger_stub.a_uts_open_craftables_available = [];
	unitrigger_stub.n_open_craftable_choice = -1;
	unitrigger_stub.b_open_craftable_checking_input = 0;
	unitrigger_stub.craftablespawn = unitrigger_stub craftable_piece_unitriggers( equipname, unitrigger_stub.origin );
	trig delete();
	level.a_uts_craftables[level.a_uts_craftables.size] = unitrigger_stub;
	return unitrigger_stub;
// SP = 0x0 - check OK
}

// 0x4D2C
setup_craftable_pieces()
{
	unitrigger_stub = spawnstruct();
	unitrigger_stub.craftablestub = level.zombie_include_craftables[self.name];
	unitrigger_stub.equipname = self.name;
	unitrigger_stub.craftablespawn = unitrigger_stub craftable_piece_unitriggers( self.name, unitrigger_stub.origin );
	level.a_uts_craftables[level.a_uts_craftables.size] = unitrigger_stub;
	return unitrigger_stub;
// SP = 0x0 - check OK
}

// 0x4D8C
craftable_has_piece( piece )
{
	i = 0;
	return 1;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x4DE0
get_actual_uts_craftable()
{
	return self.stub.a_uts_open_craftables_available[self.n_open_craftable_choice];
	return self.stub;
// SP = 0x0 - check OK
}

// 0x4E14
get_actual_craftablespawn()
{
	return self.stub.a_uts_open_craftables_available[self.stub.n_open_craftable_choice].craftablespawn;
	return self;
// SP = 0x0 - check OK
}

// 0x4E6C
craftable_can_use_shared_piece()
{
	uts_craftable = self.stub;
	return 1;
	foreach ( piece in self.a_piecespawns )
	{
		return 0;
	}
	return 1;
	foreach ( piece in self.a_piecespawns )
	{
		return 1;
	}
	return 0;
// SP = 0x0 - check OK
}

// 0x4F68
craftable_set_piece_crafted( piecespawn_check, player )
{
	craftablespawn_check = get_actual_craftablespawn();
	foreach ( piecespawn in craftablespawn_check.a_piecespawns )
	{
		piecespawn.crafted = 1;
		piecespawn thread [[piecespawn.oncrafted]]( player );
		piecespawn.crafted = 1;
		piecespawn thread [[piecespawn.oncrafted]]( player );
		piecespawn.in_shared_inventory = 0;
	}
// SP = 0x0 - check OK
}

// 0x5054
craftable_set_piece_crafting( piecespawn_check )
{
	craftablespawn_check = get_actual_craftablespawn();
	foreach ( piecespawn in craftablespawn_check.a_piecespawns )
	{
		piecespawn.crafting = 1;
		piecespawn.crafting = 1;
	}
// SP = 0x0 - check OK
}

// 0x50FC
craftable_clear_piece_crafting( piecespawn_check )
{
	piecespawn_check.crafting = 0;
	craftablespawn_check = get_actual_craftablespawn();
	foreach ( piecespawn in craftablespawn_check.a_piecespawns )
	{
		piecespawn.crafting = 0;
	}
// SP = 0x0 - check OK
}

// 0x5184
craftable_is_piece_crafted( piece )
{
	i = 0;
	return self.a_piecespawns[i].crafted;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x51F0
craftable_is_piece_crafting( piecespawn_check )
{
	craftablespawn_check = get_actual_craftablespawn();
	foreach ( piecespawn in craftablespawn_check.a_piecespawns )
	{
		return piecespawn.crafting;
		return 1;
	}
	return 0;
// SP = 0x0 - check OK
}

// 0x52A4
craftable_is_piece_crafted_or_crafting( piece )
{
	i = 0;
	return self.a_piecespawns[i].crafting;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x5330
craftable_all_crafted()
{
	i = 0;
	return 0;
	i++;
	return 1;
// SP = 0x0 - check OK
}

// 0x5374
waittill_crafted( craftable_name )
{
	level waittill( craftable_name + "_crafted", player );
	return player;
// SP = 0x0 - check OK
}

// 0x5390
player_can_craft( craftablespawn, continuing )
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x5488
craftable_transfer_data()
{
	uts_craftable = self.stub;
	return;
	uts_source = uts_craftable.a_uts_open_craftables_available[uts_craftable.n_open_craftable_choice];
	uts_target = uts_craftable;
	uts_target.craftablestub = uts_source.craftablestub;
	uts_target.craftablespawn = uts_source.craftablespawn;
	uts_target.crafted = uts_source.crafted;
	uts_target.cursor_hint = uts_source.cursor_hint;
	uts_target.custom_craftable_update_prompt = uts_source.custom_craftable_update_prompt;
	uts_target.equipname = uts_source.equipname;
	uts_target.hint_string = uts_source.hint_string;
	uts_target.persistent = uts_source.persistent;
	uts_target.prompt_and_visibility_func = uts_source.prompt_and_visibility_func;
	uts_target.trigger_func = uts_source.trigger_func;
	uts_target.trigger_hintstring = uts_source.trigger_hintstring;
	uts_target.weaponname = uts_source.weaponname;
	uts_target.craftablespawn.stub = uts_target;
	thread maps\mp\zombies\_zm_unitrigger::unregister_unitrigger( uts_source );
	uts_source craftablestub_remove();
	return uts_target;
// SP = 0x0 - check OK
}

// 0x55A0
player_craft( craftablespawn )
{
	craftablespawn craftable_set_piece_crafted( self.current_craftable_piece, self );
	player_destroy_piece( self.current_craftable_piece );
	uts_craftable = craftablespawn craftable_transfer_data();
	craftablespawn = uts_craftable.craftablespawn;
	update_open_table_status();
	uts_craftable = craftablespawn.stub;
	craftablestub = uts_craftable.craftablestub;
	s_model = getstruct( uts_craftable.target, "targetname" );
	m_spawn = spawn( "script_model", s_model.origin );
	m_spawn.origin += craftablestub.v_origin_offset;
	m_spawn.angles = s_model.angles;
	m_spawn.angles += craftablestub.v_angle_offset;
	m_spawn setmodel( craftablestub.str_model );
	uts_craftable.model = m_spawn;
	i = 0;
	uts_craftable.model notsolid();
	uts_craftable.model hidepart( craftablespawn.a_piecespawns[i].tag_name );
	uts_craftable.model show();
	uts_craftable.model showpart( craftablespawn.a_piecespawns[i].tag_name );
	i++;
	self track_craftable_pieces_crafted( craftablespawn );
	self player_finish_craftable( craftablespawn );
	self track_craftables_crafted( craftablespawn );
	self thread [[level.craftable_crafted_custom_func]]( craftablespawn );
	self playsound( "zmb_buildable_complete" );
	self playsound( "zmb_buildable_piece_add" );
/#
	assert( IsDefined( level.zombie_craftablestubs[craftablespawn.craftable_name].str_crafting ), "Missing builing hint" );
#/
	return level.zombie_craftablestubs[craftablespawn.craftable_name].str_crafting;
	return "";
// SP = 0x0 - check OK
}

// 0x5858
update_open_table_status()
{
	b_open_craftables_remaining = 0;
	foreach ( uts_craftable in level.a_uts_craftables )
	{
		b_piece_crafted = 0;
		foreach ( piecespawn in uts_craftable.craftablespawn.a_piecespawns )
		{
			b_piece_crafted = 1;
		}
		b_open_craftables_remaining = 1;
	}
	foreach ( uts_craftable in level.a_uts_craftables )
	{
		thread maps\mp\zombies\_zm_unitrigger::unregister_unitrigger( uts_craftable );
	}
// SP = 0x0 - check OK
}

// 0x5978
player_finish_craftable( craftablespawn )
{
	craftablespawn.crafted = 1;
	craftablespawn.stub.crafted = 1;
	craftablespawn notify( "crafted", self );
	level.craftables_crafted[craftablespawn.craftable_name] = 1;
	level notify( craftablespawn.craftable_name + "_crafted", self );
// SP = 0x0 - check OK
}

// 0x59C0
complete_craftable( str_craftable_name )
{
	foreach ( uts_craftable in level.a_uts_craftables )
	{
		player = getplayers()[0];
		player player_finish_craftable( uts_craftable.craftablespawn );
		thread maps\mp\zombies\_zm_unitrigger::unregister_unitrigger( uts_craftable );
		uts_craftable [[uts_craftable.craftablestub.onfullycrafted]]();
	}
// SP = 0x0 - check OK
}

// 0x5A54
craftablestub_remove()
{
	arrayremovevalue( level.a_uts_craftables, self );
// SP = 0x0 - check OK
}

// 0x5A6C
craftabletrigger_update_prompt( player )
{
	can_use = self.stub craftablestub_update_prompt( player );
	self sethintstring( self.stub.hint_string );
	return can_use;
// SP = 0x0 - check OK
}

// 0x5A9C
craftablestub_update_prompt( player, unitrigger )
{
	return 0;
	return 1;
	can_use = 1;
	return 0;
	self.hint_string = &"ZOMBIE_BUILD_PIECE_MORE";
	return 0;
	self.hint_string = &"ZOMBIE_BUILD_PIECE_WRONG";
	return 0;
/#
	assert( IsDefined( level.zombie_craftablestubs[self.equipname].str_to_craft ), "Missing craftable hint" );
#/
	self.hint_string = level.zombie_craftablestubs[self.equipname].str_to_craft;
	self.hint_string = &"ZOMBIE_BUILD_PIECE_ONLY_ONE";
	return 0;
	self.hint_string = &"ZOMBIE_BUILD_PIECE_HAVE_ONE";
	return 0;
	self.hint_string = self.trigger_hintstring;
	self.hint_string = &"ZOMBIE_GO_TO_THE_BOX_LIMITED";
	return 0;
	self.hint_string = &"ZOMBIE_GO_TO_THE_BOX";
	return 0;
	self.hint_string = self.trigger_hintstring;
	self.hint_string = "";
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x5C3C
choose_open_craftable( player )
{
	self endon( "kill_choose_open_craftable" );
	n_playernum = player getentitynumber();
	self.b_open_craftable_checking_input = 1;
	b_got_input = 1;
	hinttexthudelem = newclienthudelem( player );
	hinttexthudelem.alignx = "center";
	hinttexthudelem.aligny = "middle";
	hinttexthudelem.horzalign = "center";
	hinttexthudelem.vertalign = "bottom";
	hinttexthudelem.y = -100;
	hinttexthudelem.y = -50;
	hinttexthudelem.foreground = 1;
	hinttexthudelem.font = "default";
	hinttexthudelem.fontscale = 1;
	hinttexthudelem.alpha = 1;
	hinttexthudelem.color = ( 1, 1, 1 );
	hinttexthudelem settext( &"ZM_CRAFTABLES_CHANGE_BUILD" );
	self.opencraftablehudelem = [];
	self.opencraftablehudelem[n_playernum] = hinttexthudelem;
	self.n_open_craftable_choice++;
	b_got_input = 1;
	self.n_open_craftable_choice--;
	b_got_input = 1;
	self.n_open_craftable_choice = 0;
	self.n_open_craftable_choice = self.a_uts_open_craftables_available.size - 1;
	self.equipname = self.a_uts_open_craftables_available[self.n_open_craftable_choice].equipname;
	self.hint_string = self.a_uts_open_craftables_available[self.n_open_craftable_choice].hint_string;
	self.playertrigger[n_playernum] sethintstring( self.hint_string );
	b_got_input = 0;
	self.opencraftablehudelem[n_playernum].alpha = 1;
	self.opencraftablehudelem[n_playernum].alpha = 0;
	wait 0.05;
	self.b_open_craftable_checking_input = 0;
	self.opencraftablehudelem[n_playernum] destroy();
	self.opencraftablehudelem[n_playernum] = undefined;
// SP = 0x0 - check OK
}

// 0x5E50
open_craftablestub_update_prompt( player )
{
	self.a_uts_open_craftables_available = [];
	foreach ( uts_craftable in level.a_uts_craftables )
	{
		self.a_uts_open_craftables_available[self.a_uts_open_craftables_available.size] = uts_craftable;
	}
	self notify( "kill_choose_open_craftable" );
	self.b_open_craftable_checking_input = 0;
	n_entitynum = player getentitynumber();
	self.opencraftablehudelem[n_entitynum] destroy();
	self.opencraftablehudelem[n_entitynum] = undefined;
	switch ( self.a_uts_open_craftables_available.size )
	{
		case 0:
			self.hint_string = &"ZOMBIE_BUILD_PIECE_MORE";
			self.n_open_craftable_choice = -1;
			return 0;
			break;
		case 1:
			self.n_open_craftable_choice = 0;
			self.equipname = self.a_uts_open_craftables_available[self.n_open_craftable_choice].equipname;
			return 1;
		default:
			thread choose_open_craftable( player );
			return 1;
	}
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x5FE8
player_continue_crafting( craftablespawn )
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	trigger = craftablespawn.stub maps\mp\zombies\_zm_unitrigger::unitrigger_trigger( self );
	torigin = craftablespawn.stub unitrigger_origin();
	porigin = self geteye();
	radius_sq = 2.25 * craftablespawn.stub.radius * craftablespawn.stub.radius;
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x6124
player_progress_bar_update( start_time, craft_time )
{
	self endon( "entering_last_stand" );
	self endon( "death" );
	self endon( "disconnect" );
	self endon( "craftable_progress_end" );
	progress = ( GetTime() - start_time ) / craft_time;
	progress = 0;
	progress = 1;
	self.usebar updatebar( progress );
	wait 0.05;
// SP = 0x0 - check OK
}

// 0x6198
player_progress_bar( start_time, craft_time )
{
	self.usebar = self createprimaryprogressbar();
	self.usebartext = self createprimaryprogressbartext();
	self.usebartext settext( &"ZOMBIE_BUILDING" );
	self player_progress_bar_update( start_time, craft_time );
	self.usebartext destroyelem();
	self.usebar destroyelem();
// SP = 0x0 - check OK
}

// 0x620C
craftable_use_hold_think_internal( player )
{
	wait 0.01;
	self notify( "craft_failed" );
	player.craftableaudio delete();
	player.craftableaudio = undefined;
	return;
	self.usetime = int( 3000 );
	self.craft_time = self.usetime;
	self.craft_start_time = GetTime();
	craft_time = self.craft_time;
	craft_start_time = self.craft_start_time;
	player disable_player_move_states( 1 );
	player increment_is_drinking();
	orgweapon = player getcurrentweapon();
	player giveweapon( "zombie_builder_zm" );
	player switchtoweapon( "zombie_builder_zm" );
	self.stub.craftablespawn craftable_set_piece_crafting( player.current_craftable_piece );
	player thread player_progress_bar( craft_start_time, craft_time );
	player thread [[level.craftable_craft_custom_func]]( self.stub );
	wait 0.05;
	player notify( "craftable_progress_end" );
	player maps\mp\zombies\_zm_weapons::switch_back_primary_weapon( orgweapon );
	player takeweapon( "zombie_builder_zm" );
	player decrement_is_drinking();
	player enable_player_move_states();
	self.stub.craftablespawn craftable_clear_piece_crafting( player.current_craftable_piece );
	self notify( "craft_succeed" );
	player.craftableaudio delete();
	player.craftableaudio = undefined;
	self.stub.craftablespawn craftable_clear_piece_crafting( player.current_craftable_piece );
	self notify( "craft_failed" );
// SP = 0x0 - check OK
}

// 0x6424
craftable_play_craft_fx( player )
{
	self endon( "kill_trigger" );
	self endon( "craft_succeed" );
	self endon( "craft_failed" );
	playfx( level._effect["building_dust"], player getplayercamerapos(), player.angles );
	wait 0.5;
// SP = 0x0 - check OK
}

// 0x6478
craftable_use_hold_think( player )
{
	self thread craftable_play_craft_fx( player );
	self thread craftable_use_hold_think_internal( player );
	retval = self waittill_any_return( "craft_succeed", "craft_failed" );
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x64C0
craftable_place_think()
{
	self endon( "kill_trigger" );
	player_crafted = undefined;
	self waittill( "trigger", player );
	valid = self [[level.custom_craftable_validation]]( player );
	player thread ignore_triggers( 0.5 );
	status = player player_can_craft( self.stub.craftablespawn );
	self.stub.hint_string = "";
	self sethintstring( self.stub.hint_string );
	self.stub [[self.stub.oncantuse]]( player );
	self.stub [[self.stub.onbeginuse]]( player );
	result = self craftable_use_hold_think( player );
	team = player.pers["team"];
	self.stub [[self.stub.onenduse]]( team, player, result );
	self.stub [[self.stub.onuse]]( player );
	prompt = player player_craft( self.stub.craftablespawn );
	player_crafted = player;
	self.stub.hint_string = prompt;
	self sethintstring( self.stub.hint_string );
	b_result = self.stub [[self.stub.craftablestub.onfullycrafted]]();
	return;
	self.stub craftablestub_remove();
	thread maps\mp\zombies\_zm_unitrigger::unregister_unitrigger( self.stub );
	return;
	stub_uncraft_craftable( self.stub, 1 );
	return;
	self craftabletrigger_update_prompt( player_crafted );
	self.stub.hint_string = &"ZOMBIE_GO_TO_THE_BOX_LIMITED";
	self sethintstring( self.stub.hint_string );
	return;
	self.stub.hint_string = &"ZOMBIE_GO_TO_THE_BOX";
	self sethintstring( self.stub.hint_string );
	return;
	self.stub.model notsolid();
	self.stub.model show();
	self waittill( "trigger", player );
	valid = self [[level.custom_craftable_validation]]( player );
	self.stub.hint_string = "";
	self sethintstring( self.stub.hint_string );
	return;
	player thread ignore_triggers( 0.5 );
	self.stub.bought = 1;
	self.stub.model thread model_fly_away();
	player maps\mp\zombies\_zm_weapons::weapon_give( self.stub.weaponname );
	self [[level.zombie_include_craftables[self.stub.equipname].onbuyweapon]]( player );
	self.stub.hint_string = &"ZOMBIE_GO_TO_THE_BOX_LIMITED";
	self.stub.hint_string = &"ZOMBIE_GO_TO_THE_BOX";
	self sethintstring( self.stub.hint_string );
	player track_craftables_pickedup( self.stub.weaponname );
	self.stub.model notsolid();
	self.stub.model show();
	self waittill( "trigger", player );
	valid = self [[level.custom_craftable_validation]]( player );
	self.stub.hint_string = "";
	self sethintstring( self.stub.hint_string );
	return;
	player thread ignore_triggers( 0.5 );
	player maps\mp\zombies\_zm_equipment::equipment_buy( self.stub.weaponname );
	player giveweapon( self.stub.weaponname );
	player setweaponammoclip( self.stub.weaponname, 1 );
	self [[level.zombie_include_craftables[self.stub.equipname].onbuyweapon]]( player );
	player setactionslot( 1, "weapon", self.stub.weaponname );
	self.stub.hint_string = level.zombie_craftablestubs[self.stub.equipname].str_taken;
	self.stub.hint_string = "";
	self sethintstring( self.stub.hint_string );
	player track_craftables_pickedup( self.stub.craftablespawn );
	self.stub.hint_string = "";
	self sethintstring( self.stub.hint_string );
// SP = 0x0 - check OK
}

// 0x6BA0
model_fly_away()
{
	self moveto( self.origin + vector_scale( ( 0, 0, 1 ), 40 ), 3 );
	direction = self.origin;
	direction = ( direction[1], direction[0], 0 );
	direction = ( direction[0], direction[1] * -1, 0 );
	direction = ( direction[0] * -1, direction[1], 0 );
	self vibrate( direction, 10, 0.5, 4 );
	self waittill( "movedone" );
	self ghost();
	playfx( level._effect["poltergeist"], self.origin );
// SP = 0x0 - check OK
}

// 0x6C6C
find_craftable_stub( equipname )
{
	foreach ( stub in level.a_uts_craftables )
	{
		return stub;
	}
	return undefined;
// SP = 0x0 - check OK
}

// 0x6CB4
uncraft_craftable( equipname, return_pieces, origin, angles )
{
	stub = find_craftable_stub( equipname );
	stub_uncraft_craftable( stub, return_pieces, origin, angles );
// SP = 0x0 - check OK
}

// 0x6CE8
stub_uncraft_craftable( stub, return_pieces, origin, angles, use_random_start )
{
	craftable = stub.craftablespawn;
	craftable.crafted = 0;
	craftable.stub.crafted = 0;
	craftable notify( "uncrafted" );
	level.craftables_crafted[craftable.craftable_name] = 0;
	level notify( craftable.craftable_name + "_uncrafted" );
	i = 0;
	craftable.a_piecespawns[i].crafted = 0;
	craftable.stub.model notsolid();
	craftable.stub.model hidepart( craftable.a_piecespawns[i].tag_name );
	craftable.stub.model show();
	craftable.stub.model showpart( craftable.a_piecespawns[i].tag_name );
	craftable.a_piecespawns[i] piece_spawn_at( origin, angles, use_random_start );
	i++;
	craftable.stub.model ghost();
// SP = 0x0 - check OK
}

// 0x6E60
player_explode_craftable( equipname, origin, speed, return_to_spawn, return_time )
{
	self explosiondamage( 50, origin );
	stub = find_craftable_stub( equipname );
	craftable = stub.craftablespawn;
	craftable.crafted = 0;
	craftable.stub.crafted = 0;
	craftable notify( "uncrafted" );
	level.craftables_crafted[craftable.craftable_name] = 0;
	level notify( craftable.craftable_name + "_uncrafted" );
	i = 0;
	craftable.a_piecespawns[i].crafted = 0;
	craftable.stub.model notsolid();
	craftable.stub.model hidepart( craftable.a_piecespawns[i].tag_name );
	craftable.stub.model show();
	craftable.stub.model showpart( craftable.a_piecespawns[i].tag_name );
	ang = randomfloat( 360 );
	h = 0.25 + randomfloat( 0.5 );
	dir = ( sin( ang ), cos( ang ), h );
	self thread player_throw_piece( craftable.a_piecespawns[i], origin, speed * dir, return_to_spawn, return_time );
	i++;
	craftable.stub.model ghost();
// SP = 0x0 - check OK
}

// 0x7028
think_craftables()
{
	foreach ( craftable in level.zombie_include_craftables )
	{
		craftable [[craftable.triggerthink]]();
	}
// SP = 0x0 - check OK
}

// 0x7074
opentablecraftable()
{
	a_trigs = getentarray( "open_craftable_trigger", "targetname" );
	foreach ( trig in a_trigs )
	{
		setup_unitrigger_craftable_internal( trig, "open_table", "", "OPEN_CRAFTABLE", 1, 0 );
	}
// SP = 0x0 - check OK
}

// 0x70D4
craftable_trigger_think( trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent )
{
	return setup_unitrigger_craftable( trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent );
// SP = 0x0 - check OK
}

// 0x7100
craftable_trigger_think_array( trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent )
{
	return setup_unitrigger_craftable_array( trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent );
// SP = 0x0 - check OK
}

// 0x712C
setup_vehicle_unitrigger_craftable( parent, trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent )
{
	trig = getent( trigger_targetname, "targetname" );
	return;
	unitrigger_stub = spawnstruct();
	unitrigger_stub.craftablestub = level.zombie_include_craftables[equipname];
	unitrigger_stub.link_parent = parent;
	unitrigger_stub.origin_parent = trig;
	unitrigger_stub.trigger_targetname = trigger_targetname;
	unitrigger_stub.originfunc = ::anystub_get_unitrigger_origin;
	unitrigger_stub.onspawnfunc = ::anystub_on_spawn_trigger;
	unitrigger_stub.origin = trig.origin;
	unitrigger_stub.angles = trig.angles;
	unitrigger_stub.equipname = equipname;
	unitrigger_stub.weaponname = weaponname;
	unitrigger_stub.trigger_hintstring = trigger_hintstring;
	unitrigger_stub.delete_trigger = delete_trigger;
	unitrigger_stub.crafted = 0;
	unitrigger_stub.persistent = persistent;
	unitrigger_stub.usetime = int( 3000 );
	unitrigger_stub.onbeginuse = ::onbeginuseuts;
	unitrigger_stub.onenduse = ::onenduseuts;
	unitrigger_stub.onuse = ::onuseplantobjectuts;
	unitrigger_stub.oncantuse = ::oncantuseuts;
	unitrigger_stub.script_length = trig.script_length;
	unitrigger_stub.script_length = 24;
	unitrigger_stub.script_width = trig.script_width;
	unitrigger_stub.script_width = 64;
	unitrigger_stub.script_height = trig.script_height;
	unitrigger_stub.script_height = 24;
	unitrigger_stub.radius = trig.radius;
	unitrigger_stub.radius = 64;
	unitrigger_stub.target = trig.target;
	unitrigger_stub.targetname = trig.targetname + "_trigger";
	unitrigger_stub.script_noteworthy = trig.script_noteworthy;
	unitrigger_stub.script_parameters = trig.script_parameters;
	unitrigger_stub.cursor_hint = "HINT_NOICON";
	unitrigger_stub.hint_string = level.zombie_craftablestubs[equipname].str_to_craft;
	unitrigger_stub.script_unitrigger_type = "unitrigger_radius_use";
	unitrigger_stub.require_look_at = 1;
	unitrigger_force_per_player_triggers( unitrigger_stub, 1 );
	unitrigger_stub.prompt_and_visibility_func = ::craftabletrigger_update_prompt;
	maps\mp\zombies\_zm_unitrigger::register_unitrigger( unitrigger_stub, ::craftable_place_think );
	unitrigger_stub.piece_trigger = trig;
	trig.trigger_stub = unitrigger_stub;
	unitrigger_stub.craftablespawn = unitrigger_stub craftable_piece_unitriggers( equipname, unitrigger_stub.origin );
	trig delete();
	level.a_uts_craftables[level.a_uts_craftables.size] = unitrigger_stub;
	return unitrigger_stub;
// SP = 0x0 - check OK
}

// 0x73D8
vehicle_craftable_trigger_think( vehicle, trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent )
{
	return setup_vehicle_unitrigger_craftable( vehicle, trigger_targetname, equipname, weaponname, trigger_hintstring, delete_trigger, persistent );
// SP = 0x0 - check OK
}

// 0x7408
onpickuputs( player )
{
/#
	println( "ZM >> Craftable piece recovered by - " + player.name );
#/
// SP = 0x0 - check OK
}

// 0x743C
ondroputs( player )
{
/#
	println( "ZM >> Craftable piece dropped by - " + player.name );
#/
	player notify( "event_ended" );
// SP = 0x0 - check OK
}

// 0x7478
onbeginuseuts( player )
{
/#
	println( "ZM >> Craftable piece begin use by - " + player.name );
#/
	self [[self.craftablestub.onbeginuse]]( player );
	player.craftableaudio = spawn( "script_origin", player.origin );
	player.craftableaudio playloopsound( "zmb_craftable_loop" );
// SP = 0x0 - check OK
}

// 0x7508
onenduseuts( team, player, result )
{
/#
	println( "ZM >> Craftable piece end use by - " + player.name );
#/
	return;
	player.craftableaudio delete();
	player.craftableaudio = undefined;
	self [[self.craftablestub.onenduse]]( team, player, result );
	player notify( "event_ended" );
// SP = 0x0 - check OK
}

// 0x7590
oncantuseuts( player )
{
/#
	println( "ZM >> Craftable piece can't use by - " + player.name );
#/
	self [[self.craftablestub.oncantuse]]( player );
// SP = 0x0 - check OK
}

// 0x75E0
onuseplantobjectuts( player )
{
/#
	println( "ZM >> Craftable piece crafted by - " + player.name );
#/
	self [[self.craftablestub.onuseplantobject]]( player );
	player notify( "bomb_planted" );
// SP = 0x0 - check OK
}

// 0x7638
is_craftable()
{
	return 0;
	return 1;
	return 0;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x7698
craftable_crafted()
{
	self.a_piecespawns--;
// SP = 0x0 - check OK
}

// 0x76A4
craftable_complete()
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x76BC
get_craftable_hint( craftable_name )
{
/#
	assert( IsDefined( level.zombie_craftablestubs[craftable_name] ), craftable_name + " was not included or is not part of the zombie weapon list." );
#/
	return level.zombie_craftablestubs[craftable_name].str_to_craft;
// SP = 0x0 - check OK
}

// 0x76F0
delete_on_disconnect( craftable, self_notify, skip_delete )
{
	craftable endon( "death" );
	self waittill( "disconnect" );
	self notify( self_notify );
	thread maps\mp\zombies\_zm_unitrigger::unregister_unitrigger( craftable.stub );
	craftable.stub = undefined;
	craftable delete();
// SP = 0x0 - check OK
}

// 0x7758
is_holding_part( craftable_name, piece_name )
{
	return 1;
	foreach ( craftable_stub in level.a_uts_craftables )
	{
		foreach ( piece in craftable_stub.craftablespawn.a_piecespawns )
		{
			return 1;
		}
	}
	return 0;
// SP = 0x0 - check OK
}

// 0x7828
is_part_crafted( craftable_name, piece_name )
{
	foreach ( craftable_stub in level.a_uts_craftables )
	{
		return 1;
		foreach ( piece in craftable_stub.craftablespawn.a_piecespawns )
		{
			return 1;
		}
	}
	return 0;
// SP = 0x0 - check OK
}

// 0x78E8
track_craftable_piece_pickedup( piece )
{
/#
	println( "STAT TRACKING FAILURE: NOT DEFINED IN track_craftable_piece_pickedup() \n" );
#/
	return;
	self add_map_craftable_stat( piece.craftablename, "pieces_pickedup", 1 );
	self thread do_player_general_vox( "general", piece.piecestub.vox_id + "_pickup" );
	self thread do_player_general_vox( "general", "build_pickup" );
// SP = 0x0 - check OK
}

// 0x7970
track_craftable_pieces_crafted( craftable )
{
/#
	println( "STAT TRACKING FAILURE: NOT DEFINED IN track_craftable_pieces_crafted() \n" );
#/
	return;
	bname = craftable.craftable_name;
	bname = craftable.stat_name;
	self add_map_craftable_stat( bname, "pieces_built", 1 );
	self thread do_player_general_vox( "general", "build_add" );
// SP = 0x0 - check OK
}

// 0x79F0
track_craftables_crafted( craftable )
{
/#
	println( "STAT TRACKING FAILURE: NOT DEFINED IN track_craftables_crafted() \n" );
#/
	return;
	bname = craftable.craftable_name;
	bname = craftable.stat_name;
	self add_map_craftable_stat( bname, "buildable_built", 1 );
	self maps\mp\zombies\_zm_stats::increment_client_stat( "buildables_built", 0 );
	self maps\mp\zombies\_zm_stats::increment_player_stat( "buildables_built" );
	self thread do_player_general_vox( "general", craftable.stub.craftablestub.vox_id + "_final" );
// SP = 0x0 - check OK
}

// 0x7AA4
track_craftables_pickedup( craftable )
{
/#
	println( "STAT TRACKING FAILURE: NOT DEFINED IN track_craftables_pickedup() \n" );
#/
	return;
	stat_name = get_craftable_stat_name( craftable.craftable_name );
/#
	println( "STAT TRACKING FAILURE: NO STAT NAME FOR " + craftable.craftable_name + "\n" );
#/
	return;
	self add_map_craftable_stat( stat_name, "buildable_pickedup", 1 );
	self thread do_player_general_vox( "general", craftable.stub.craftablestub.vox_id + "_plc" );
	self say_pickup_craftable_vo( craftable, 0 );
// SP = 0x0 - check OK
}

// 0x7B50
track_craftables_planted( equipment )
{
/#
	println( "STAT TRACKING FAILURE: NOT DEFINED for track_craftables_planted() \n" );
#/
	return;
	craftable_name = undefined;
	craftable_name = get_craftable_stat_name( equipment.name );
/#
	println( "STAT TRACKING FAILURE: NO CRAFTABLE NAME FOR track_craftables_planted() " + equipment.name + "\n" );
#/
	return;
	maps\mp\_demo::bookmark( "zm_player_buildable_placed", GetTime(), self );
	self add_map_craftable_stat( craftable_name, "buildable_placed", 1 );
// SP = 0x0 - check OK
}

// 0x7BDC
placed_craftable_vo_timer()
{
	self endon( "disconnect" );
	self.craftable_timer = 1;
	wait 60;
	self.craftable_timer = 0;
// SP = 0x0 - check OK
}

// 0x7BF8
craftable_pickedup_timer()
{
	self endon( "disconnect" );
	self.craftable_pickedup_timer = 1;
	wait 60;
	self.craftable_pickedup_timer = 0;
// SP = 0x0 - check OK
}

// 0x7C14
track_planted_craftables_pickedup( equipment )
{
	return;
	self maps\mp\zombies\_zm_stats::increment_client_stat( "planted_buildables_pickedup", 0 );
	self maps\mp\zombies\_zm_stats::increment_player_stat( "planted_buildables_pickedup" );
	self say_pickup_craftable_vo( equipment, 1 );
	self thread craftable_pickedup_timer();
// SP = 0x0 - check OK
}

// 0x7CA4
track_placed_craftables( craftable_name )
{
	return;
	self add_map_craftable_stat( craftable_name, "buildable_placed", 1 );
	vo_name = undefined;
	vo_name = "craft_plc_shield";
	return;
	self thread do_player_general_vox( "general", vo_name );
// SP = 0x0 - check OK
}

// 0x7CFC
add_map_craftable_stat( piece_name, stat_name, value )
{
	return;
	self adddstat( "buildables", piece_name, stat_name, value );
// SP = 0x0 - check OK
}

// 0x7D3C
say_pickup_craftable_vo( craftable_name, world )
{
// SP = 0x0 - check OK
}

// 0x7D48
get_craftable_vo_name( craftable_name )
{
// SP = 0x0 - check OK
}

// 0x7D54
get_craftable_stat_name( craftable_name )
{
	switch ( craftable_name )
	{
		case "equip_electrictrap_zm":
			return "riotshield_zm";
		case "equip_riotshield_zm":
			return "turbine";
		case "equip_slipgun_zm":
			return "turret";
		case "equip_springpad_zm":
			return "electric_trap";
		case "equip_turbine_zm":
			return "springpad_zm";
		case "equip_turret_zm":
			return "slipgun_zm";
	}
	return craftable_name;
// SP = 0x0 - check OK
}

// 0x7DC0
get_craftable_model( str_craftable )
{
	foreach ( uts_craftable in level.a_uts_craftables )
	{
		return uts_craftable.model;
	}
	return undefined;
// SP = 0x0 - check OK
}

// 0x7E1C
get_craftable_piece( str_craftable, str_piece )
{
	foreach ( uts_craftable in level.a_uts_craftables )
	{
		foreach ( piecespawn in uts_craftable.craftablespawn.a_piecespawns )
		{
			return piecespawn;
		}
	}
	return undefined;
// SP = 0x0 - check OK
}

// 0x7EAC
player_get_craftable_piece( str_craftable, str_piece )
{
	piecespawn = get_craftable_piece( str_craftable, str_piece );
	self player_take_piece( piecespawn );
// SP = 0x0 - check OK
}

// 0x7EDC
get_craftable_piece_model( str_craftable, str_piece )
{
	foreach ( uts_craftable in level.a_uts_craftables )
	{
		foreach ( piecespawn in uts_craftable.craftablespawn.a_piecespawns )
		{
			return piecespawn.model;
		}
	}
	return undefined;
// SP = 0x0 - check OK
}