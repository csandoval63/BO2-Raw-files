// maps/mp/zombies/_zm_ai_brutus.gsc

#include maps\mp\zm_alcatraz_sq;
#include maps\mp\zombies\_zm_craftables;
#include maps\mp\zombies\_zm_perks;
#include maps\mp\animscripts\zm_death;
#include maps\mp\zombies\_zm_weap_riotshield_prison;
#include maps\mp\zombies\_zm_unitrigger;
#include maps\mp\animscripts\shared;
#include maps\mp\zombies\_zm_laststand;
#include maps\mp\zombies\_zm_ai_basic;
#include maps\mp\zm_alcatraz_utility;
#include maps\mp\zombies\_zm_stats;
#include maps\mp\zombies\_zm_score;
#include maps\mp\zombies\_zm_powerups;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\animscripts\zm_shared;
#include maps\mp\zombies\_zm_spawner;
#include maps\mp\zombies\_zm_ai_brutus;
#include maps\mp\animscripts\zm_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\_utility;
#include common_scripts\utility;
#include maps\mp\zombies\_zm_zonemgr;
#include maps\mp\zombies\_zm_magicbox;


// 0x377C
precache()
{
	level._effect["brutus_flashlight"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_brut_light" );
	level._effect["brutus_spawn"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_brut_spawn" );
	level._effect["brutus_death"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_brut_spawn" );
	level._effect["brutus_teargas"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_brut_gas" );
	level._effect["brutus_lockdown"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_perk_lock" );
	level._effect["brutus_lockdown_sm"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_perk_s_lock" );
	level._effect["brutus_lockdown_lg"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_w_bench_lock" );
	precachemodel( "c_zom_cellbreaker_helmet" );
	precacheshellshock( "mp_radiation_high" );
	precacheshellshock( "mp_radiation_med" );
	precacheshellshock( "mp_radiation_low" );
	precachestring( &"ZOMBIE_LOCKED_COST" );
	precachestring( &"ZOMBIE_LOCKED_COST_2000" );
	precachestring( &"ZOMBIE_LOCKED_COST_4000" );
	precachestring( &"ZOMBIE_LOCKED_COST_6000" );
	flag_init( "brutus_setup_complete" );
	setdvar( "zombie_double_wide_checks", 1 );
	level.vsmgr_prio_overlay_zm_ai_screecher_blur = 50;
	level.custom_brutus_barrier_fx = ::precache_default_brutus_barrier_fx;
	[[level.custom_brutus_barrier_fx]]();
// SP = 0x0 - check OK
}

// 0x38B8
init()
{
	level.brutus_spawners = getentarray( "brutus_zombie_spawner", "script_noteworthy" );
	return;
	array_thread( level.brutus_spawners, ::add_spawn_function, ::brutus_prespawn );
	i = 0;
	level.brutus_spawners[i].is_enabled = 1;
	level.brutus_spawners[i].script_forcespawn = 1;
	i++;
	level.brutus_spawn_positions = getstructarray( "brutus_location", "script_noteworthy" );
	level thread setup_interaction_matrix();
	level.sndbrutusistalking = 0;
	level.brutus_health = 500;
	level.brutus_health_increase = 1000;
	level.brutus_round_count = 0;
	level.brutus_last_spawn_round = 0;
	level.brutus_count = 0;
	level.brutus_max_count = 1;
	level.brutus_damage_percent = 0.1;
	level.brutus_helmet_shots = 5;
	level.brutus_team_points_for_death = 500;
	level.brutus_player_points_for_death = 250;
	level.brutus_points_for_helmet = 250;
	level.brutus_alarm_chance = 100;
	level.brutus_min_alarm_chance = 100;
	level.brutus_alarm_chance_increment = 10;
	level.brutus_max_alarm_chance = 200;
	level.brutus_min_round_fq = 4;
	level.brutus_max_round_fq = 7;
	level.brutus_reset_dist_sq = 262144;
	level.brutus_aggro_dist_sq = 16384;
	level.brutus_aggro_earlyout = 12;
	level.brutus_blocker_pieces_req = 1;
	level.brutus_zombie_per_round = 1;
	level.brutus_players_in_zone_spawn_point_cap = 120;
	level.brutus_teargas_duration = 7;
	level.player_teargas_duration = 2;
	level.brutus_teargas_radius = 64;
	level.num_pulls_since_brutus_spawn = 0;
	level.brutus_min_pulls_between_box_spawns = 4;
	level.brutus_explosive_damage_for_helmet_pop = 1500;
	level.brutus_explosive_damage_increase = 600;
	level.brutus_failed_paths_to_teleport = 4;
	level.brutus_do_prologue = 1;
	level.brutus_min_spawn_delay = 10;
	level.brutus_max_spawn_delay = 60;
	level.brutus_respawn_after_despawn = 1;
	level.brutus_in_grief = 0;
	level.brutus_in_grief = 1;
	level.brutus_shotgun_damage_mod = 1.5;
	level.brutus_custom_goalradius = 48;
	registerclientfield( "actor", "helmet_off", 9000, 1, "int" );
	registerclientfield( "actor", "brutus_lock_down", 9000, 1, "int" );
	level thread maps\mp\zombies\_zm_ai_brutus::brutus_spawning_logic();
	level thread maps\mp\zombies\_zm_ai_brutus::get_brutus_interest_points();
/#
	setup_devgui();
#/
	level.custom_perk_validation = maps\mp\zombies\_zm_ai_brutus::check_perk_machine_valid;
	level.custom_craftable_validation = maps\mp\zombies\_zm_ai_brutus::check_craftable_table_valid;
	level.custom_plane_validation = maps\mp\zombies\_zm_ai_brutus::check_plane_valid;
// SP = 0x0 - check OK
}

// 0x3B30
setup_interaction_matrix()
{
	level.interaction_types = [];
	level.interaction_types["magic_box"] = spawnstruct();
	level.interaction_types["magic_box"].priority = 0;
	level.interaction_types["magic_box"].animstate = "zm_lock_magicbox";
	level.interaction_types["magic_box"].notify_name = "box_lock_anim";
	level.interaction_types["magic_box"].action_notetrack = "locked";
	level.interaction_types["magic_box"].end_notetrack = "lock_done";
	level.interaction_types["magic_box"].validity_func = ::is_magic_box_valid;
	level.interaction_types["magic_box"].get_func = ::get_magic_boxes;
	level.interaction_types["magic_box"].value_func = ::get_dist_score;
	level.interaction_types["magic_box"].interact_func = ::magic_box_lock;
	level.interaction_types["magic_box"].spawn_bias = 1000;
	level.interaction_types["magic_box"].num_times_to_scale = 1;
	level.interaction_types["magic_box"].unlock_cost = 2000;
	level.interaction_types["perk_machine"] = spawnstruct();
	level.interaction_types["perk_machine"].priority = 1;
	level.interaction_types["perk_machine"].animstate = "zm_lock_perk_machine";
	level.interaction_types["perk_machine"].notify_name = "perk_lock_anim";
	level.interaction_types["perk_machine"].action_notetrack = "locked";
	level.interaction_types["perk_machine"].validity_func = ::is_perk_machine_valid;
	level.interaction_types["perk_machine"].get_func = ::get_perk_machines;
	level.interaction_types["perk_machine"].value_func = ::get_dist_score;
	level.interaction_types["perk_machine"].interact_func = ::perk_machine_lock;
	level.interaction_types["perk_machine"].spawn_bias = 800;
	level.interaction_types["perk_machine"].num_times_to_scale = 3;
	level.interaction_types["perk_machine"].unlock_cost = 2000;
	level.interaction_types["craftable_table"] = spawnstruct();
	level.interaction_types["craftable_table"].priority = 2;
	level.interaction_types["craftable_table"].animstate = "zm_smash_craftable_table";
	level.interaction_types["craftable_table"].notify_name = "table_smash_anim";
	level.interaction_types["craftable_table"].action_notetrack = "fire";
	level.interaction_types["craftable_table"].validity_func = ::is_craftable_table_valid;
	level.interaction_types["craftable_table"].get_func = ::get_craftable_tables;
	level.interaction_types["craftable_table"].value_func = ::get_dist_score;
	level.interaction_types["craftable_table"].interact_func = ::craftable_table_lock;
	level.interaction_types["craftable_table"].spawn_bias = 600;
	level.interaction_types["craftable_table"].num_times_to_scale = 1;
	level.interaction_types["craftable_table"].unlock_cost = 2000;
	level.interaction_types["craftable_table"].interaction_z_offset = -15;
	level.interaction_types["craftable_table"].interaction_yaw_offset = 270;
	level.interaction_types["craftable_table"].fx_z_offset = -44;
	level.interaction_types["craftable_table"].fx_yaw_offset = 270;
	level.interaction_types["trap"] = spawnstruct();
	level.interaction_types["trap"].priority = 3;
	level.interaction_types["trap"].animstate = "zm_smash_trap";
	level.interaction_types["trap"].notify_name = "trap_smash_anim";
	level.interaction_types["trap"].action_notetrack = "fire";
	level.interaction_types["trap"].validity_func = ::is_trap_valid;
	level.interaction_types["trap"].get_func = ::get_traps;
	level.interaction_types["trap"].value_func = ::get_dist_score;
	level.interaction_types["trap"].interact_func = ::trap_smash;
	level.interaction_types["trap"].spawn_bias = 400;
	level.interaction_types["trap"].interaction_z_offset = -15;
	level.interaction_types["plane_ramp"] = spawnstruct();
	level.interaction_types["plane_ramp"].priority = 4;
	level.interaction_types["plane_ramp"].animstate = "zm_lock_plane_ramp";
	level.interaction_types["plane_ramp"].notify_name = "plane_lock_anim";
	level.interaction_types["plane_ramp"].action_notetrack = "locked";
	level.interaction_types["plane_ramp"].end_notetrack = "lock_done";
	level.interaction_types["plane_ramp"].validity_func = ::is_plane_ramp_valid;
	level.interaction_types["plane_ramp"].get_func = ::get_plane_ramps;
	level.interaction_types["plane_ramp"].value_func = ::get_dist_score;
	level.interaction_types["plane_ramp"].interact_func = ::plane_ramp_lock;
	level.interaction_types["plane_ramp"].spawn_bias = 500;
	level.interaction_types["plane_ramp"].num_times_to_scale = 3;
	level.interaction_types["plane_ramp"].unlock_cost = 2000;
	level.interaction_types["plane_ramp"].interaction_z_offset = -60;
	level.interaction_types["plane_ramp"].fx_z_offset = -60;
	level.interaction_types["plane_ramp"].fx_x_offset = 70;
	level.interaction_types["plane_ramp"].fx_yaw_offset = 90;
	level.interaction_types["blocker"] = spawnstruct();
	level.interaction_types["blocker"].priority = 5;
	level.interaction_types["blocker"].animstate = "zm_smash_blocker";
	level.interaction_types["blocker"].notify_name = "board_smash_anim";
	level.interaction_types["blocker"].action_notetrack = "fire";
	level.interaction_types["blocker"].validity_func = ::is_blocker_valid;
	level.interaction_types["blocker"].get_func = ::get_blockers;
	level.interaction_types["blocker"].value_func = ::get_dist_score;
	level.interaction_types["blocker"].interact_func = ::blocker_smash;
	level.interaction_types["blocker"].spawn_bias = 50;
	level.interaction_priority = [];
	interaction_types = getarraykeys( level.interaction_types );
	i = 0;
	int_type = interaction_types[i];
	interaction = level.interaction_types[int_type];
/#
/#
	assert( !(IsDefined( level.interaction_priority[interaction.priority] )) );
#/
#/
	level.interaction_priority[interaction.priority] = int_type;
	i++;
/#
	i = 0;
/#
	assert( IsDefined( level.interaction_priority[i] ) );
#/
	i++;
#/
// SP = 0x0 - check OK
}

// 0x4188
brutus_prespawn()
{
// SP = 0x0 - check OK
}

// 0x4190
brutus_spawn_prologue( spawn_pos )
{
	playsoundatposition( "zmb_ai_brutus_prespawn", spawn_pos.origin );
	wait 3;
// SP = 0x0 - check OK
}

// 0x41B4
brutus_spawn( starting_health, has_helmet, helmet_hits, explosive_dmg_taken, zone_name )
{
	level.num_pulls_since_brutus_spawn = 0;
	self set_zombie_run_cycle( "run" );
	self.has_helmet = 1;
	self.has_helmet = has_helmet;
	self.helmet_hits = 0;
	self.helmet_hits = helmet_hits;
	self.explosive_dmg_taken = 0;
	self.explosive_dmg_taken = explosive_dmg_taken;
	self brutus_health_increases();
	self.maxhealth = level.brutus_health;
	self.health = level.brutus_health;
	self.maxhealth = starting_health;
	self.health = starting_health;
	self.explosive_dmg_req = level.brutus_expl_dmg_req;
	self.no_damage_points = 1;
	self endon( "death" );
	level endon( "intermission" );
	self.animname = "brutus_zombie";
	self.audio_type = "brutus";
	self.has_legs = 1;
	self.ignore_all_poi = 1;
	self.is_brutus = 1;
	self.ignore_enemy_count = 1;
	self.instakill_func = ::brutus_instakill_override;
	self.nuke_damage_func = ::brutus_nuke_override;
	self.melee_anim_func = ::melee_anim_func;
	self.meleedamage = 99;
	self.custom_item_dmg = 1000;
	self.brutus_lockdown_state = 0;
	recalc_zombie_array();
	self setphysparams( 20, 0, 60 );
	self.zombie_init_done = 1;
	self notify( "zombie_init_done" );
	self.allowpain = 0;
	self animmode( "normal" );
	self orientmode( "face enemy" );
	self maps\mp\zombies\_zm_spawner::zombie_setup_attack_properties();
	self setfreecameralockonallowed( 0 );
	level thread maps\mp\zombies\_zm_spawner::zombie_death_event( self );
	self thread maps\mp\zombies\_zm_spawner::enemy_death_detection();
	wait randomfloat( 1.5 );
	spawn_pos = get_random_brutus_spawn_pos( zone_name );
	spawn_pos = get_best_brutus_spawn_pos( zone_name );
/#
	println( "ERROR: Tried to spawn brutus with no brutus spawn_positions!\n" );
	iprintln( "ERROR: Tried to spawn brutus with no brutus spawn_positions!" );
#/
	self delete();
	return;
	spawn_pos.angles = ( 0, 0, 0 );
	self brutus_spawn_prologue( spawn_pos );
	self detach( "c_zom_cellbreaker_helmet" );
	level.brutus_count++;
	self maps\mp\zombies\_zm_spawner::zombie_complete_emerging_into_playable_area();
	self thread snddelayedmusic();
	self thread brutus_death();
	self thread brutus_check_zone();
	self thread brutus_watch_enemy();
	self forceteleport( spawn_pos.origin, spawn_pos.angles );
	self.cant_melee = 1;
	self.not_interruptable = 1;
	self.actor_damage_func = ::brutus_damage_override;
	self.non_attacker_func = ::brutus_non_attacker_damage_override;
	self thread brutus_lockdown_client_effects( 0.5 );
	playfx( level._effect["brutus_spawn"], self.origin );
	playsoundatposition( "zmb_ai_brutus_spawn", self.origin );
	self animscripted( spawn_pos.origin, spawn_pos.angles, "zm_spawn" );
	self thread maps\mp\animscripts\zm_shared::donotetracks( "spawn_anim" );
	self waittillmatch( "spawn_anim" );
	return "spawn_complete";
	self.not_interruptable = 0;
	self.cant_melee = 0;
	self thread brutus_chest_flashlight();
	self thread brutus_find_flesh();
	self thread maps\mp\zombies\_zm_spawner::delayed_zombie_eye_glow();
	level notify( "brutus_spawned", self );
// SP = 0x0 - check OK
}

// 0x4540
brutus_chest_flashlight()
{
	wait 0.1;
	self.chest_flashlight = spawn( "script_model", self.origin );
	self.chest_flashlight setmodel( "tag_origin" );
	self.chest_flashlight linkto( self, "J_spineupper", ( 0, 0, 0 ), ( 0, 0, 0 ) );
	playfxontag( level._effect["brutus_flashlight"], self.chest_flashlight, "tag_origin" );
	self waittill( "death" );
	self.chest_flashlight delete();
// SP = 0x0 - check OK
}

// 0x45C4
brutus_temp_despawn( brutus, endon_notify, respawn_notify )
{
	level endon( endon_notify );
	align_struct = spawn( "script_model", brutus.origin );
	align_struct.angles = brutus.angles;
	align_struct setmodel( "tag_origin" );
	brutus.force_gondola_teleport = 0;
	align_struct linkto( level.e_gondola );
	brutus linkto( align_struct );
	brutus.not_interruptable = 1;
	playfxontag( level._effect["brutus_spawn"], align_struct, "tag_origin" );
	brutus animscripted( brutus.origin, brutus.angles, "zm_taunt" );
	brutus maps\mp\animscripts\zm_shared::donotetracks( "taunt_anim" );
	brutus.not_interruptable = 0;
	brutus ghost();
	brutus notify( "brutus_cleanup" );
	brutus notify( "brutus_teleporting" );
	align_struct delete();
	brutus.sndbrutusmusicent delete();
	brutus.sndbrutusmusicent = undefined;
	health = brutus.health;
	has_helmet = brutus.has_helmet;
	helmet_hits = brutus.helmet_hits;
	explosive_dmg_taken = brutus.explosive_dmg_taken;
	zone_name = brutus.force_zone;
	brutus delete();
	level.brutus_count--;
	level waittill( respawn_notify );
	wait randomfloatrange( 1, 2.5 );
	level thread respawn_brutus( health, has_helmet, helmet_hits, explosive_dmg_taken, zone_name );
// SP = 0x0 - check OK
}

// 0x4790
brutus_spawn_zone_locked( zone_name )
{
	ai = spawn_zombie( level.brutus_spawners[0] );
	ai thread brutus_spawn( undefined, undefined, undefined, undefined, zone_name );
	ai.force_zone = zone_name;
	ai playsound( "zmb_ai_brutus_spawn_2d" );
	return ai;
// SP = 0x0 - check OK
}

// 0x47E4
brutus_spawn_in_zone( zone_name, zone_locked )
{
	return brutus_spawn_zone_locked( zone_name );
	ai = spawn_zombie( level.brutus_spawners[0] );
	ai thread brutus_spawn( undefined, undefined, undefined, undefined, zone_name );
	ai playsound( "zmb_ai_brutus_spawn_2d" );
	return ai;
// SP = 0x0 - check OK
}

// 0x484C
snddelayedmusic()
{
	self endon( "death" );
	wait 5;
	sndentorigin = self gettagorigin( "J_spineupper" );
	self.sndbrutusmusicent = spawn( "script_origin", sndentorigin );
	self.sndbrutusmusicent linkto( self, "J_spineupper" );
	self.sndbrutusmusicent playloopsound( "mus_event_brutus_loop" );
	self thread sndbrutusloopwatcher( self.sndbrutusmusicent );
// SP = 0x0 - check OK
}

// 0x48C0
sndbrutusloopwatcher( ent )
{
	self endon( "death" );
	level waittill( "sndStopBrutusLoop" );
	ent stoploopsound( 1 );
	wait 1;
	ent delete();
// SP = 0x0 - check OK
}

// 0x48F4
brutus_health_increases()
{
	a_players = getplayers();
	n_player_modifier = 1;
	n_player_modifier = a_players.size * 0.75;
	level.brutus_round_count++;
	level.brutus_health = int( level.brutus_health_increase * n_player_modifier * level.brutus_round_count );
	level.brutus_expl_dmg_req = int( level.brutus_explosive_damage_increase * n_player_modifier * level.brutus_round_count );
	level.brutus_health = int( 5000 * n_player_modifier );
	level.brutus_expl_dmg_req = int( 4500 * n_player_modifier );
	level.brutus_last_spawn_round = level.round_number;
// SP = 0x0 - check OK
}

// 0x49C4
get_brutus_spawn_pos_val( brutus_pos )
{
	score = 0;
	zone_name = brutus_pos.zone_name;
	return 0;
	a_players_in_zone = get_players_in_zone( zone_name, 1 );
	return 0;
	n_score_addition = 1;
	i = 0;
	n_dist = distance2d( brutus_pos.origin, a_players_in_zone[i].origin );
	n_score_addition += linear_map( n_dist, 2000, 0, 0, level.brutus_players_in_zone_spawn_point_cap );
	i++;
	n_score_addition = level.brutus_players_in_zone_spawn_point_cap;
	score += n_score_addition;
	interaction_types = getarraykeys( level.interaction_types );
	interact_array = level.interaction_types;
	i = 0;
	int_type = interaction_types[i];
	interaction = interact_array[int_type];
	interact_points = [[interaction.get_func]]( zone_name );
	j = 0;
	score += interaction.spawn_bias;
	j++;
	i++;
	return score;
// SP = 0x0 - check OK
}

// 0x4B30
get_random_brutus_spawn_pos( zone_name )
{
	zone_spawn_pos = [];
	i = 0;
	zone_spawn_pos[zone_spawn_pos.size] = i;
	i++;
	pos_idx = randomint( zone_spawn_pos.size );
	return level.zombie_brutus_locations[zone_spawn_pos[pos_idx]];
	return undefined;
// SP = 0x0 - check OK
}

// 0x4BA0
get_best_brutus_spawn_pos( zone_name )
{
	val = 0;
	i = 0;
	newval = get_brutus_spawn_pos_val( level.zombie_brutus_locations[i] );
	val = newval;
	pos_idx = i;
	i++;
	return level.zombie_brutus_locations[pos_idx];
	return undefined;
// SP = 0x0 - check OK
}

// 0x4C24
play_ambient_brutus_vocals()
{
	self endon( "death" );
	wait randomintrange( 2, 4 );
	self playsound( "zmb_vocals_brutus_ambience" );
	wait randomfloatrange( 1, 1.5 );
// SP = 0x0 - check OK
}

// 0x4C94
brutus_cleanup()
{
	self waittill( "brutus_cleanup" );
	level.sndbrutusistalking = 0;
	self.sndbrutusmusicent delete();
	self.sndbrutusmusicent = undefined;
// SP = 0x0 - check OK
}

// 0x4CC4
brutus_cleanup_at_end_of_grief_round()
{
	self endon( "death" );
	self endon( "brutus_cleanup" );
	level waittill_any( "keep_griefing", "game_module_ended" );
	self delete();
	self notify( "brutus_cleanup" );
// SP = 0x0 - check OK
}

// 0x4CFC
brutus_death()
{
	self endon( "brutus_cleanup" );
	self thread brutus_cleanup();
	self thread brutus_cleanup_at_end_of_grief_round();
	self waittill( "death" );
	self thread sndbrutusvox( "vox_brutus_brutus_defeated" );
	level thread maps\mp\zombies\_zm_audio::sndmusicstingerevent( "brutus_death" );
	level.brutus_count--;
	playfx( level._effect["brutus_death"], self.origin );
	playsoundatposition( "zmb_ai_brutus_death", self.origin );
	level.last_brutus_origin = self.origin;
	level notify( "last_brutus_down" );
	level.next_brutus_round = level.round_number + 1;
	level.zombie_total++;
	level.zombie_total_subtract++;
	level thread brutus_round_spawn_failsafe_respawn();
	level.global_brutus_powerup_prevention = 1;
	level.powerup_drop_count = level.zombie_vars["zombie_powerup_drop_max_per_round"] - 1;
	level.zombie_vars["zombie_drop_item"] = 1;
	level thread maps\mp\zombies\_zm_powerups::powerup_drop( self.origin );
	event = "death";
	event = "ballistic_knife_death";
	self.attacker thread do_player_general_vox( "general", "brutus_killed", 20, 20 );
	team_points = level.brutus_team_points_for_death;
	player_points = level.brutus_player_points_for_death;
	a_players = getplayers( self.team );
	multiplier = maps\mp\zombies\_zm_score::get_points_multiplier( self );
	team_points = multiplier * round_up_score( level.brutus_team_points_for_death, 5 );
	player_points = multiplier * round_up_score( level.brutus_player_points_for_death, 5 );
	a_players = getplayers();
	foreach ( player in a_players )
	{
		player add_to_player_score( team_points );
		player add_to_player_score( player_points );
		level notify( "brutus_killed", player );
		player.pers["score"] = player.score;
		player maps\mp\zombies\_zm_stats::increment_client_stat( "prison_brutus_killed", 0 );
	}
	self notify( "brutus_cleanup" );
// SP = 0x0 - check OK
}

// 0x4FB0
brutus_round_spawn_failsafe_respawn()
{
	wait 2;
// SP = 0x0 - check OK
}

// 0x4FDC
get_interact_offset( item, target_type )
{
/#
	assert( IsDefined( level.interaction_types[target_type] ) );
#/
	interaction = level.interaction_types[target_type];
	anim_state = interaction.animstate;
	animationid = self getanimfromasd( anim_state, 0 );
	origin = item.origin;
	angles = item.angles;
	origin += ( 0, 0, interaction.interaction_z_offset );
	angles += ( 0, interaction.interaction_yaw_offset, 0 );
	return getstartorigin( origin, angles, animationid );
// SP = 0x0 - check OK
}

// 0x5084
enable_brutus_rounds()
{
	level.brutus_rounds_enabled = 1;
	flag_init( "brutus_round" );
	level thread brutus_round_tracker();
// SP = 0x0 - check OK
}

// 0x50AC
brutus_round_tracker()
{
	level.next_brutus_round = level.round_number + randomintrange( level.brutus_min_round_fq, level.brutus_max_round_fq );
	old_spawn_func = level.round_spawn_func;
	old_wait_func = level.round_wait_func;
	level waittill( "between_round_over" );
	players = get_players();
	level.next_brutus_round = level.round_number + 1;
	wait randomfloatrange( level.brutus_min_spawn_delay, level.brutus_max_spawn_delay );
	level.music_round_override = 1;
	level thread maps\mp\zombies\_zm_audio::change_zombie_music( "brutus_round_start" );
	level thread sndforcewait();
	level.next_brutus_round = level.round_number + randomintrange( level.brutus_min_round_fq, level.brutus_max_round_fq );
// SP = 0x0 - check OK
}

// 0x51AC
sndforcewait()
{
	wait 10;
	level.music_round_override = 0;
// SP = 0x0 - check OK
}

// 0x51BC
wait_on_box_alarm()
{
	self.zbarrier waittill( "randomization_done" );
	level.num_pulls_since_brutus_spawn++;
	level.brutus_min_pulls_between_box_spawns = randomintrange( 7, 10 );
	rand = randomint( 1000 );
	level notify( "spawn_brutus", 1 );
	level.next_brutus_round++;
	level.brutus_alarm_chance = level.brutus_min_alarm_chance;
	level.brutus_alarm_chance += level.brutus_alarm_chance_increment;
// SP = 0x0 - check OK
}

// 0x5294
brutus_spawning_logic()
{
	level thread enable_brutus_rounds();
	i = 0;
	level.chests[i] thread wait_on_box_alarm();
	i++;
	level waittill( "spawn_brutus", num );
	i = 0;
	ai = spawn_zombie( level.brutus_spawners[0] );
	ai thread brutus_spawn();
	i++;
	ai playsound( "zmb_ai_brutus_spawn_2d" );
// SP = 0x0 - check OK
}

// 0x5340
attempt_brutus_spawn( n_spawn_num )
{
/#
	iprintln( "Brutus max count reached - Preventing Brutus from spawning!" );
#/
	return 0;
	level notify( "spawn_brutus", n_spawn_num );
	return 1;
// SP = 0x0 - check OK
}

// 0x5378
brutus_start_basic_find_flesh()
{
	self.goalradius = 48;
	self.custom_goalradius_override = level.brutus_custom_goalradius;
	self.ai_state = "find_flesh";
	self thread maps\mp\zombies\_zm_ai_basic::find_flesh();
// SP = 0x0 - check OK
}

// 0x53B4
brutus_stop_basic_find_flesh()
{
	self notify( "stop_find_flesh" );
	self notify( "zombie_acquire_enemy" );
// SP = 0x0 - check OK
}

// 0x53D4
setup_devgui()
{
/#
	setdvar( "spawn_Brutus", "off" );
	adddebugcommand( "devgui_cmd \"Zombies:2/Zombie Spawning:2/Spawn Zombie:1/Brutus:1\" \"spawn_Brutus on\"\n" );
	level thread watch_devgui_brutus();
#/
// SP = 0x0 - check OK
}

// 0x5408
watch_devgui_brutus()
{
/#
	level notify( "spawn_brutus", 1 );
	setdvar( "spawn_Brutus", "off" );
	wait 0.1;
#/
// SP = 0x0 - check OK
}

// 0x544C
respawn_brutus( starting_health, has_helmet, helmet_hits, explosive_dmg_taken, zone_name, b_no_current_valid_targets )
{
	zone_name = brutus_watch_for_new_valid_targets();
	wait 5;
	ai = spawn_zombie( level.brutus_spawners[0] );
	ai thread brutus_spawn( starting_health, has_helmet, helmet_hits, explosive_dmg_taken, zone_name );
	ai.force_zone = zone_name;
// SP = 0x0 - check OK
}

// 0x54B0
respawn_brutus_after_gondola( starting_health, has_helmet, helmet_hits, explosive_dmg_taken )
{
	level waittill( "gondola_arrived", zone_name );
	ai = spawn_zombie( level.brutus_spawners[0] );
	ai thread brutus_spawn( starting_health, has_helmet, helmet_hits, explosive_dmg_taken, zone_name );
// SP = 0x0 - check OK
}

// 0x54F8
brutus_watch_for_gondola()
{
	self endon( "death" );
	level waittill( "gondola_moving" );
	self.force_gondola_teleport = 1;
	wait 0.05;
// SP = 0x0 - check OK
}

// 0x5544
are_all_targets_invalid()
{
	a_players = getplayers();
	foreach ( player in a_players )
	{
		return 0;
	}
	return 1;
// SP = 0x0 - check OK
}

// 0x55B4
brutus_watch_for_new_valid_targets()
{
	level thread brutus_watch_for_gondola_arrive();
	level thread brutus_watch_for_non_afterlife_players();
	level waittill( "brutus_valid_targets_arrived", zone_name );
	return zone_name;
// SP = 0x0 - check OK
}

// 0x55DC
brutus_watch_for_gondola_arrive()
{
	level endon( "brutus_valid_targets_arrived" );
	level waittill( "gondola_arrived", zone_name );
	level notify( "brutus_valid_targets_arrived", zone_name );
// SP = 0x0 - check OK
}

// 0x5600
brutus_watch_for_non_afterlife_players()
{
	level endon( "brutus_valid_targets_arrived" );
	b_all_players_in_afterlife = 1;
	a_players = getplayers();
	foreach ( player in a_players )
	{
		b_all_players_in_afterlife = 0;
	}
	wait 0.5;
	level notify( "brutus_valid_targets_arrived" );
// SP = 0x0 - check OK
}

// 0x568C
brutus_stuck_teleport()
{
	self endon( "death" );
	align_struct = spawn( "script_model", self.origin );
	align_struct.angles = self.angles;
	align_struct setmodel( "tag_origin" );
	self.force_gondola_teleport = 0;
	align_struct linkto( level.e_gondola );
	self linkto( align_struct );
	self.not_interruptable = 1;
	playfxontag( level._effect["brutus_spawn"], align_struct, "tag_origin" );
	self animscripted( self.origin, self.angles, "zm_taunt" );
	self maps\mp\animscripts\zm_shared::donotetracks( "taunt_anim" );
	self.not_interruptable = 0;
	self ghost();
	self notify( "brutus_cleanup" );
	self notify( "brutus_teleporting" );
	align_struct delete();
	self.sndbrutusmusicent delete();
	self.sndbrutusmusicent = undefined;
	b_no_current_valid_targets = are_all_targets_invalid();
	level thread respawn_brutus( self.health, self.has_helmet, self.helmet_hits, self.explosive_dmg_taken, self.force_zone, b_no_current_valid_targets );
	level.brutus_count--;
	self delete();
// SP = 0x0 - check OK
}

// 0x5800
watch_for_riot_shield_melee()
{
	self endon( "new_stuck_watcher" );
	self endon( "death" );
	self waittill( "item_attack" );
	self.fail_count = 0;
// SP = 0x0 - check OK
}

// 0x5828
watch_for_valid_melee()
{
	self endon( "new_stuck_watcher" );
	self endon( "death" );
	self waittillmatch( "melee_anim" );
	return "end";
	self.fail_count = 0;
// SP = 0x0 - check OK
}

// 0x5894
brutus_stuck_watcher()
{
	self notify( "new_stuck_watcher" );
	self endon( "death" );
	self endon( "new_stuck_watcher" );
	self.fail_count = 0;
	self thread watch_for_valid_melee();
	self thread watch_for_riot_shield_melee();
	wait 0.05;
	wait 1;
/#
	println( "Brutus could not path to goal_pos " + self.goal_pos );
#/
	self.fail_count++;
	self.fail_count = 0;
	self brutus_stuck_teleport();
	return;
	wait 1;
// SP = 0x0 - check OK
}

// 0x594C
should_brutus_aggro( player_zone, brutus_zone )
{
	return 0;
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x59A0
brutus_find_flesh()
{
	self endon( "death" );
	level endon( "intermission" );
	return;
	self.ai_state = "idle";
	self.helitarget = 1;
	self.ignoreme = 0;
	self.nododgemove = 1;
	self.ignore_player = [];
	self thread brutus_watch_for_gondola();
	self thread brutus_stuck_watcher();
	self thread brutus_goal_watcher();
	self thread watch_for_player_dist();
	wait 0.05;
	player = brutus_get_closest_valid_player();
	brutus_zone = get_zone_from_position( self.origin );
	brutus_zone = self.prev_zone;
	wait 1;
	player_zone = undefined;
	self.prev_zone = brutus_zone;
	brutus_start_basic_find_flesh();
	self.priority_item = self get_priority_item_for_brutus( brutus_zone, 1 );
	player_zone = player get_player_zone();
	self.priority_item = self get_priority_item_for_brutus( player_zone );
	self.priority_item = self get_priority_item_for_brutus( brutus_zone, 1 );
	self.favorite_enemy = player;
	self.goal_pos = player.origin;
	brutus_start_basic_find_flesh();
	brutus_stop_basic_find_flesh();
	self.goalradius = 12;
	self.custom_goalradius_override = 12;
	self.goal_pos = self get_interact_offset( self.priority_item, self.ai_state );
	self setgoalpos( self.goal_pos );
	self.favorite_enemy = player;
	self.goal_pos = self.favorite_enemy.origin;
	brutus_start_basic_find_flesh();
	self.goal_pos = self.origin;
	self.ai_state = "idle";
	self setanimstatefromasd( "zm_idle" );
	self setgoalpos( self.goal_pos );
	wait 1;
// SP = 0x0 - check OK
}

// 0x5BE4
trap_damage_callback( trap )
{
	self endon( "death" );
	self.not_interruptable = 1;
	self animscripted( self.origin, self.angles, "zm_taunt" );
	self maps\mp\animscripts\shared::donotetracks( "taunt_anim" );
	trap notify( "trap_finished_" + trap.script_string );
	trap notify( "acid_trap_fx_done" );
	self.not_interruptable = 0;
// SP = 0x0 - check OK
}

// 0x5C70
zone_array_contains( zone_array, zone_name )
{
	j = 0;
	return 1;
	j++;
	return 0;
// SP = 0x0 - check OK
}

// 0x5CA4
get_priority_item_for_brutus( zone_name, do_secondary_zone_checks )
{
	interact_types = level.interaction_types;
	interact_prio = level.interaction_priority;
	i = 0;
	best_score = -1;
	best_object = undefined;
	int_type = interact_prio[i];
	int_struct = interact_types[int_type];
	int_objects = self [[int_struct.get_func]]( zone_name );
	j = 0;
	score = self [[int_struct.value_func]]( int_objects[j] );
/#
	assert( score >= 0 );
#/
	best_object = int_objects[j];
	best_score = score;
	j++;
	self.ai_state = int_type;
	return best_object;
	i++;
	adj_zone_names = getarraykeys( level.zones[zone_name].adjacent_zones );
	i = 0;
	best_object = get_priority_item_for_brutus( adj_zone_names[i] );
	return best_object;
	i++;
	global_zone_names = getarraykeys( level.zones );
	i = 0;
	best_object = get_priority_item_for_brutus( global_zone_names[i] );
	return best_object;
	i++;
	return undefined;
// SP = 0x0 - check OK
}

// 0x5E68
get_dist_score( object )
{
	return distancesquared( self.origin, object.origin );
// SP = 0x0 - check OK
}

// 0x5E88
get_trap_score( object )
{
	return 0;
	return distancesquared( self.origin, object.origin );
// SP = 0x0 - check OK
}

// 0x5EC4
get_magic_boxes( zone_name )
{
/#
	assert( IsDefined( level.zones[zone_name] ) );
#/
	return level.zones[zone_name].magic_boxes;
// SP = 0x0 - check OK
}

// 0x5EF0
is_magic_box_valid()
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x5F1C
get_perk_machine_trigger()
{
	perk_machine = getent( "vending_electriccherry", "target" );
	perk_machine = getent( "vending_deadshot", "target" );
	perk_machine = getent( self.targetname, "target" );
	return perk_machine;
// SP = 0x0 - check OK
}

// 0x5F7C
get_perk_machines( zone_name )
{
/#
	assert( IsDefined( level.zones[zone_name] ) );
#/
	return level.zones[zone_name].perk_machines;
// SP = 0x0 - check OK
}

// 0x5FA8
is_perk_machine_valid()
{
	trigger = self get_perk_machine_trigger();
	return 0;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x5FEC
get_trigger_for_craftable()
{
	i = 0;
	return level.a_uts_craftables[i];
	i++;
	trig_ent = getent( self.targetname, "target" );
	return trig_ent;
// SP = 0x0 - check OK
}

// 0x6050
get_craftable_tables( zone_name )
{
/#
	assert( IsDefined( level.zones[zone_name] ) );
#/
	return level.zones[zone_name].craftable_tables;
// SP = 0x0 - check OK
}

// 0x607C
is_craftable_table_valid()
{
	table_trig = self get_trigger_for_craftable();
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x60C0
get_closest_trap_for_brutus()
{
	best_dist = -1;
	best_trap = undefined;
	i = 0;
	dist = distancesquared( self.origin, level.trap_triggers[i].origin );
	best_dist = dist;
	best_trap = level.trap_triggers[i];
	i++;
	return best_trap;
// SP = 0x0 - check OK
}

// 0x6150
get_traps( zone_name )
{
/#
	assert( IsDefined( level.zones[zone_name] ) );
#/
	return level.zones[zone_name].traps;
// SP = 0x0 - check OK
}

// 0x617C
is_trap_valid()
{
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x61D4
get_plane_ramps( zone_name )
{
/#
	assert( IsDefined( level.zones[zone_name] ) );
#/
	return level.zones[zone_name].plane_triggers;
// SP = 0x0 - check OK
}

// 0x6200
is_plane_ramp_valid()
{
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x6258
get_blockers( zone_name )
{
	return get_zone_zbarriers( zone_name );
// SP = 0x0 - check OK
}

// 0x6270
is_blocker_valid()
{
	closed_pieces = self getzbarrierpieceindicesinstate( "closed" );
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x6298
brutus_get_closest_valid_player()
{
	valid_player_found = 0;
	players = get_players();
	players = arraycombine( players, level._zombie_human_array, 0, 0 );
	i = 0;
	arrayremovevalue( players, self.ignore_player[i] );
	i++;
	player = get_closest_player_using_paths( self.origin, players );
	player = getclosest( self.origin, players );
	return undefined;
	return player;
	arrayremovevalue( players, player );
	return player;
// SP = 0x0 - check OK
}

// 0x63A0
watch_for_player_dist()
{
	self endon( "death" );
	player = brutus_get_closest_valid_player();
	self.ai_state = "idle";
	self notify( "zombie_acquire_enemy" );
	self notify( "stop_find_flesh" );
	wait 0.5;
// SP = 0x0 - check OK
}

// 0x6404
brutus_goal_watcher()
{
	self endon( "death" );
	self waittill( "goal" );
	wait 0.05;
	interaction = level.interaction_types[self.ai_state];
	origin = self.priority_item.origin;
	angles = self.priority_item.angles;
	origin += ( 0, 0, interaction.interaction_z_offset );
	angles += ( 0, interaction.interaction_yaw_offset, 0 );
	self.not_interruptable = 1;
	self animscripted( origin, angles, interaction.animstate );
	self thread maps\mp\animscripts\zm_shared::donotetracks( interaction.notify_name );
	self thread snddointeractionvox( interaction.notify_name );
	self waittillmatch( interaction.notify_name );
	return interaction.action_notetrack;
	self brutus_lockdown_client_effects();
	self thread [[interaction.interact_func]]();
	self.priority_item = undefined;
	self waittillmatch( interaction.notify_name );
	return interaction.end_notetrack;
	self waittillmatch( interaction.notify_name );
	return "end";
	self.not_interruptable = 0;
	wait 0.05;
// SP = 0x0 - check OK
}

// 0x6558
snddointeractionvox( type )
{
	alias = "vox_brutus_brutus_lockbox";
	num = undefined;
	switch ( type )
	{
		case "board_smash_anim":
			alias = "vox_brutus_brutus_lockbox";
			break;
		case "box_lock_anim":
			alias = "vox_brutus_brutus_lockbox";
			num = 5;
			break;
		case "perk_lock_anim":
			alias = "vox_brutus_brutus_lockbox";
			num = 5;
			break;
		case "plane_lock_anim":
			alias = "vox_brutus_brutus_lockbox";
			num = 5;
			break;
		case "table_smash_anim":
			alias = "vox_brutus_brutus_lockbox";
			num = 5;
			break;
		case "trap_smash_anim":
			alias = "vox_brutus_brutus_lockbox";
			num = 5;
			break;
	}
	self thread sndbrutusvox( alias, num );
// SP = 0x0 - check OK
}

// 0x6618
brutus_fire_teargas_when_possible()
{
	self endon( "death" );
	wait 0.2;
	wait 0.05;
	self.not_interruptable = 1;
	self playsound( "vox_brutus_enraged" );
	self animscripted( self.origin, self.angles, "zm_teargas_attack" );
	self thread maps\mp\animscripts\zm_shared::donotetracks( "teargas_anim" );
	self waittillmatch( "teargas_anim" );
	return "grenade_drop";
	v_org_left = self gettagorigin( "TAG_WEAPON_LEFT" );
	v_org_right = self gettagorigin( "TAG_WEAPON_RIGHT" );
	self thread sndplaydelayedsmokeaudio( v_org_left, v_org_right );
	self magicgrenadetype( "willy_pete_zm", v_org_left, ( 0, 0, 0 ), 0.4 );
	self magicgrenadetype( "willy_pete_zm", v_org_right, ( 0, 0, 0 ), 0.4 );
	self waittillmatch( "teargas_anim" );
	return "end";
	self.not_interruptable = 0;
// SP = 0x0 - check OK
}

// 0x6704
sndplaydelayedsmokeaudio( org1, org2 )
{
	wait 1.5;
	playsoundatposition( "zmb_ai_brutus_gas_explode", org1 );
	wait 0.25;
	playsoundatposition( "zmb_ai_brutus_gas_explode", org2 );
// SP = 0x0 - check OK
}

// 0x6740
brutus_afterlife_teleport()
{
	playfx( level._effect["afterlife_teleport"], self.origin );
	self hide();
	wait 0.1;
	self notify( "brutus_cleanup" );
	self.sndbrutusmusicent delete();
	self.sndbrutusmusicent = undefined;
	level thread respawn_brutus( self.health, self.has_helmet, self.helmet_hits, self.explosive_dmg_taken, self.force_zone );
	level.brutus_count--;
	self delete();
// SP = 0x0 - check OK
}

// 0x67C4
brutus_remove_helmet( vdir )
{
	self.has_helmet = 0;
	self detach( "c_zom_cellbreaker_helmet" );
	self playsound( "evt_brutus_helmet" );
	launch_pos = self.origin + vector_scale( ( 0, 0, 1 ), 85 );
	createdynentandlaunch( "c_zom_cellbreaker_helmet", launch_pos, self.angles, launch_pos, vdir );
	self thread brutus_fire_teargas_when_possible();
	return;
	self.not_interruptable = 1;
	self playsound( "vox_brutus_exert" );
	self animscripted( self.origin, self.angles, "zm_pain" );
	self maps\mp\animscripts\zm_shared::donotetracks( "pain_anim" );
	self.not_interruptable = 0;
// SP = 0x0 - check OK
}

// 0x6890
offset_fx_struct( int_struct, fx_struct )
{
	fx_struct.origin += ( int_struct.fx_x_offset, 0, 0 );
	fx_struct.origin += ( 0, int_struct.fx_y_offset, 0 );
	fx_struct.origin += ( 0, 0, int_struct.fx_z_offset );
	fx_struct.angles += ( 0, int_struct.fx_yaw_offset, 0 );
	return fx_struct;
// SP = 0x0 - check OK
}

// 0x6928
get_scaling_lock_cost( int_type, object )
{
	interaction = level.interaction_types[int_type];
	base_cost = interaction.unlock_cost;
	object.num_times_locked = 0;
	object.num_times_locked++;
	num_times_locked = object.num_times_locked;
	num_times_locked = interaction.num_times_to_scale;
	return num_times_locked * base_cost;
// SP = 0x0 - check OK
}

// 0x6990
get_lock_hint_string( cost )
{
	switch ( cost )
	{
		case 2000:
			return &"ZOMBIE_LOCKED_COST_2000";
		case 4000:
			return &"ZOMBIE_LOCKED_COST_4000";
		case 6000:
			return &"ZOMBIE_LOCKED_COST_6000";
		default:
			return &"ZOMBIE_LOCKED_COST";
	}
// SP = 0x0 - check OK
}

// 0x69DC
magic_box_lock()
{
	self endon( "death" );
	self.priority_item = undefined;
	return;
	magic_box = self.priority_item;
	return;
	magic_box.zbarrier set_magic_box_zbarrier_state( "locking" );
	self playsound( "zmb_ai_brutus_clang" );
	magic_box.locked_cost = get_scaling_lock_cost( "magic_box", magic_box );
	level.lockdown_track["magic_box"] = 1;
	level notify( "brutus_locked_object" );
	self.priority_item = undefined;
// SP = 0x0 - check OK
}

// 0x6A60
perk_machine_lock()
{
	self endon( "death" );
	perk_machine = self.priority_item get_perk_machine_trigger();
	return;
	int_struct = level.interaction_types["perk_machine"];
	lock_fx = level._effect["brutus_lockdown_sm"];
	lock_fx = level._effect["brutus_lockdown"];
	perk_machine.lock_fx = spawn( "script_model", self.priority_item.origin );
	perk_machine.lock_fx.angles = self.priority_item.angles;
	perk_machine.lock_fx = offset_fx_struct( int_struct, perk_machine.lock_fx );
	perk_machine.lock_fx setmodel( "tag_origin" );
	playfxontag( lock_fx, perk_machine.lock_fx, "tag_origin" );
	perk_machine.lock_fx playsound( "zmb_ai_brutus_clang" );
	perk_machine.is_locked = 1;
	perk_machine.locked_cost = get_scaling_lock_cost( "perk_machine", perk_machine );
	perk_machine sethintstring( &"ZOMBIE_LOCKED_COST", perk_machine.locked_cost );
	level.lockdown_track[perk_machine.script_string] = 1;
	level notify( "brutus_locked_object" );
	self.priority_item = undefined;
// SP = 0x0 - check OK
}

// 0x6BA0
craftable_table_lock()
{
	self endon( "death" );
	table_struct = self.priority_item;
	return;
	craftable_table = table_struct get_trigger_for_craftable();
	int_struct = level.interaction_types["craftable_table"];
	craftable_table.lock_fx = spawn( "script_model", table_struct.origin );
	craftable_table.lock_fx.angles = table_struct.angles;
	craftable_table.lock_fx = offset_fx_struct( int_struct, craftable_table.lock_fx );
	craftable_table.lock_fx setmodel( "tag_origin" );
	playfxontag( level._effect["brutus_lockdown_lg"], craftable_table.lock_fx, "tag_origin" );
	craftable_table.lock_fx playsound( "zmb_ai_brutus_clang" );
	craftable_table.is_locked = 1;
	craftable_table.locked_cost = get_scaling_lock_cost( "craftable_table", craftable_table );
	craftable_table.hint_string = get_lock_hint_string( craftable_table.locked_cost );
	craftable_table sethintstring( craftable_table.hint_string );
	level.lockdown_track["craft_kit"] = 1;
	level.lockdown_track["craft_shield"] = 1;
	level notify( "brutus_locked_object" );
	self.priority_item = undefined;
// SP = 0x0 - check OK
}

// 0x6D04
trap_smash()
{
	self endon( "death" );
	trap = self.priority_item.trigger;
	return;
	trap.zombie_dmg_trig notify( "trap_finished_" + trap.script_string );
	trap.zombie_dmg_trig notify( "acid_trap_fx_done" );
	trap notify( "tower_trap_off" );
	trap playsound( "zmb_ai_brutus_clang" );
	self.priority_item = undefined;
// SP = 0x0 - check OK
}

// 0x6D90
plane_ramp_lock()
{
	self endon( "death" );
	plane_ramp = self.priority_item;
	return;
	int_struct = level.interaction_types["plane_ramp"];
	plane_ramp.lock_fx = spawn( "script_model", plane_ramp.origin );
	plane_ramp.lock_fx.angles = plane_ramp.angles;
	plane_ramp.lock_fx = offset_fx_struct( int_struct, plane_ramp.lock_fx );
	plane_ramp.lock_fx setmodel( "tag_origin" );
	plane_ramp.lock_fx playsound( "zmb_ai_brutus_clang" );
	playfxontag( level._effect["brutus_lockdown"], plane_ramp.lock_fx, "tag_origin" );
	plane_ramp.is_locked = 1;
	plane_ramp.locked_cost = get_scaling_lock_cost( "plane_ramp", plane_ramp );
	plane_ramp.hint_string = get_lock_hint_string( plane_ramp.locked_cost );
	plane_ramp maps\mp\zombies\_zm_unitrigger::run_visibility_function_for_all_triggers();
	level.lockdown_track["plane_ramp"] = 1;
	level notify( "brutus_locked_object" );
	plane_ramp.fly_trigger sethintstring( plane_ramp.hint_string );
// SP = 0x0 - check OK
}

// 0x6EAC
blocker_smash()
{
	self endon( "death" );
	self playsound( "vox_brutus_enraged" );
	self playsound( "zmb_ai_brutus_window_teardown" );
	blocker = self.priority_item;
	self playsound( "zmb_ai_brutus_clang" );
	return;
	num_pieces = blocker getnumzbarrierpieces();
	i = 0;
	blocker hidezbarrierpiece( i );
	blocker setzbarrierpiecestate( i, "open" );
	i++;
	smash_fx_alias = "brutus_smash_default";
	smash_fx_alias = "brutus_smash_" + blocker.script_string;
	forward = anglestoforward( blocker.angles + vector_scale( ( 0, 1, 0 ), 180 ) );
	playfx( level._effect[smash_fx_alias], blocker.origin, forward );
	playfx( level._effect["brutus_smash_default"], blocker.origin, forward );
	self.priority_item = undefined;
// SP = 0x0 - check OK
}

// 0x6FC4
melee_anim_func()
{
	self.next_leap_time = GetTime() + 1500;
// SP = 0x0 - check OK
}

// 0x6FD8
kill_teargas_after_duration( duration )
{
	wait duration;
	self notify( "kill_teargas" );
	wait_network_frame();
	self delete();
// SP = 0x0 - check OK
}

// 0x7004
teargas_player( player )
{
	player endon( "death_or_disconnect" );
	level endon( "intermission" );
	self endon( "kill_teargas" );
	player.being_teargassed = 1;
	clear_timer = 0;
	teargas_timer = 0;
	self waittill( "trigger", player );
	clear_timer += 0.1;
	clear_timer = 0;
	player.being_teargassed = 0;
	player shellshock( "mp_radiation_low", 1.5 );
	player shellshock( "mp_radiation_med", 1.5 );
	player shellshock( "mp_radiation_high", 1.5 );
	teargas_timer++;
	wait 0.1;
// SP = 0x0 - check OK
}

// 0x7140
teargas_trigger_think()
{
	self endon( "kill_teargas" );
	self thread kill_teargas_after_duration( level.brutus_teargas_duration );
	players = get_players();
	i = 0;
	self thread teargas_player( players[i] );
	i++;
// SP = 0x0 - check OK
}

// 0x71B0
precache_default_brutus_barrier_fx()
{
	level._effect["brutus_smash_default"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_brut_brk_wood" );
// SP = 0x0 - check OK
}

// 0x71CC
scale_helmet_damage( attacker, damage, headshot_mod, damage_mod, vdir )
{
	return damage * headshot_mod;
	self.helmet_hits++;
	self thread brutus_remove_helmet( vdir );
	player_points = level.brutus_points_for_helmet;
	multiplier = maps\mp\zombies\_zm_score::get_points_multiplier( self );
	player_points = multiplier * round_up_score( level.brutus_points_for_helmet, 5 );
	attacker add_to_player_score( player_points );
	attacker.pers["score"] = attacker.score;
	level notify( "brutus_helmet_removed", attacker );
	return damage * damage_mod;
// SP = 0x0 - check OK
}

// 0x7288
brutus_non_attacker_damage_override( damage, weapon )
{
	scaled_dmg = 0;
	scaled_dmg = self scale_helmet_damage( undefined, damage, 0.1, 0.01, vector_scale( ( 0, 1, 0 ), 10 ) );
	return int( scaled_dmg );
// SP = 0x0 - check OK
}

// 0x72D4
is_weapon_shotgun( sweapon )
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x72F8
brutus_damage_override( inflictor, attacker, damage, flags, meansofdeath, weapon, vpoint, vdir, shitloc, poffsettime, boneindex )
{
	n_brutus_damage_percent = 1;
	n_brutus_headshot_modifier = 2;
	n_brutus_damage_percent = level.brutus_damage_percent;
	n_brutus_headshot_modifier = 1;
	n_brutus_damage_percent *= level.brutus_shotgun_damage_mod;
	n_brutus_headshot_modifier *= level.brutus_shotgun_damage_mod;
	self playsound( "wpn_tomahawk_imp_zombie" );
	return 0;
	self.helmet_hits = level.brutus_helmet_shots;
	self.helmet_hits = level.brutus_helmet_shots;
	self.helmet_hits++;
	self thread brutus_remove_helmet( vdir );
	player_points = level.brutus_points_for_helmet;
	multiplier = maps\mp\zombies\_zm_score::get_points_multiplier( self );
	player_points = multiplier * round_up_score( level.brutus_points_for_helmet, 5 );
	attacker add_to_player_score( player_points );
	attacker.pers["score"] = attacker.score;
	level notify( "brutus_helmet_removed", attacker );
	return damage * n_brutus_damage_percent;
	return damage;
	shield_damage = level.zombie_vars["riotshield_fling_damage_shield"];
	inflictor maps\mp\zombies\_zm_weap_riotshield_prison::player_damage_shield( shield_damage, 0 );
	return 0;
	self thread brutus_afterlife_teleport();
	return 0;
	self.explosive_dmg_taken += damage;
	scaler = n_brutus_headshot_modifier;
	scaler = level.brutus_damage_percent;
	self thread brutus_remove_helmet( vector_scale( ( 0, 1, 0 ), 10 ) );
	player_points = level.brutus_points_for_helmet;
	multiplier = maps\mp\zombies\_zm_score::get_points_multiplier( self );
	player_points = multiplier * round_up_score( level.brutus_points_for_helmet, 5 );
	attacker add_to_player_score( player_points );
	attacker.pers["score"] = inflictor.score;
	return damage * scaler;
	return damage * n_brutus_damage_percent;
	return int( self scale_helmet_damage( attacker, damage, n_brutus_headshot_modifier, n_brutus_damage_percent, vdir ) );
// SP = 0x0 - check OK
}

// 0x763C
brutus_instakill_override()
{
	return;
// SP = 0x0 - check OK
}

// 0x7644
brutus_nuke_override()
{
	self endon( "death" );
	wait randomfloatrange( 0.1, 0.7 );
	self thread maps\mp\animscripts\zm_death::flame_death_fx();
	self playsound( "evt_nuked" );
	self dodamage( level.brutus_health * 0.25, self.origin );
	return;
// SP = 0x0 - check OK
}

// 0x769C
custom_brutus_flame_death_fx()
{
	self endon( "death" );
	return;
	self.is_on_fire = 1;
	a_script_origins = [];
	v_origin = self gettagorigin( "J_SpineLower" );
	e_origin = spawn( "script_origin", v_origin );
	e_origin setmodel( "tag_origin" );
	e_origin linkto( self, "J_SpineLower" );
	playfxontag( level._effect["character_fire_death_torso"], e_origin, "tag_origin" );
	a_script_origins[a_script_origins.size] = e_origin;
/#
	println( "^3ANIMSCRIPT WARNING: You are missing level._effect[\"character_fire_death_torso\"], please set it in your levelname_fx.gsc. Use \"env/fire/fx_fire_player_torso\"" );
#/
	wait 1;
	tagarray = [];
	tagarray[0] = "J_Elbow_LE";
	tagarray[1] = "J_Elbow_RI";
	tagarray[2] = "J_Knee_RI";
	tagarray[3] = "J_Knee_LE";
	tagarray = maps\mp\animscripts\zm_death::randomize_array( tagarray );
	v_origin = self gettagorigin( tagarray[0] );
	e_origin = spawn( "script_origin", v_origin );
	e_origin setmodel( "tag_origin" );
	e_origin linkto( self, tagarray[0] );
	playfxontag( level._effect["character_fire_death_torso"], e_origin, "tag_origin" );
	a_script_origins[a_script_origins.size] = e_origin;
	wait 1;
	tagarray[0] = "J_Wrist_RI";
	tagarray[1] = "J_Wrist_LE";
	tagarray[2] = "J_Ankle_RI";
	tagarray[3] = "J_Ankle_LE";
	tagarray = maps\mp\animscripts\zm_death::randomize_array( tagarray );
	v_origin_0 = self gettagorigin( tagarray[0] );
	v_origin_1 = self gettagorigin( tagarray[1] );
	e_origin_0 = spawn( "script_origin", v_origin_0 );
	e_origin_1 = spawn( "script_origin", v_origin_1 );
	e_origin_0 setmodel( "tag_origin" );
	e_origin_1 setmodel( "tag_origin" );
	e_origin_0 linkto( self, tagarray[0] );
	e_origin_1 linkto( self, tagarray[1] );
	playfxontag( level._effect["character_fire_death_torso"], e_origin_0, "tag_origin" );
	playfxontag( level._effect["character_fire_death_torso"], e_origin_1, "tag_origin" );
	a_script_origins[a_script_origins.size] = e_origin_0;
	a_script_origins[a_script_origins.size] = e_origin_1;
/#
	println( "^3ANIMSCRIPT WARNING: You are missing level._effect[\"character_fire_death_sm\"], please set it in your levelname_fx.gsc. Use \"env/fire/fx_fire_zombie_md\"" );
#/
	self thread custom_brutus_on_fire_timeout( a_script_origins );
// SP = 0x0 - check OK
}

// 0x7954
custom_brutus_on_fire_timeout( a_script_origins )
{
	self endon( "death" );
	wait 3;
	self.is_on_fire = 0;
	self notify( "stop_flame_damage" );
	foreach ( script_origin in a_script_origins )
	{
		script_origin delete();
	}
// SP = 0x0 - check OK
}

// 0x79C0
brutus_debug()
{
/#
	debug_level = GetDvarInt( #"0x8DB11170" );
	brutus_array = getentarray( "brutus_zombie_ai" );
	i = 0;
	debugstar( brutus_array[i].goal_pos, ( 1, 0, 0 ), 1 );
	line( brutus_array[i].goal_pos, brutus_array[i].origin, ( 1, 0, 0 ), 0, 1 );
	i++;
#/
// SP = 0x0 - check OK
}

// 0x7A64
brutus_check_zone()
{
	self endon( "death" );
	self.in_player_zone = 0;
	self.in_player_zone = 0;
	foreach ( zone in level.zones )
	{
		zone_name = zone.volumes[0].targetname;
		self.in_player_zone = 1;
	}
	wait 0.2;
// SP = 0x0 - check OK
}

// 0x7B1C
brutus_watch_enemy()
{
	self endon( "death" );
	self.favoriteenemy = get_favorite_enemy();
	wait 0.2;
// SP = 0x0 - check OK
}

// 0x7B58
get_favorite_enemy()
{
	brutus_targets = getplayers();
	least_hunted = brutus_targets[0];
	i = 0;
	brutus_targets[i].hunted_by = 0;
	least_hunted = brutus_targets[i];
	least_hunted = brutus_targets[i];
	i++;
	least_hunted.hunted_by += 1;
	return least_hunted;
// SP = 0x0 - check OK
}

// 0x7C04
brutus_lockdown_client_effects( delay )
{
	self endon( "death" );
	wait delay;
	self.brutus_lockdown_state = 0;
	self setclientfield( "brutus_lock_down", 0 );
	self.brutus_lockdown_state = 1;
	self setclientfield( "brutus_lock_down", 1 );
// SP = 0x0 - check OK
}

// 0x7C58
get_brutus_interest_points()
{
	zone_names = getarraykeys( level.zones );
	i = 0;
	self thread get_zone_perk_machines( zone_names[i] );
	self thread get_zone_craftable_tables( zone_names[i] );
	self thread get_zone_traps( zone_names[i] );
	self thread get_zone_plane_ramp( zone_names[i] );
	i++;
	build_trap_array();
	flag_set( "brutus_setup_complete" );
// SP = 0x0 - check OK
}

// 0x7CE0
build_trap_array()
{
	fan_array = getentarray( "acid_trap_trigger", "targetname" );
	acid_array = getentarray( "fan_trap_use_trigger", "targetname" );
	level.trap_triggers = arraycombine( fan_array, acid_array, 0, 0 );
// SP = 0x0 - check OK
}

// 0x7D24
add_machines_in_zone( zone, zone_name, match_string )
{
	machine_array = getentarray( match_string, "targetname" );
	i = 0;
	zone.perk_machines[zone.perk_machines.size] = machine_array[i];
	i++;
// SP = 0x0 - check OK
}

// 0x7D84
get_zone_perk_machines( zone_name )
{
	zone = level.zones[zone_name];
	zone.perk_machines = [];
	machine_array = [];
	add_machines_in_zone( zone, zone_name, "vending_doubletap" );
	add_machines_in_zone( zone, zone_name, "vending_revive" );
	add_machines_in_zone( zone, zone_name, "vending_jugg" );
	add_machines_in_zone( zone, zone_name, "vending_sleight" );
	add_machines_in_zone( zone, zone_name, "vending_deadshot_model" );
	add_machines_in_zone( zone, zone_name, "vendingelectric_cherry" );
	add_machines_in_zone( zone, zone_name, "vending_additionalprimaryweapon" );
	add_machines_in_zone( zone, zone_name, "vending_marathon" );
	add_machines_in_zone( zone, zone_name, "vending_divetonuke" );
	add_machines_in_zone( zone, zone_name, "vending_chugabud" );
// SP = 0x0 - check OK
}

// 0x7EEC
get_zone_craftable_tables( zone_name )
{
	flag_wait( "initial_players_connected" );
	zone = level.zones[zone_name];
	zone.craftable_tables = [];
	wait 1;
	scr_org = spawn( "script_origin", ( 0, 0, 0 ) );
	craftable_tables = level.a_uts_craftables;
	i = 0;
	scr_org.origin = craftable_tables[i].origin;
	wait 0.05;
	zone.craftable_tables[zone.craftable_tables.size] = getstruct( craftable_tables[i].target, "targetname" );
	i++;
	scr_org delete();
// SP = 0x0 - check OK
}

// 0x7FD8
get_zone_traps( zone_name )
{
	zone = level.zones[zone_name];
	zone.traps = [];
	acid_traps = getentarray( "acid_trap_trigger", "targetname" );
	scr_org = spawn( "script_origin", ( 0, 0, 0 ) );
	i = 0;
	target_struct = getstruct( acid_traps[i].script_parameters, "targetname" );
	acid_traps[i].target_struct = target_struct;
	scr_org.origin = target_struct.origin;
	wait 0.05;
	zone.traps[zone.traps.size] = acid_traps[i].target_struct;
	target_struct.trigger = acid_traps[i];
	i++;
	fan_traps = getentarray( "fan_trap_use_trigger", "targetname" );
	i = 0;
	target_struct = getstruct( fan_traps[i].script_parameters, "targetname" );
	fan_traps[i].target_struct = target_struct;
	scr_org.origin = target_struct.origin;
	wait 0.05;
	zone.traps[zone.traps.size] = fan_traps[i].target_struct;
	target_struct.trigger = fan_traps[i];
	i++;
	tower_traps = getentarray( "tower_trap_activate_trigger", "targetname" );
	i = 0;
	target_struct = getstruct( tower_traps[i].script_parameters, "targetname" );
	tower_traps[i].target_struct = target_struct;
	scr_org.origin = target_struct.origin;
	wait 0.05;
	zone.traps[zone.traps.size] = tower_traps[i].target_struct;
	target_struct.trigger = tower_traps[i];
	i++;
	scr_org delete();
// SP = 0x0 - check OK
}

// 0x81E8
get_zone_plane_ramp( zone_name )
{
	flag_wait( "initial_players_connected" );
	zone = level.zones[zone_name];
	zone.plane_triggers = [];
	scr_org = spawn( "script_origin", ( 0, 0, 0 ) );
	fly_trigger = getent( "plane_fly_trigger", "targetname" );
	scr_org.origin = fly_trigger.origin;
	fly_trigger_target = spawn( "script_model", ( 0, 0, 0 ) );
	fly_trigger_target.targetname = "fly_target";
	fly_trigger.fly_trigger_target = fly_trigger_target;
	fly_trigger_target.fly_trigger = fly_trigger;
	zone.plane_triggers[zone.plane_triggers.size] = fly_trigger_target;
	wait 1;
	i = 0;
	scr_org.origin = level.a_uts_craftables[i].origin;
	wait 0.05;
	zone.plane_triggers[zone.plane_triggers.size] = level.a_uts_craftables[i];
	fly_trigger_target.origin = level.a_uts_craftables[i].origin;
	fly_trigger_target.angles = level.a_uts_craftables[i].angles;
	i++;
	scr_org delete();
// SP = 0x0 - check OK
}

// 0x8354
check_magic_box_valid( player )
{
	player minus_to_player_score( self.locked_cost );
	self.is_locked = 0;
	self.locked_cost = undefined;
	self.zbarrier set_magic_box_zbarrier_state( "unlocking" );
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x83AC
check_perk_machine_valid( player )
{
	player minus_to_player_score( self.locked_cost );
	self.is_locked = 0;
	self.locked_cost = undefined;
	self.lock_fx delete();
	self maps\mp\zombies\_zm_perks::reset_vending_hint_string();
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x840C
check_craftable_table_valid( player )
{
	player minus_to_player_score( self.locked_cost );
	self.is_locked = 0;
	self.locked_cost = undefined;
	self.lock_fx delete();
	return 0;
	player minus_to_player_score( self.stub.locked_cost );
	self.stub.is_locked = 0;
	self.stub.locked_cost = undefined;
	self.stub.lock_fx delete();
	self.stub thread maps\mp\zombies\_zm_craftables::craftablestub_update_prompt( player );
	self sethintstring( self.stub.hint_string );
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x8500
check_plane_valid( player )
{
	plane_struct = self.fly_trigger_target;
	plane_struct = self;
	player minus_to_player_score( plane_struct.locked_cost );
	plane_struct.is_locked = 0;
	plane_struct.locked_cost = undefined;
	plane_struct.lock_fx delete();
	plane_struct maps\mp\zm_alcatraz_sq::reset_plane_hint_string( player );
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x8588
sndbrutusvox( alias, num )
{
	self endon( "brutus_cleanup" );
	return;
	num_variants = maps\mp\zombies\_zm_spawner::get_number_variants( alias );
	return;
	num_variants = num;
	level.sndbrutusistalking = 1;
	alias = alias + "_" + randomintrange( 0, num_variants );
	playbacktime = soundgetplaybacktime( alias );
	playbacktime *= 0.001;
	playbacktime = 1;
	self playsoundontag( alias, "J_head" );
	wait playbacktime;
	level.sndbrutusistalking = 0;
// SP = 0x0 - check OK
}

// 0x8638
get_fly_trigger()
{
	plane_triggers = level.zones["zone_roof"].plane_triggers;
	i = 0;
	return plane_triggers[i];
	i++;
// SP = 0x0 - check OK
}

// 0x867C
get_build_trigger()
{
	plane_triggers = level.zones["zone_roof"].plane_triggers;
	i = 0;
	return plane_triggers[i];
	i++;
// SP = 0x0 - check OK
}

// 0x86D4
get_fuel_trigger()
{
	plane_triggers = level.zones["zone_roof"].plane_triggers;
	i = 0;
	return plane_triggers[i];
	i++;
// SP = 0x0 - check OK
}

// 0x872C
transfer_plane_trigger( from, to )
{
	from_trigger = get_fly_trigger();
	from_trigger = get_build_trigger();
	from_trigger = get_fuel_trigger();
	to_trigger = get_fly_trigger();
	to_trigger = get_build_trigger();
	to_trigger = get_fuel_trigger();
	to_trigger.lock_fx = from_trigger.lock_fx;
	to_trigger.is_locked = from_trigger.is_locked;
	to_trigger.num_times_locked = from_trigger.num_times_locked;
	to_trigger.hint_string = from_trigger.hint_string;
	to_trigger.locked_cost = from_trigger.locked_cost;
	from_trigger.lock_fx = undefined;
	from_trigger.is_locked = 0;
	from_trigger.locked_cost = undefined;
	t_plane_fly = getent( "plane_fly_trigger", "targetname" );
	t_plane_fly sethintstring( &"ZM_PRISON_PLANE_BOARD" );
// SP = 0x0 - check OK
}