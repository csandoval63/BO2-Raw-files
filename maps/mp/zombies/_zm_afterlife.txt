// maps/mp/zombies/_zm_afterlife.gsc

#include maps\mp\zombies\_zm_ai_basic;
#include maps\mp\animscripts\shared;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\zombies\_zm_zonemgr;
#include maps\mp\zm_alcatraz_travel;
#include maps\mp\gametypes_zm\_zm_gametype;
#include maps\mp\zombies\_zm_equipment;
#include maps\mp\zombies\_zm_weapons;
#include maps\mp\zombies\_zm_clone;
#include maps\mp\zombies\_zm_perk_electric_cherry;
#include maps\mp\zombies\_zm_perks;
#include maps\mp\zombies\_zm_unitrigger;
#include maps\mp\zombies\_zm;
#include maps\mp\_visionset_mgr;
#include maps\mp\zm_alcatraz_utility;
#include maps\mp\zombies\_zm_laststand;
#include maps\mp\gametypes_zm\_hud;
#include maps\mp\gametypes_zm\_hud_util;
#include maps\mp\zombies\_zm_utility;
#include common_scripts\utility;
#include maps\mp\_utility;

#using_animtree ( "fxanim_props" );


// 0x325C
init()
{
	level.zombiemode_using_afterlife = 1;
	flag_init( "afterlife_start_over" );
	level.afterlife_revive_tool = "syrette_afterlife_zm";
	precacheitem( level.afterlife_revive_tool );
	precachemodel( "drone_collision" );
	maps\mp\_visionset_mgr::vsmgr_register_info( "visionset", "zm_afterlife", 9000, 120, 1, 1 );
	maps\mp\_visionset_mgr::vsmgr_register_info( "overlay", "zm_afterlife_filter", 9000, 120, 1, 1 );
	maps\mp\zombies\_zm::register_player_damage_callback( level.afterlife_player_damage_override );
	maps\mp\zombies\_zm::register_player_damage_callback( ::afterlife_player_damage_callback );
	registerclientfield( "toplayer", "player_lives", 9000, 2, "int" );
	registerclientfield( "toplayer", "player_in_afterlife", 9000, 1, "int" );
	registerclientfield( "toplayer", "player_afterlife_mana", 9000, 5, "float" );
	registerclientfield( "allplayers", "player_afterlife_fx", 9000, 1, "int" );
	registerclientfield( "toplayer", "clientfield_afterlife_audio", 9000, 1, "int" );
	registerclientfield( "toplayer", "player_afterlife_refill", 9000, 1, "int" );
	registerclientfield( "scriptmover", "player_corpse_id", 9000, 3, "int" );
	afterlife_load_fx();
	level thread afterlife_hostmigration();
	precachemodel( "c_zom_ghost_viewhands" );
	precachemodel( "c_zom_hero_ghost_fb" );
	precacheitem( "lightning_hands_zm" );
	precachemodel( "p6_zm_al_shock_box_on" );
	precacheshader( "waypoint_revive_afterlife" );
	a_afterlife_interact = getentarray( "afterlife_interact", "targetname" );
	array_thread( a_afterlife_interact, ::afterlife_interact_object_think );
	level.zombie_spawners = getentarray( "zombie_spawner", "script_noteworthy" );
	array_thread( level.zombie_spawners, ::add_spawn_function, ::afterlife_zombie_damage );
	a_afterlife_triggers = getstructarray( "afterlife_trigger", "targetname" );
	foreach ( struct in a_afterlife_triggers )
	{
		afterlife_trigger_create( struct );
	}
	level.afterlife_interact_dist = 256;
	level.is_player_valid_override = ::is_player_valid_afterlife;
	level.can_revive = ::can_revive_override;
	level.round_prestart_func = ::afterlife_start_zombie_logic;
	level.custom_pap_validation = ::is_player_valid_afterlife;
	level.player_out_of_playable_area_monitor_callback = ::player_out_of_playable_area;
	level thread afterlife_gameover_cleanup();
	level.afterlife_get_spawnpoint = ::afterlife_get_spawnpoint;
	level.afterlife_zapped = ::afterlife_zapped;
	level.afterlife_give_loadout = ::afterlife_give_loadout;
	level.afterlife_save_loadout = ::afterlife_save_loadout;
// SP = 0x0 - check OK
}

// 0x3534
afterlife_gameover_cleanup()
{
	level waittill( "end_game" );
	foreach ( player in getplayers() )
	{
		player.afterlife = 0;
		player clientnotify( "end_game" );
		player notify( "end_game" );
		player.client_hint destroy();
	}
	wait 5;
	foreach ( player in getplayers() )
	{
		maps\mp\_visionset_mgr::vsmgr_deactivate( "overlay", "zm_afterlife_filter", player );
	}
// SP = 0x0 - check OK
}

// 0x3608
afterlife_load_fx()
{
	level._effect["afterlife_teleport"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_afterlife_zmb_tport" );
	level._effect["teleport_ball"] = loadfx( "weapon/tomahawk/fx_tomahawk_trail_ug" );
	level._effect["afterlife_kill_point_fx"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_suicide_area" );
	level._effect["afterlife_enter"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_afterlife_start" );
	level._effect["afterlife_leave"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_player_revive" );
	level._effect["afterlife_pixie_dust"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_afterlife_pixies" );
	level._effect["afterlife_corpse"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_player_down" );
	level._effect["afterlife_damage"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_afterlife_damage" );
	level._effect["afterlife_ghost_fx"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_ghost_body" );
	level._effect["afterlife_ghost_h_fx"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_ghost_head" );
	level._effect["afterlife_ghost_arm_fx"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_ghost_arm" );
	level._effect["afterlife_ghost_hand_fx"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_ghost_hand" );
	level._effect["afterlife_ghost_hand_r_fx"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_ghost_hand_r" );
	level._effect["afterlife_transition"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_afterlife_transition" );
	level._effect["fx_alcatraz_ghost_vm_wrist"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_ghost_vm_wrist" );
	level._effect["fx_alcatraz_ghost_vm_wrist_r"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_ghost_vm_wrist_r" );
	level._effect["fx_alcatraz_ghost_spectate"] = loadfx( "maps/zombie_alcatraz/fx_alcatraz_ghost_spec" );
// SP = 0x0 - check OK
}

// 0x3764
afterlife_start_zombie_logic()
{
	flag_wait( "start_zombie_round_logic" );
	wait 0.5;
	b_everyone_alive = 0;
	b_everyone_alive = 1;
	a_players = getplayers();
	foreach ( player in a_players )
	{
		b_everyone_alive = 0;
		wait 0.05;
	}
	wait 0.5;
	wait 0.05;
	flag_set( "afterlife_start_over" );
	wait 2;
	array_func( getplayers(), ::afterlife_add );
// SP = 0x0 - check OK
}

// 0x3840
is_player_valid_afterlife( player )
{
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x3864
can_revive_override( revivee )
{
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x3884
player_out_of_playable_area()
{
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x38B4
init_player()
{
	flag_wait( "initial_players_connected" );
	self.lives = 3;
	self.lives = 1;
	self setclientfieldtoplayer( "player_lives", self.lives );
	self.afterlife = 0;
	self.afterliferound = level.round_number;
	self.afterlifedeaths = 0;
	self thread afterlife_doors_close();
	self thread afterlife_player_refill_watch();
// SP = 0x0 - check OK
}

// 0x3928
afterlife_remove( b_afterlife_death )
{
	b_afterlife_death = 0;
	self.lives = 0;
	self.lives--;
	self notify( "sndLifeGone" );
	self setclientfieldtoplayer( "player_lives", self.lives );
// SP = 0x0 - check OK
}

// 0x397C
afterlife_add()
{
	self.lives++;
	self thread afterlife_add_fx();
	self.lives++;
	self thread afterlife_add_fx();
	self playsoundtoplayer( "zmb_afterlife_add", self );
	self setclientfieldtoplayer( "player_lives", self.lives );
// SP = 0x0 - check OK
}

// 0x39F0
afterlife_add_fx()
{
	self setclientfieldtoplayer( "player_afterlife_refill", 1 );
	wait 3;
	self setclientfieldtoplayer( "player_afterlife_refill", 0 );
// SP = 0x0 - check OK
}

// 0x3A3C
afterlife_player_refill_watch()
{
	self endon( "disconnect" );
	self endon( "_zombie_game_over" );
	level endon( "stage_final" );
	level waittill( "end_of_round" );
	wait 2;
	self afterlife_add();
	reset_all_afterlife_unitriggers();
// SP = 0x0 - check OK
}

// 0x3A7C
afterlife_player_damage_callback( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime )
{
	idamage = eattacker [[eattacker.custom_damage_func]]( self );
	idamage = eattacker.meleedamage;
	self afterlife_reduce_mana( 10 );
	self clientnotify( "al_d" );
	return 0;
	return 0;
	item_dmg = 100;
	item_dmg = eattacker.custom_item_dmg;
	self [[self.player_shield_apply_damage]]( item_dmg, 0 );
	return 0;
	self [[self.player_shield_apply_damage]]( item_dmg, 0 );
	return 0;
	self.use_adjusted_grenade_damage = 1;
	idamage = 0;
	self.use_adjusted_grenade_damage = 1;
	idamage = 10;
	return 0;
	idamage = 75;
	self.use_adjusted_grenade_damage = 1;
	return 0;
	self playsoundtoplayer( "zmb_afterlife_death", self );
	self afterlife_remove();
	self.afterlife = 1;
	self thread afterlife_laststand();
	return 0;
	idamage = self.health - 1;
	self thread last_stand_conscience_vo();
	return idamage;
// SP = 0x0 - check OK
}

// 0x3D54
afterlife_enter()
{
	maps\mp\_visionset_mgr::vsmgr_activate( "visionset", "zm_afterlife", self );
	maps\mp\_visionset_mgr::vsmgr_activate( "overlay", "zm_afterlife_filter", self );
	self.afterlife_visionset = 1;
	self enableafterlife();
	self.str_living_model = self.model;
	self.str_living_view = self getviewmodel();
	self setmodel( "c_zom_hero_ghost_fb" );
	self setviewmodel( "c_zom_ghost_viewhands" );
	self thread afterlife_doors_open();
	self setclientfieldtoplayer( "player_in_afterlife", 1 );
	self setclientfield( "player_afterlife_fx", 1 );
	self afterlife_create_mana_bar( self.e_afterlife_corpse );
	self increment_downed_stat();
	a_afterlife_triggers = getstructarray( "afterlife_trigger", "targetname" );
	foreach ( struct in a_afterlife_triggers )
	{
		struct.unitrigger_stub maps\mp\zombies\_zm_unitrigger::run_visibility_function_for_all_triggers();
	}
	a_exterior_goals = getstructarray( "exterior_goal", "targetname" );
	foreach ( struct in a_exterior_goals )
	{
		struct.unitrigger_stub maps\mp\zombies\_zm_unitrigger::run_visibility_function_for_all_triggers();
	}
// SP = 0x0 - check OK
}

// 0x3EF8
afterlife_leave( b_revived )
{
	b_revived = 1;
	self clientnotify( "al_t" );
	maps\mp\_visionset_mgr::vsmgr_deactivate( "visionset", "zm_afterlife", self );
	maps\mp\_visionset_mgr::vsmgr_deactivate( "overlay", "zm_afterlife_filter", self );
	self.afterlife_visionset = 0;
	self disableafterlife();
	self.dontspeak = 0;
	self thread afterlife_doors_close();
	self.health = self.maxhealth;
	self setclientfieldtoplayer( "player_in_afterlife", 0 );
	self setclientfield( "player_afterlife_fx", 0 );
	self setclientfieldtoplayer( "clientfield_afterlife_audio", 0 );
	self maps\mp\zombies\_zm_perks::perk_set_max_health_if_jugg( "health_reboot", 1, 0 );
	self allowstand( 1 );
	self allowcrouch( 1 );
	self allowprone( 1 );
	self setmodel( self.str_living_model );
	self setviewmodel( self.str_living_view );
	self setorigin( self.e_afterlife_corpse.revivetrigger.origin );
	self setorigin( self.e_afterlife_corpse.origin );
	a_gondola_doors_gates = get_gondola_doors_and_gates();
	i = 0;
	str_location = level.e_gondola.destination;
	str_location = level.e_gondola.location;
	a_s_orgs = getstructarray( "gondola_dropped_parts_" + str_location, "targetname" );
	foreach ( struct in a_s_orgs )
	{
		self setorigin( struct.origin );
	}
	i++;
	self setplayerangles( self.e_afterlife_corpse.angles );
	self.afterlife = 0;
	self afterlife_laststand_cleanup( self.e_afterlife_corpse );
	self afterlife_remove( 1 );
	self dodamage( 1000, self.origin );
	reset_all_afterlife_unitriggers();
// SP = 0x0 - check OK
}

// 0x4198
afterlife_laststand( b_electric_chair )
{
	b_electric_chair = 0;
	self endon( "disconnect" );
	self endon( "afterlife_bleedout" );
	level endon( "end_game" );
	self thread [[level.afterlife_laststand_override]]( b_electric_chair );
	return;
	self.dontspeak = 1;
	self.health = 1000;
	b_has_electric_cherry = 0;
	b_has_electric_cherry = 1;
	self [[level.afterlife_save_loadout]]();
	self afterlife_fake_death();
	wait 1;
	self maps\mp\zombies\_zm_perk_electric_cherry::electric_cherry_laststand();
	wait 2;
	self setclientfieldtoplayer( "clientfield_afterlife_audio", 1 );
	self clientnotify( "al_t" );
	wait 1;
	self thread fadetoblackforxsec( 0, 1, 0.5, 0.5, "white" );
	wait 0.5;
	self ghost();
	self.e_afterlife_corpse = self afterlife_spawn_corpse();
	self thread afterlife_clean_up_on_disconnect();
	self notify( "player_fake_corpse_created" );
	self afterlife_fake_revive();
	self afterlife_enter();
	self.e_afterlife_corpse setclientfield( "player_corpse_id", self getentitynumber() + 1 );
	wait 0.5;
	self show();
	self freezecontrols( 0 );
	self disableinvulnerability();
	self.e_afterlife_corpse waittill( "player_revived", e_reviver );
	self notify( "player_revived" );
	self seteverhadweaponall( 1 );
	self enableinvulnerability();
	self.afterlife_revived = 1;
	playsoundatposition( "zmb_afterlife_spawn_leave", self.e_afterlife_corpse.origin );
	self afterlife_leave();
	self thread afterlife_revive_invincible();
	self playsound( "zmb_afterlife_revived_gasp" );
// SP = 0x0 - check OK
}

// 0x43AC
afterlife_clean_up_on_disconnect()
{
	e_corpse = self.e_afterlife_corpse;
	e_corpse endon( "death" );
	self waittill( "disconnect" );
	e_corpse notify( "stop_revive_trigger" );
	e_corpse.revivetrigger delete();
	e_corpse.revivetrigger = undefined;
	e_corpse setclientfield( "player_corpse_id", 0 );
	e_corpse notify( "disconnect" );
	wait_network_frame();
	wait_network_frame();
	e_corpse delete();
// SP = 0x0 - check OK
}

// 0x4428
afterlife_revive_invincible()
{
	self endon( "disconnect" );
	wait 2;
	self disableinvulnerability();
	self seteverhadweaponall( 0 );
	self.afterlife_revived = undefined;
// SP = 0x0 - check OK
}

// 0x4454
afterlife_laststand_cleanup( corpse )
{
	self [[level.afterlife_give_loadout]]();
	self afterlife_corpse_cleanup( corpse );
// SP = 0x0 - check OK
}

// 0x4474
afterlife_create_mana_bar( corpse )
{
	self.afterlifedeaths++;
	self.afterliferound = level.round_number;
	self.afterlifedeaths = 1;
	self.manacur = 200;
	self thread afterlife_mana_watch( corpse );
	self thread afterlife_lightning_watch( corpse );
	self thread afterlife_jump_watch( corpse );
// SP = 0x0 - check OK
}

// 0x44E4
afterlife_infinite_mana( b_infinite )
{
	b_infinite = 1;
	self.infinite_mana = 1;
	self.infinite_mana = 0;
// SP = 0x0 - check OK
}

// 0x4518
afterlife_mana_watch( corpse )
{
	self endon( "disconnect" );
	corpse endon( "player_revived" );
	wait 0.05;
	self afterlife_reduce_mana( 0.05 * self.afterlifedeaths * 3 );
	self.manacur = 0;
	n_mapped_mana = linear_map( self.manacur, 0, 200, 0, 1 );
	self setclientfieldtoplayer( "player_afterlife_mana", n_mapped_mana );
	wait 0.05;
	corpse notify( "stop_revive_trigger" );
	self thread fadetoblackforxsec( 0, 0.5, 0.5, 0.5, "black" );
	wait 0.5;
	self notify( "out_of_mana" );
	self afterlife_leave( 0 );
// SP = 0x0 - check OK
}

// 0x4604
afterlife_doors_open()
{
	n_network_sent = 0;
	a_show = getentarray( "afterlife_show", "targetname" );
	a_show = arraycombine( a_show, getentarray( "afterlife_prop", "script_noteworthy" ), 0, 0 );
	foreach ( ent in a_show )
	{
		n_network_sent++;
		n_network_sent = 0;
		wait_network_frame();
		ent setvisibletoplayer( self );
	}
	a_hide = getentarray( "afterlife_door", "targetname" );
	a_hide = arraycombine( a_hide, getentarray( "zombie_door", "targetname" ), 0, 0 );
	a_hide = arraycombine( a_hide, getentarray( "quest_trigger", "script_noteworthy" ), 0, 0 );
	a_hide = arraycombine( a_hide, getentarray( "trap_trigger", "script_noteworthy" ), 0, 0 );
	a_hide = arraycombine( a_hide, getentarray( "travel_trigger", "script_noteworthy" ), 0, 0 );
	foreach ( ent in a_hide )
	{
		n_network_sent++;
		n_network_sent = 0;
		wait_network_frame();
		ent setinvisibletoplayer( self );
	}
	foreach ( claymore in self.claymores )
	{
		claymore.pickuptrigger setinvisibletoplayer( self );
	}
// SP = 0x0 - check OK
}

// 0x47C4
afterlife_doors_close()
{
	n_network_sent = 0;
	a_hide = getentarray( "afterlife_show", "targetname" );
	a_hide = arraycombine( a_hide, getentarray( "afterlife_prop", "script_noteworthy" ), 0, 0 );
	foreach ( ent in a_hide )
	{
		n_network_sent++;
		n_network_sent = 0;
		wait_network_frame();
		ent setinvisibletoplayer( self );
	}
	a_show = getentarray( "afterlife_door", "targetname" );
	a_show = arraycombine( a_show, getentarray( "zombie_door", "targetname" ), 0, 0 );
	a_show = arraycombine( a_show, getentarray( "quest_trigger", "script_noteworthy" ), 0, 0 );
	a_show = arraycombine( a_show, getentarray( "trap_trigger", "script_noteworthy" ), 0, 0 );
	a_show = arraycombine( a_show, getentarray( "travel_trigger", "script_noteworthy" ), 0, 0 );
	foreach ( ent in a_show )
	{
		n_network_sent++;
		n_network_sent = 0;
		wait_network_frame();
		ent setvisibletoplayer( self );
	}
	foreach ( claymore in self.claymores )
	{
		claymore.pickuptrigger setvisibletoplayer( self );
	}
// SP = 0x0 - check OK
}

// 0x4984
afterlife_corpse_cleanup( corpse )
{
	playsoundatposition( "zmb_afterlife_revived", corpse.origin );
	corpse notify( "stop_revive_trigger" );
	corpse.revivetrigger delete();
	corpse.revivetrigger = undefined;
	corpse setclientfield( "player_corpse_id", 0 );
	corpse afterlife_corpse_remove_pois();
	wait_network_frame();
	wait_network_frame();
	corpse delete();
	self.e_afterlife_corpse = undefined;
// SP = 0x0 - check OK
}

// 0x4A08
afterlife_spawn_corpse()
{
	corpse = maps\mp\zombies\_zm_clone::spawn_player_clone( self, self.origin, undefined );
	trace_start = self.origin;
	trace_end = self.origin + vector_scale( ( 0, 0, -1 ), 500 );
	corpse_trace = playerphysicstrace( trace_start, trace_end );
	corpse = maps\mp\zombies\_zm_clone::spawn_player_clone( self, corpse_trace, undefined );
	corpse.angles = self.angles;
	corpse.ignoreme = 1;
	corpse maps\mp\zombies\_zm_clone::clone_give_weapon( "m1911_zm" );
	corpse maps\mp\zombies\_zm_clone::clone_animate( "afterlife" );
	corpse.revive_hud = self afterlife_revive_hud_create();
	corpse thread afterlife_revive_trigger_spawn();
	corpse thread afterlife_corpse_create_pois();
	return corpse;
// SP = 0x0 - check OK
}

// 0x4AF4
afterlife_corpse_create_pois()
{
	n_attractors = ceil( get_current_zombie_count() / 3 );
	n_attractors = 4;
	a_nodes = afterlife_corpse_get_array_poi_positions();
	self.pois = [];
	i = 0;
	self.pois[i] = afterlife_corpse_create_poi( a_nodes[i].origin, n_attractors );
	wait 0.05;
	i++;
// SP = 0x0 - check OK
}

// 0x4B80
afterlife_corpse_create_poi( v_origin, n_attractors )
{
	e_poi = spawn( "script_origin", v_origin );
	e_poi create_zombie_point_of_interest( 10000, 24, 5000, 1 );
	e_poi thread create_zombie_point_of_interest_attractor_positions();
/#
	e_poi thread print3d_ent( "Corpse POI" );
#/
	return e_poi;
// SP = 0x0 - check OK
}

// 0x4BD0
afterlife_corpse_remove_pois()
{
	return;
	i = 0;
	remove_poi_attractor( self.pois[i] );
	self.pois[i] delete();
	i++;
	self.pois = undefined;
// SP = 0x0 - check OK
}

// 0x4C24
afterlife_corpse_get_array_poi_positions()
{
	n_ideal_dist_sq = 490000;
	a_nodes = getanynodearray( self.origin, 1200 );
	i = 0;
	a_nodes[i] = undefined;
	i++;
	a_nodes = remove_undefined_from_array( a_nodes );
	return array_randomize( a_nodes );
// SP = 0x0 - check OK
}

// 0x4C94
afterlife_revive_hud_create()
{
	self.revive_hud = newclienthudelem( self );
	self.revive_hud.alignx = "center";
	self.revive_hud.aligny = "middle";
	self.revive_hud.horzalign = "center";
	self.revive_hud.vertalign = "bottom";
	self.revive_hud.y = -160;
	self.revive_hud.foreground = 1;
	self.revive_hud.font = "default";
	self.revive_hud.fontscale = 1.5;
	self.revive_hud.alpha = 0;
	self.revive_hud.color = ( 1, 1, 1 );
	self.revive_hud.hidewheninmenu = 1;
	self.revive_hud settext( "" );
	return self.revive_hud;
// SP = 0x0 - check OK
}

// 0x4D48
afterlife_revive_trigger_spawn()
{
	radius = GetDvarInt( #"0xA17166B0" );
	self.revivetrigger = spawn( "trigger_radius", ( 0, 0, 0 ), 0, radius, radius );
	self.revivetrigger sethintstring( "" );
	self.revivetrigger setcursorhint( "HINT_NOICON" );
	self.revivetrigger setmovingplatformenabled( 1 );
	self.revivetrigger enablelinkto();
	self.revivetrigger.origin = self.origin;
	self.revivetrigger linkto( self );
	self.revivetrigger.beingrevived = 0;
	self.revivetrigger.createtime = GetTime();
	self thread afterlife_revive_trigger_think();
// SP = 0x0 - check OK
}

// 0x4DF0
afterlife_revive_trigger_think()
{
	self endon( "disconnect" );
	self endon( "stop_revive_trigger" );
	self endon( "death" );
	wait 1;
	wait 0.1;
	self.revivetrigger sethintstring( "" );
	players = get_players();
	i = 0;
	self.revivetrigger setrevivehintstring( &"GAME_BUTTON_TO_REVIVE_PLAYER", self.team );
	i++;
	i = 0;
	reviver = players[i];
	gun = reviver getcurrentweapon();
/#
	assert( IsDefined( gun ) );
#/
	reviver giveweapon( level.afterlife_revive_tool );
	reviver switchtoweapon( level.afterlife_revive_tool );
	reviver setweaponammostock( level.afterlife_revive_tool, 1 );
	reviver giveweapon( level.revive_tool );
	reviver switchtoweapon( level.revive_tool );
	reviver setweaponammostock( level.revive_tool, 1 );
	revive_success = reviver afterlife_revive_do_revive( self, gun );
	reviver revive_give_back_weapons( gun );
	self allowjump( 1 );
	self.laststand = undefined;
	self thread revive_success( reviver );
	self cleanup_suicide_hud();
	return;
	i++;
// SP = 0x0 - check OK
}

// 0x4FC8
afterlife_can_revive( revivee )
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	return 0;
	ignore_sight_checks = 0;
	ignore_touch_checks = 0;
	ignore_sight_checks = [[level.revive_trigger_should_ignore_sight_checks]]( self );
	ignore_touch_checks = 1;
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x50F4
afterlife_revive_do_revive( playerbeingrevived, revivergun )
{
/#
	assert( self is_reviving_afterlife( playerbeingrevived ) );
#/
	revivetime = 3;
	playloop = 0;
	playloop = 1;
	revivetime = 1;
	timer = 0;
	revived = 0;
	playerbeingrevived.revivetrigger.beingrevived = 1;
	playerbeingrevived.revive_hud settext( &"GAME_PLAYER_IS_REVIVING_YOU", self );
	playerbeingrevived revive_hud_show_n_fade( 3 );
	playerbeingrevived.revivetrigger sethintstring( "" );
	playerbeingrevived startrevive( self );
	self.reviveprogressbar = self createprimaryprogressbar();
	self.revivetexthud = newclienthudelem( self );
	self thread revive_clean_up_on_gameover();
	self thread laststand_clean_up_on_disconnect( playerbeingrevived, revivergun );
	self.is_reviving_any = 0;
	self.is_reviving_any++;
	self thread laststand_clean_up_reviving_any( playerbeingrevived );
	self.reviveprogressbar updatebar( 0.01, 1 / revivetime );
	self.revivetexthud.alignx = "center";
	self.revivetexthud.aligny = "middle";
	self.revivetexthud.horzalign = "center";
	self.revivetexthud.vertalign = "bottom";
	self.revivetexthud.y = -113;
	self.revivetexthud.y = -347;
	self.revivetexthud.foreground = 1;
	self.revivetexthud.font = "default";
	self.revivetexthud.fontscale = 1.8;
	self.revivetexthud.alpha = 1;
	self.revivetexthud.color = ( 1, 1, 1 );
	self.revivetexthud.hidewheninmenu = 1;
	self.revivetexthud.color = ( 0.5, 0.5, 1 );
	self.revivetexthud settext( &"GAME_REVIVING" );
	self thread check_for_failed_revive( playerbeingrevived );
	e_fx = spawn( "script_model", playerbeingrevived.revivetrigger.origin );
	e_fx setmodel( "tag_origin" );
	e_fx thread revive_fx_clean_up_on_disconnect( playerbeingrevived );
	playfxontag( level._effect["afterlife_leave"], e_fx, "tag_origin" );
	e_fx playloopsound( "zmb_afterlife_reviving", 0.05 );
	wait 0.05;
	timer += 0.05;
	revived = 1;
	e_fx delete();
	self.reviveprogressbar destroyelem();
	self.revivetexthud destroy();
	playerbeingrevived stoprevive( self );
	playerbeingrevived.revivetrigger sethintstring( &"GAME_BUTTON_TO_REVIVE_PLAYER" );
	playerbeingrevived.revivetrigger.beingrevived = 0;
	self notify( "do_revive_ended_normally" );
	self.is_reviving_any--;
	playerbeingrevived thread checkforbleedout( self );
	return revived;
// SP = 0x0 - check OK
}

// 0x54C4
revive_fx_clean_up_on_disconnect( e_corpse )
{
	self endon( "death" );
	e_corpse waittill( "disconnect" );
	self delete();
// SP = 0x0 - check OK
}

// 0x54E8
revive_clean_up_on_gameover()
{
	self endon( "do_revive_ended_normally" );
	level waittill( "end_game" );
	self.reviveprogressbar destroyelem();
	self.revivetexthud destroy();
// SP = 0x0 - check OK
}

// 0x552C
is_reviving_afterlife( revivee )
{
	return afterlife_can_revive( revivee );
// SP = 0x0 - check OK
}

// 0x5550
afterlife_save_loadout()
{
	primaries = self getweaponslistprimaries();
	currentweapon = self getcurrentweapon();
	self.loadout = spawnstruct();
	self.loadout.player = self;
	self.loadout.weapons = [];
	self.loadout.score = self.score;
	self.loadout.current_weapon = 0;
	foreach ( weapon in primaries )
	{
		self.loadout.weapons[index] = weapon;
		self.loadout.stockcount[index] = self getweaponammostock( weapon );
		self.loadout.clipcount[index] = self getweaponammoclip( weapon );
		weapon_dw = weapondualwieldweaponname( weapon );
		self.loadout.clipcount2[index] = self getweaponammoclip( weapon_dw );
		weapon_alt = weaponaltweaponname( weapon );
		self.loadout.stockcountalt[index] = self getweaponammostock( weapon_alt );
		self.loadout.clipcountalt[index] = self getweaponammoclip( weapon_alt );
		self.loadout.current_weapon = index;
	}
	self.loadout.equipment = self get_player_equipment();
	self equipment_take( self.loadout.equipment );
	self.loadout.hasclaymore = 1;
	self.loadout.claymoreclip = self getweaponammoclip( "claymore_zm" );
	self.loadout.hasemp = 1;
	self.loadout.empclip = self getweaponammoclip( "emp_grenade_zm" );
	self.loadout.hastomahawk = 1;
	self setclientfieldtoplayer( "tomahawk_in_use", 0 );
	self.loadout.perks = afterlife_save_perks( self );
	lethal_grenade = self get_player_lethal_grenade();
	self.loadout.grenade = self getweaponammoclip( lethal_grenade );
	self.loadout.grenade = 0;
	self.loadout.lethal_grenade = lethal_grenade;
	self set_player_lethal_grenade( undefined );
// SP = 0x0 - check OK
}

// 0x57F4
afterlife_give_loadout()
{
	self takeallweapons();
	loadout = self.loadout;
	primaries = self getweaponslistprimaries();
	foreach ( weapon in primaries )
	{
		self takeweapon( weapon );
	}
	i = 0;
	weapon = loadout.weapons[i];
	stock_amount = loadout.stockcount[i];
	clip_amount = loadout.clipcount[i];
	self giveweapon( weapon, 0, self maps\mp\zombies\_zm_weapons::get_pack_a_punch_weapon_options( weapon ) );
	self setweaponammostock( weapon, stock_amount );
	self setweaponammoclip( weapon, clip_amount );
	weapon_dw = weapondualwieldweaponname( weapon );
	self setweaponammoclip( weapon_dw, loadout.clipcount2[i] );
	weapon_alt = weaponaltweaponname( weapon );
	self setweaponammostock( weapon_alt, loadout.stockcountalt[i] );
	self setweaponammoclip( weapon_alt, loadout.clipcountalt[i] );
	i++;
	self setspawnweapon( loadout.weapons[loadout.current_weapon] );
	self switchtoweaponimmediate( loadout.weapons[loadout.current_weapon] );
	self giveweapon( self get_player_melee_weapon() );
	self maps\mp\zombies\_zm_equipment::equipment_give( self.loadout.equipment );
	self giveweapon( "claymore_zm" );
	self set_player_placeable_mine( "claymore_zm" );
	self setactionslot( 4, "weapon", "claymore_zm" );
	self setweaponammoclip( "claymore_zm", loadout.claymoreclip );
	self giveweapon( "emp_grenade_zm" );
	self setweaponammoclip( "emp_grenade_zm", loadout.empclip );
	self giveweapon( self.current_tomahawk_weapon );
	self set_player_tactical_grenade( self.current_tomahawk_weapon );
	self setclientfieldtoplayer( "tomahawk_in_use", 1 );
	self.score = loadout.score;
	perk_array = maps\mp\zombies\_zm_perks::get_perk_array( 1 );
	i = 0;
	perk = perk_array[i];
	self unsetperk( perk );
	self set_perk_clientfield( perk, 0 );
	i++;
	i = 0;
	level.solo_game_free_player_quickrevive = 1;
	maps\mp\zombies\_zm_perks::give_perk( loadout.perks[i] );
	i++;
	self.keep_perks = undefined;
	self set_player_lethal_grenade( self.loadout.lethal_grenade );
	curgrenadecount = 0;
	self getweaponammoclip( self get_player_lethal_grenade() );
	self giveweapon( self get_player_lethal_grenade() );
	self setweaponammoclip( self get_player_lethal_grenade(), loadout.grenade + curgrenadecount );
// SP = 0x0 - check OK
}

// 0x5C74
afterlife_fake_death()
{
	level notify( "fake_death" );
	self notify( "fake_death" );
	self takeallweapons();
	self allowstand( 0 );
	self allowcrouch( 0 );
	self allowprone( 1 );
	self setstance( "prone" );
	wait 0.05;
	playfx( level._effect["afterlife_enter"], self.origin );
	self.ignoreme = 1;
	self enableinvulnerability();
	self freezecontrols( 1 );
// SP = 0x0 - check OK
}

// 0x5D28
afterlife_fake_revive()
{
	level notify( "fake_revive" );
	self notify( "fake_revive" );
	playsoundatposition( "zmb_afterlife_spawn_leave", self.origin );
	spawnpoint = [[level.afterlife_get_spawnpoint]]();
	trace_start = spawnpoint.origin;
	trace_end = spawnpoint.origin + vector_scale( ( 0, 0, -1 ), 200 );
	respawn_trace = playerphysicstrace( trace_start, trace_end );
	self setorigin( respawn_trace );
	self setplayerangles( spawnpoint.angles );
	playsoundatposition( "zmb_afterlife_spawn_enter", spawnpoint.origin );
	playsoundatposition( "zmb_afterlife_spawn_enter", self.origin );
	self allowstand( 1 );
	self allowcrouch( 0 );
	self allowprone( 0 );
	self.ignoreme = 0;
	self setstance( "stand" );
	self giveweapon( "lightning_hands_zm" );
	self switchtoweapon( "lightning_hands_zm" );
	self.score = 0;
	wait 1;
// SP = 0x0 - check OK
}

// 0x5E48
afterlife_get_spawnpoint()
{
	spawnpoint = check_for_valid_spawn_in_zone( self );
	spawnpoint = maps\mp\zombies\_zm::check_for_valid_spawn_near_position( self, self.origin, 1 );
	spawnpoint = maps\mp\zombies\_zm::check_for_valid_spawn_near_team( self, 1 );
	match_string = "";
	location = level.scr_zm_map_start_location;
	location = level.default_start_location;
	match_string = level.scr_zm_ui_gametype + "_" + location;
	spawnpoints = [];
	structs = getstructarray( "initial_spawn", "script_noteworthy" );
	foreach ( struct in structs )
	{
		tokens = strtok( struct.script_string, " " );
		foreach ( token in tokens )
		{
			spawnpoints[spawnpoints.size] = struct;
		}
	}
	spawnpoints = getstructarray( "initial_spawn_points", "targetname" );
/#
	assert( IsDefined( spawnpoints ), "Could not find initial spawn points!" );
#/
	spawnpoint = maps\mp\zombies\_zm::getfreespawnpoint( spawnpoints, self );
	return spawnpoint;
// SP = 0x0 - check OK
}

// 0x5FCC
check_for_valid_spawn_in_zone( player )
{
	a_spawn_points = maps\mp\gametypes_zm\_zm_gametype::get_player_spawns_for_gametype();
	str_player_zone = "zone_cellblock_west_gondola";
	str_player_zone = "zone_dock";
	str_player_zone = player maps\mp\zombies\_zm_zonemgr::get_player_zone();
	str_player_zone = player maps\mp\zombies\_zm_zonemgr::get_player_zone();
/#
	println( "The player is not in a zone at origin " + player.origin );
#/
	foreach ( spawn_point in a_spawn_points )
	{
		a_spawn_structs = getstructarray( spawn_point.target, "targetname" );
		a_spawn_structs = get_array_of_closest( player.origin, a_spawn_structs );
		foreach ( s_spawn in a_spawn_structs )
		{
			return s_spawn;
		}
		a_spawn_structs = get_array_of_farthest( player.origin, a_spawn_structs, undefined, 250000 );
		foreach ( s_spawn in a_spawn_structs )
		{
			return s_spawn;
		}
	}
	return undefined;
// SP = 0x0 - check OK
}

// 0x61D8
afterlife_save_perks( ent )
{
	perk_array = ent get_perk_array( 1 );
	foreach ( perk in perk_array )
	{
		ent unsetperk( perk );
	}
	return perk_array;
// SP = 0x0 - check OK
}

// 0x622C
afterlife_hostmigration()
{
	level waittill( "host_migration_end" );
	foreach ( player in getplayers() )
	{
		player setclientfieldtoplayer( "player_lives", player.lives );
		player.e_afterlife_corpse setclientfield( "player_corpse_id", 0 );
	}
	wait_network_frame();
	wait_network_frame();
	foreach ( player in getplayers() )
	{
		player.e_afterlife_corpse setclientfield( "player_corpse_id", player getentitynumber() + 1 );
	}
// SP = 0x0 - check OK
}

// 0x6314
afterlife_reduce_mana( n_mana )
{
	return;
	return;
	self.manacur = 200;
	return;
/#
	self.manacur = 200;
#/
	return;
	self.manacur -= n_mana;
// SP = 0x0 - check OK
}

// 0x63A4
afterlife_lightning_watch( corpse )
{
	self endon( "disconnect" );
	corpse endon( "player_revived" );
	self waittill( "weapon_fired" );
	self afterlife_reduce_mana( 1 );
	wait 0.05;
// SP = 0x0 - check OK
}

// 0x63E0
afterlife_jump_watch( corpse )
{
	self endon( "disconnect" );
	corpse endon( "player_revived" );
	self afterlife_reduce_mana( 0.3 );
	earthquake( 0.1, 0.05, self.origin, 200, self );
	wait 0.05;
// SP = 0x0 - check OK
}

// 0x6448
afterlife_trigger_create( s_origin )
{
	s_origin.unitrigger_stub = spawnstruct();
	s_origin.unitrigger_stub.origin = s_origin.origin;
	s_origin.unitrigger_stub.radius = 36;
	s_origin.unitrigger_stub.height = 256;
	s_origin.unitrigger_stub.script_unitrigger_type = "unitrigger_radius_use";
	s_origin.unitrigger_stub.hint_string = &"ZM_PRISON_AFTERLIFE_KILL";
	s_origin.unitrigger_stub.cursor_hint = "HINT_NOICON";
	s_origin.unitrigger_stub.require_look_at = 1;
	s_origin.unitrigger_stub.prompt_and_visibility_func = ::afterlife_trigger_visibility;
	maps\mp\zombies\_zm_unitrigger::unitrigger_force_per_player_triggers( s_origin.unitrigger_stub, 1 );
	maps\mp\zombies\_zm_unitrigger::register_static_unitrigger( s_origin.unitrigger_stub, ::afterlife_trigger_think );
// SP = 0x0 - check OK
}

// 0x6500
reset_all_afterlife_unitriggers()
{
	a_afterlife_triggers = getstructarray( "afterlife_trigger", "targetname" );
	foreach ( struct in a_afterlife_triggers )
	{
		maps\mp\zombies\_zm_unitrigger::unregister_unitrigger( struct.unitrigger_stub );
		maps\mp\zombies\_zm_unitrigger::register_static_unitrigger( struct.unitrigger_stub, ::afterlife_trigger_think );
	}
// SP = 0x0 - check OK
}

// 0x656C
afterlife_trigger_visibility( player )
{
	b_is_invis = player.afterlife;
	self setinvisibletoplayer( player, b_is_invis );
	self sethintstring( &"ZM_PRISON_OUT_OF_LIVES" );
	self sethintstring( self.stub.hint_string );
	player thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "general", "killswitch_clue" );
	player.has_played_afterlife_trigger_hint = 1;
	return !(b_is_invis);
// SP = 0x0 - check OK
}

// 0x661C
afterlife_trigger_think()
{
	self endon( "kill_trigger" );
	flag_wait( "start_zombie_round_logic" );
	self waittill( "trigger", player );
	self playsound( "zmb_no_cha_ching" );
	wait 0.1;
	self setinvisibletoplayer( player, 1 );
	self playsound( "zmb_afterlife_trigger_activate" );
	player playsoundtoplayer( "zmb_afterlife_trigger_electrocute", player );
	player thread afterlife_trigger_used_vo();
	self sethintstring( "" );
	player.keep_perks = 1;
	player afterlife_remove();
	player.afterlife = 1;
	player thread afterlife_laststand();
	e_fx = spawn( "script_model", self.origin );
	e_fx setmodel( "tag_origin" );
	e_fx.angles = vector_scale( ( 1, 0, 0 ), 90 );
	playfxontag( level._effect["afterlife_kill_point_fx"], e_fx, "tag_origin" );
	wait 2;
	e_fx delete();
	self sethintstring( &"ZM_PRISON_AFTERLIFE_KILL" );
// SP = 0x0 - check OK
}

// 0x6788
afterlife_interact_object_think()
{
	self endon( "afterlife_interact_complete" );
	n_total_interact_count = self.script_int;
	n_total_interact_count = 0;
	n_count = 0;
	self.health = 5000;
	self setcandamage( 1 );
	self useanimtree( -1 );
	self playloopsound( "zmb_afterlife_shockbox_off", 1 );
	level.shockbox_anim["on"] = %fxanim_zom_al_shock_box_on_anim;
	level.shockbox_anim["off"] = %fxanim_zom_al_shock_box_off_anim;
	trig_spawn_offset = ( 0, 0, 0 );
	self.t_bump = spawn( "trigger_radius", self.origin + vector_scale( ( 0, 1, 0 ), 28 ), 0, 28, 64 );
	trig_spawn_offset = ( 0, 11, 46 );
	str_hint = &"ZM_PRISON_AFTERLIFE_INTERACT";
	trig_spawn_offset = ( 32, 35, 58 );
	str_hint = &"ZM_PRISON_AFTERLIFE_OVERLOAD";
	afterlife_interact_hint_trigger_create( self, trig_spawn_offset, str_hint );
	self.unitrigger_stub.is_activated_in_afterlife = 0;
	self.t_bump setcursorhint( "HINT_NOICON" );
	self.t_bump sethintstring( &"ZM_PRISON_AFTERLIFE_INTERACT" );
	self waittill( "damage", amount, attacker );
	level notify( self.script_string );
	self.unitrigger_stub.is_activated_in_afterlife = 1;
	self.unitrigger_stub maps\mp\zombies\_zm_unitrigger::run_visibility_function_for_all_triggers();
	self.t_bump sethintstring( "" );
	self playloopsound( "zmb_afterlife_shockbox_on", 1 );
	playfxontag( level._effect["box_activated"], self, "tag_origin" );
	self.playing_fx = 1;
	self thread afterlife_interact_object_fx_cooldown();
	self playsound( "zmb_powerpanel_activate" );
	self setmodel( "p6_zm_al_shock_box_on" );
	self setanim( level.shockbox_anim["on"] );
	n_count++;
	self waittill( "afterlife_interact_reset" );
	self playloopsound( "zmb_afterlife_shockbox_off", 1 );
	self setmodel( "p6_zm_al_shock_box_off" );
	self setanim( level.shockbox_anim["off"] );
	self.unitrigger_stub.is_activated_in_afterlife = 0;
	self.unitrigger_stub maps\mp\zombies\_zm_unitrigger::run_visibility_function_for_all_triggers();
	self.t_bump delete();
// SP = 0x0 - check OK
}

// 0x6AFC
afterlife_interact_hint_trigger_create( m_interact, v_trig_offset, str_hint )
{
	m_interact.unitrigger_stub = spawnstruct();
	m_interact.unitrigger_stub.origin = ( ( m_interact.origin + anglestoforward( m_interact.angles ) * v_trig_offset[0] ) + anglestoright( m_interact.angles ) * v_trig_offset[1] ) + anglestoup( m_interact.angles ) * v_trig_offset[2];
	m_interact.unitrigger_stub.radius = 40;
	m_interact.unitrigger_stub.height = 64;
	m_interact.unitrigger_stub.script_unitrigger_type = "unitrigger_radius_use";
	m_interact.unitrigger_stub.hint_string = str_hint;
	m_interact.unitrigger_stub.cursor_hint = "HINT_NOICON";
	m_interact.unitrigger_stub.require_look_at = 1;
	m_interact.unitrigger_stub.ignore_player_valid = 1;
	m_interact.unitrigger_stub.prompt_and_visibility_func = ::afterlife_trigger_visible_in_afterlife;
	maps\mp\zombies\_zm_unitrigger::register_static_unitrigger( m_interact.unitrigger_stub, ::afterlife_interact_hint_trigger_think );
// SP = 0x0 - check OK
}

// 0x6BE0
afterlife_trigger_visible_in_afterlife( player )
{
	b_is_invis = self.stub.is_activated_in_afterlife;
	self setinvisibletoplayer( player, b_is_invis );
	self sethintstring( self.stub.hint_string );
	player thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "general", "need_electricity" );
	player thread maps\mp\zombies\_zm_audio::create_and_play_dialog( "general", "electric_zap" );
	return !(b_is_invis);
// SP = 0x0 - check OK
}

// 0x6C78
afterlife_interact_hint_trigger_think()
{
	self endon( "kill_trigger" );
	self waittill( "trigger" );
	wait 1000;
// SP = 0x0 - check OK
}

// 0x6C98
afterlife_interact_object_fx_cooldown()
{
	wait 2;
	self.playing_fx = undefined;
// SP = 0x0 - check OK
}

// 0x6CA8
afterlife_zombie_damage()
{
	self.actor_damage_func = ::afterlife_damage_func;
// SP = 0x0 - check OK
}

// 0x6CBC
afterlife_damage_func( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime )
{
	a_zombies = get_array_of_closest( self.origin, getaiarray( "axis" ), undefined, 5, 80 );
	i = 0;
	a_zombies[i] notify( "zapped" );
	a_zombies[i] thread [[level.afterlife_zapped]]();
	wait 0.05;
	i++;
	return 0;
	return idamage;
// SP = 0x0 - check OK
}

// 0x6D64
afterlife_zapped()
{
	self endon( "death" );
	self endon( "zapped" );
	self.zapped = 1;
	n_ideal_dist_sq = 490000;
	n_min_dist_sq = 10000;
	a_nodes = getanynodearray( self.origin, 1200 );
	a_nodes = arraycombine( a_nodes, getanynodearray( self.origin + vector_scale( ( 0, 0, 1 ), 120 ), 1200 ), 0, 0 );
	a_nodes = arraycombine( a_nodes, getanynodearray( self.origin - vector_scale( ( 0, 0, 1 ), 120 ), 1200 ), 0, 0 );
	a_nodes = array_randomize( a_nodes );
	nd_target = undefined;
	i = 0;
	nd_target = a_nodes[i];
	i++;
	i = 0;
	nd_target = a_nodes[i];
	i++;
	v_fx_offset = vector_scale( ( 0, 0, 1 ), 40 );
	playfx( level._effect["afterlife_teleport"], self.origin );
	playsoundatposition( "zmb_afterlife_zombie_warp_out", self.origin );
	self hide();
	linker = spawn( "script_model", self.origin + v_fx_offset );
	linker setmodel( "tag_origin" );
	playfxontag( level._effect["teleport_ball"], linker, "tag_origin" );
	linker thread linker_delete_watch( self );
	self linkto( linker );
	linker moveto( nd_target.origin + v_fx_offset, 1 );
	linker waittill( "movedone" );
	linker delete();
	playfx( level._effect["afterlife_teleport"], self.origin );
	playsoundatposition( "zmb_afterlife_zombie_warp_in", self.origin );
	self show();
/#
	iprintln( "Could not teleport" );
#/
	playfx( level._effect["afterlife_teleport"], self.origin );
	playsoundatposition( "zmb_afterlife_zombie_warp_out", self.origin );
	level.zombie_total++;
	self delete();
	return;
	self.zapped = undefined;
	self.ignoreall = 1;
	self notify( "stop_find_flesh" );
	self thread afterlife_zapped_fx();
	i = 0;
	self animscripted( self.origin, self.angles, "zm_afterlife_stun" );
	self maps\mp\animscripts\shared::donotetracks( "stunned" );
	i++;
	self.ignoreall = 0;
	self thread maps\mp\zombies\_zm_ai_basic::find_flesh();
// SP = 0x0 - check OK
}

// 0x706C
is_valid_teleport_node()
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x70BC
linker_delete_watch( ai_zombie )
{
	self endon( "death" );
	ai_zombie waittill( "death" );
	self delete();
// SP = 0x0 - check OK
}

// 0x70E0
afterlife_zapped_fx()
{
	self endon( "death" );
	playfxontag( level._effect["elec_torso"], self, "J_SpineLower" );
	self playsound( "zmb_elec_jib_zombie" );
	wait 1;
	tagarray = [];
	tagarray[0] = "J_Elbow_LE";
	tagarray[1] = "J_Elbow_RI";
	tagarray[2] = "J_Knee_RI";
	tagarray[3] = "J_Knee_LE";
	tagarray = array_randomize( tagarray );
	playfxontag( level._effect["elec_md"], self, tagarray[0] );
	self playsound( "zmb_elec_jib_zombie" );
	wait 1;
	self playsound( "zmb_elec_jib_zombie" );
	tagarray[0] = "J_Wrist_RI";
	tagarray[1] = "J_Wrist_LE";
	tagarray[2] = "J_Ankle_RI";
	tagarray[3] = "J_Ankle_LE";
	tagarray = array_randomize( tagarray );
	playfxontag( level._effect["elec_sm"], self, tagarray[0] );
	playfxontag( level._effect["elec_sm"], self, tagarray[1] );
// SP = 0x0 - check OK
}

// 0x7208
enable_afterlife_prop()
{
	self show();
	self.script_noteworthy = "afterlife_prop";
	a_players = getplayers();
	foreach ( player in a_players )
	{
		self setvisibletoplayer( player );
		self setinvisibletoplayer( player );
	}
// SP = 0x0 - check OK
}

// 0x728C
disable_afterlife_prop()
{
	self.script_noteworthy = undefined;
	self setvisibletoall();
// SP = 0x0 - check OK
}

// 0x72A4
last_stand_conscience_vo()
{
	self endon( "player_revived" );
	self endon( "player_suicide" );
	self endon( "zombified" );
	self endon( "disconnect" );
	self endon( "end_game" );
	self.conscience_vo_played = 0;
	self.conscience_vo_played++;
	convo = [];
	convo = level.conscience_vo["conscience_" + self.character_name + "_convo_" + self.conscience_vo_played];
	wait 5;
	a_players = getplayers();
	foreach ( player in a_players )
	{
	}
	self.dontspeak = 1;
	i = 0;
	n_duration = soundgetplaybacktime( convo[i] );
	self playsoundtoplayer( convo[i], self );
	self thread conscience_vo_ended_early( convo[i] );
	wait n_duration / 1000;
	wait 0.5;
	i++;
	self.dontspeak = 0;
// SP = 0x0 - check OK
}

// 0x73D8
conscience_vo_ended_early( str_alias )
{
	self notify( "conscience_VO_end_early" );
	self endon( "conscience_VO_end_early" );
	self waittill_any( "player_revived", "player_suicide", "zombified", "death", "end_game" );
	self.dontspeak = 0;
	self stoplocalsound( str_alias );
// SP = 0x0 - check OK
}

// 0x7420
afterlife_trigger_used_vo()
{
	a_vo = level.exert_sounds[self.characterindex + 1]["hitlrg"];
	n_index = randomint( a_vo.size );
	self playsound( a_vo[n_index] );
// SP = 0x0 - check OK
}