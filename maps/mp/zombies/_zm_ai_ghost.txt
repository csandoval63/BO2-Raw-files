// maps/mp/zombies/_zm_ai_ghost.gsc

#include maps\mp\zombies\_zm_ai_basic;
#include maps\mp\zombies\_zm_powerups;
#include maps\mp\zombies\_zm_weap_time_bomb;
#include maps\mp\zombies\_zm_laststand;
#include maps\mp\zombies\_zm_score;
#include maps\mp\zombies\_zm_stats;
#include maps\mp\animscripts\zm_shared;
#include maps\mp\zombies\_zm_weap_slowgun;
#include maps\mp\zombies\_zm_spawner;
#include maps\mp\zombies\_zm_ai_ghost;
#include maps\mp\zombies\_zm_ai_ghost_ffotd;
#include maps\mp\animscripts\zm_utility;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\_utility;
#include common_scripts\utility;

#using_animtree ( "zm_buried_ghost" );


// 0x350C
precache()
{
// SP = 0x0 - check OK
}

// 0x3514
init_animtree()
{
	scriptmodelsuseanimtree( -1 );
// SP = 0x0 - check OK
}

// 0x352C
precache_fx()
{
	level.ghost_effects = [];
	level.ghost_effects[1] = loadfx( "maps/zombie_buried/fx_buried_ghost_death" );
	level.ghost_effects[2] = loadfx( "maps/zombie_buried/fx_buried_ghost_drain" );
	level.ghost_effects[3] = loadfx( "maps/zombie_buried/fx_buried_ghost_spawn" );
	level.ghost_effects[4] = loadfx( "maps/zombie_buried/fx_buried_ghost_trail" );
	level.ghost_effects[5] = loadfx( "maps/zombie_buried/fx_buried_ghost_evaporation" );
	level.ghost_impact_effects[1] = loadfx( "maps/zombie_buried/fx_buried_ghost_impact" );
// SP = 0x0 - check OK
}

// 0x35BC
init()
{
	maps\mp\zombies\_zm_ai_ghost_ffotd::ghost_init_start();
	register_client_fields();
	flag_init( "spawn_ghosts" );
	return;
	init_ghost_zone();
	init_ghost_sounds();
	init_ghost_script_move_path_data();
	level.zombie_ai_limit_ghost = 4;
	level.zombie_ai_limit_ghost_per_player = 1;
	level.zombie_ghost_count = 0;
	level.ghost_health = 100;
	level.zombie_ghost_round_states = spawnstruct();
	level.zombie_ghost_round_states.any_player_in_ghost_zone = 0;
	level.zombie_ghost_round_states.active_zombie_locations = [];
	level.is_ghost_round_started = ::is_ghost_round_started;
	level.zombie_ghost_round_states.is_started = 0;
	level.zombie_ghost_round_states.is_first_ghost_round_finished = 0;
	level.zombie_ghost_round_states.current_ghost_round_number = 0;
	level.zombie_ghost_round_states.next_ghost_round_number = 0;
	level.zombie_ghost_round_states.presentation_stage_1_started = 0;
	level.zombie_ghost_round_states.presentation_stage_2_started = 0;
	level.zombie_ghost_round_states.presentation_stage_3_started = 0;
	level.zombie_ghost_round_states.is_teleporting = 0;
	level.zombie_ghost_round_states.round_count = 0;
	level thread ghost_round_presentation_think();
	level thread [[level.ghost_round_think_override_func]]();
	level thread ghost_round_think();
	level thread player_in_ghost_zone_monitor();
	level thread [[level.ghost_zone_spawning_think_override_func]]();
	level thread ghost_zone_spawning_think();
	level thread ghost_vox_think();
	init_time_bomb_ghost_rounds();
/#
	level.force_no_ghost = 0;
	level.ghost_devgui_toggle_no_ghost = ::devgui_toggle_no_ghost;
	level.ghost_devgui_warp_to_mansion = ::devgui_warp_to_mansion;
#/
	maps\mp\zombies\_zm_ai_ghost_ffotd::ghost_init_end();
// SP = 0x0 - check OK
}

// 0x373C
init_ghost_spawners()
{
	level.ghost_spawners = getentarray( "ghost_zombie_spawner", "script_noteworthy" );
	return 0;
	array_thread( level.ghost_spawners, ::add_spawn_function, maps\mp\zombies\_zm_ai_ghost::prespawn );
	foreach ( spawner in level.ghost_spawners )
	{
		level.female_ghost_spawner = spawner;
	}
	return 1;
// SP = 0x0 - check OK
}

// 0x37C8
init_ghost_script_move_path_data()
{
	level.ghost_script_move_sin = [];
	degree = 0;
	level.ghost_script_move_sin[level.ghost_script_move_sin.size] = sin( degree );
	degree += 15;
// SP = 0x0 - check OK
}

// 0x380C
init_ghost_sounds()
{
	level.ghost_vox = [];
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_0";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_1";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_2";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_3";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_4";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_5";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_6";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_7";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_8";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_9";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_10";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_11";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_12";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_13";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_14";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_15";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_16";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_17";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_18";
	level.ghost_vox[level.ghost_vox.size] = "vox_fg_ghost_haunt_19";
// SP = 0x0 - check OK
}

// 0x3958
init_ghost_zone()
{
	level.ghost_start_area = getent( "ghost_start_area", "targetname" );
	level.ghost_zone_door_clips = getentarray( "ghost_zone_door_clip", "targetname" );
	enable_ghost_zone_door_ai_clips();
	level.ghost_zone_start_lower_locations = getstructarray( "ghost_zone_start_lower_location", "targetname" );
	level.ghost_drop_down_locations = getstructarray( "ghost_start_zone_spawners", "targetname" );
	level.ghost_front_standing_locations = getstructarray( "ghost_front_standing_location", "targetname" );
	level.ghost_back_standing_locations = getstructarray( "ghost_back_standing_location", "targetname" );
	level.ghost_front_flying_out_path_starts = getstructarray( "ghost_front_flying_out_path_start", "targetname" );
	level.ghost_back_flying_out_path_starts = getstructarray( "ghost_back_flying_out_path_start", "targetname" );
	level.ghost_gazebo_pit_volume = getent( "sloth_pack_volume", "targetname" );
	level.ghost_gazebo_pit_perk_pos = getstruct( "ghost_gazebo_pit_perk_pos", "targetname" );
	level.ghost_entry_room_to_mansion = "ghost_to_maze_zone_1";
	level.ghost_entry_room_to_maze = "ghost_to_maze_zone_5";
	level.ghost_rooms = [];
	a_rooms = getentarray( "ghost_zone", "script_noteworthy" );
	foreach ( room in a_rooms )
	{
		str_targetname = room.targetname;
		level.ghost_rooms[str_targetname] = spawnstruct();
		level.ghost_rooms[str_targetname].ghost_spawn_locations = [];
		level.ghost_rooms[str_targetname].volumes = [];
		level.ghost_rooms[str_targetname].name = str_targetname;
		level.ghost_rooms[str_targetname].from_maze = 1;
		level.ghost_rooms[str_targetname].to_maze = 1;
/#
		assert( IsDefined( room.target ), "ghost zone with targetname '" + str_targetname + "' is missing spawner target! This is used to pair zones with spawners." );
#/
		a_ghost_spawn_locations = getstructarray( room.target, "targetname" );
		level.ghost_rooms[str_targetname].ghost_spawn_locations = arraycombine( a_ghost_spawn_locations, level.ghost_rooms[str_targetname].ghost_spawn_locations, 0, 0 );
		level.ghost_rooms[str_targetname].volumes[level.ghost_rooms[str_targetname].volumes.size] = room;
		level.ghost_rooms[str_targetname].next_room_names = strtok( room.script_string, " " );
		level.ghost_rooms[str_targetname].previous_room_names = strtok( room.script_parameters, " " );
		level.ghost_rooms[str_targetname].flag = room.script_flag;
	}
// SP = 0x0 - check OK
}

// 0x3C0C
register_client_fields()
{
	registerclientfield( "actor", "ghost_impact_fx", 12000, 1, "int" );
	registerclientfield( "actor", "ghost_fx", 12000, 3, "int" );
	registerclientfield( "actor", "sndGhostAudio", 12000, 3, "int" );
	registerclientfield( "scriptmover", "ghost_fx", 12000, 3, "int" );
	registerclientfield( "scriptmover", "sndGhostAudio", 12000, 3, "int" );
	registerclientfield( "world", "ghost_round_light_state", 12000, 1, "int" );
// SP = 0x0 - check OK
}

// 0x3CBC
is_player_fully_claimed( player )
{
	result = 0;
	result = 1;
	return result;
// SP = 0x0 - check OK
}

// 0x3CEC
ghost_zone_spawning_think()
{
	level endon( "intermission" );
	return;
/#
	assertmsg( "No female ghost spawner in the map.  Check to see if the zone is active and if it's pointing to spawners." );
#/
	return;
	wait 0.1;
	valid_player_count = 0;
	valid_players = [];
	players = getplayers();
	valid_player_count = 0;
	foreach ( player in players )
	{
		valid_player_count++;
		valid_players[valid_players.size] = player;
	}
	wait 0.1;
	valid_players = array_randomize( valid_players );
	spawn_point = get_best_spawn_point( valid_players[0] );
	wait 0.1;
/#
	wait 0.1;
#/
	ghost_ai = undefined;
	ghost_ai = spawn_zombie( level.female_ghost_spawner, level.female_ghost_spawner.targetname, spawn_point );
/#
	assertmsg( "No female ghost spawner in the map." );
#/
	return;
	ghost_ai setclientfield( "ghost_fx", 3 );
	ghost_ai.spawn_point = spawn_point;
	ghost_ai.is_ghost = 1;
	ghost_ai.is_spawned_in_ghost_zone = 1;
	ghost_ai.find_target = 1;
	level.zombie_ghost_count++;
/#
	ghost_print( "ghost total " + level.zombie_ghost_count );
#/
/#
	assertmsg( "Female ghost: failed spawn" );
#/
	return;
	wait 0.1;
// SP = 0x0 - check OK
}

// 0x3F0C
is_player_in_ghost_room( player, room )
{
	foreach ( volume in room.volumes )
	{
		return 1;
	}
	return 0;
// SP = 0x0 - check OK
}

// 0x3F5C
is_player_in_ghost_rooms( player, room_names )
{
	result = 0;
	foreach ( room_name in room_names )
	{
		next_room = level.ghost_rooms[room_name];
		player.current_ghost_room_name = next_room.name;
		result = 1;
	}
	return result;
// SP = 0x0 - check OK
}

// 0x3FD8
player_in_ghost_zone_monitor()
{
	level endon( "intermission" );
	return;
	players = getplayers();
	foreach ( player in players )
	{
		current_room = level.ghost_rooms[player.current_ghost_room_name];
/#
		foreach ( ghost_location in current_room.ghost_spawn_locations )
		{
			draw_debug_star( ghost_location.origin, ( 0, 0, 1 ), 2 );
		}
		foreach ( volume in current_room.volumes )
		{
			draw_debug_box( volume.origin, vector_scale( ( -1, -1, -1 ), 5 ), vector_scale( ( 1, 1, 1 ), 5 ), volume.angles[1], vector_scale( ( 0, 1, 0 ), 0.5 ), 2 );
		}
#/
		player.current_ghost_room_name = current_room.name;
		player.current_ghost_room_name = level.ghost_entry_room_to_mansion;
	}
	wait 0.1;
// SP = 0x0 - check OK
}

// 0x4198
is_any_player_near_point( target, spawn_pos )
{
	players = getplayers();
	foreach ( player in players )
	{
		dist_squared = distancesquared( player.origin, spawn_pos );
		return 1;
	}
	return 0;
// SP = 0x0 - check OK
}

// 0x4218
is_in_start_area()
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x4240
get_best_spawn_point( player )
{
	spawn_point = undefined;
	min_distance_squared = 9600 * 9600;
	selected_locations = [];
	current_ghost_room_name = player.current_ghost_room_name;
	foreach ( ghost_location in level.ghost_rooms[current_ghost_room_name].ghost_spawn_locations )
	{
		player_eye_pos = player geteyeapprox();
		line_of_sight = sighttracepassed( player_eye_pos, ghost_location.origin, 0, self );
		selected_locations[selected_locations.size] = ghost_location;
	}
	selected_location = selected_locations[randomint( selected_locations.size )];
/#
	draw_debug_line( player.origin, selected_location.origin, ( 0, 1, 0 ), 10, 0 );
#/
	return selected_location;
	random_index = randomint( level.ghost_back_standing_locations.size );
	return level.ghost_back_standing_locations[random_index];
	random_index = randomint( level.ghost_zone_start_lower_locations.size );
	return level.ghost_zone_start_lower_locations[random_index];
	random_index = randomint( level.ghost_front_standing_locations.size );
	return level.ghost_front_standing_locations[random_index];
	return undefined;
// SP = 0x0 - check OK
}

// 0x4404
check_players_in_ghost_zone()
{
	result = 0;
	players = getplayers();
	foreach ( player in players )
	{
		result = 1;
	}
	return result;
// SP = 0x0 - check OK
}

// 0x4470
player_in_ghost_zone( player )
{
	result = 0;
	result = [[level.is_player_in_ghost_zone]]( player );
	player.is_in_ghost_zone = result;
	return result;
// SP = 0x0 - check OK
}

// 0x44A0
ghost_vox_think()
{
	level endon( "end_game" );
	level endon( "intermission" );
	return;
	ghosts = get_current_ghosts();
	foreach ( ghost in ghosts )
	{
		ghost thread ghost_talk_to_target( ghost.favoriteenemy );
	}
	wait randomintrange( 2, 6 );
// SP = 0x0 - check OK
}

// 0x4554
ghost_talk_to_target( player )
{
	self endon( "death" );
	level endon( "intermission" );
	vox_index = randomint( level.ghost_vox.size );
	vox_line = level.ghost_vox[vox_index];
	self playsoundtoplayer( vox_line, player );
	player.ghost_talking = 1;
	wait 6;
	player.ghost_talking = 0;
// SP = 0x0 - check OK
}

// 0x45B0
prespawn()
{
	self endon( "death" );
	level endon( "intermission" );
	self maps\mp\zombies\_zm_ai_ghost_ffotd::prespawn_start();
	self.startinglocation = self.origin;
	self.animname = "ghost_zombie";
	self.audio_type = "ghost";
	self.has_legs = 1;
	self.no_gib = 1;
	self.ignore_enemy_count = 1;
	self.ignore_equipment = 1;
	self.ignore_claymore = 0;
	self.force_killable_timer = 0;
	self.noplayermeleeblood = 1;
	self.paralyzer_hit_callback = ::paralyzer_callback;
	self.paralyzer_slowtime = 0;
	self.paralyzer_score_time_ms = GetTime();
	self.ignore_slowgun_anim_rates = undefined;
	self.reset_anim = ::ghost_reset_anim;
	self.custom_springpad_fling = ::ghost_springpad_fling;
	self.bookcase_entering_callback = ::bookcase_entering_callback;
	self.ignore_subwoofer = 1;
	self.ignore_headchopper = 1;
	self.ignore_spring_pad = 1;
	recalc_zombie_array();
	self setphysparams( 15, 0, 72 );
	self.cant_melee = 1;
	spot = self.spawn_point;
	spot.angles = ( 0, 0, 0 );
	self forceteleport( spot.origin, spot.angles );
	self set_zombie_run_cycle( "run" );
	self setanimstatefromasd( "zm_move_run" );
	self.actor_damage_func = ::ghost_damage_func;
	self.deathfunction = ::ghost_death_func;
	self.maxhealth = level.ghost_health;
	self.health = level.ghost_health;
	self.zombie_init_done = 1;
	self notify( "zombie_init_done" );
	self.allowpain = 0;
	self.ignore_nuke = 1;
	self animmode( "normal" );
	self orientmode( "face enemy" );
	self bloodimpact( "none" );
	self disableaimassist();
	self.forcemovementscriptstate = 0;
	self maps\mp\zombies\_zm_spawner::zombie_setup_attack_properties();
	self.pathenemyfightdist = 0;
	self maps\mp\zombies\_zm_spawner::zombie_complete_emerging_into_playable_area();
	self setfreecameralockonallowed( 0 );
	self.startinglocation = self.origin;
	self [[level.ghost_custom_think_logic]]();
	self.bad_path_failsafe = maps\mp\zombies\_zm_ai_ghost_ffotd::ghost_bad_path_failsafe;
	self thread ghost_think();
	self.attack_time = 0;
	self.ignore_inert = 1;
	self.subwoofer_burst_func = ::subwoofer_burst_func;
	self.subwoofer_fling_func = ::subwoofer_fling_func;
	self.subwoofer_knockdown_func = ::subwoofer_knockdown_func;
	self maps\mp\zombies\_zm_ai_ghost_ffotd::prespawn_end();
// SP = 0x0 - check OK
}

// 0x4824
bookcase_entering_callback( bookcase_door )
{
	self endon( "death" );
	self.need_wait = 1;
	wait 2.1;
	self.need_wait = 0;
	self.need_wait = 0;
	self.need_wait = 1;
	wait 0.1;
// SP = 0x0 - check OK
}

// 0x4898
ghost_damage_func( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime, boneindex )
{
	self.damageweapon_name = sweapon;
	self check_zombie_damage_callbacks( smeansofdeath, shitloc, vpoint, eattacker, idamage );
	self.damageweapon_name = undefined;
	self.killed_by = eattacker;
	self thread prepare_to_die();
	self thread set_impact_effect();
	return idamage;
// SP = 0x0 - check OK
}

// 0x4908
set_impact_effect()
{
	self endon( "death" );
	self setclientfield( "ghost_impact_fx", 1 );
	wait_network_frame();
	self setclientfield( "ghost_impact_fx", 0 );
// SP = 0x0 - check OK
}

// 0x493C
prepare_to_die()
{
	qrate = self getclientfield( "anim_rate" );
	self.ignore_slowgun_anim_rates = 1;
	self setclientfield( "anim_rate", 1 );
	qrate = self getclientfield( "anim_rate" );
	self setentityanimrate( qrate );
	self.slowgun_anim_rate = qrate;
	wait_network_frame();
	self setclientfield( "anim_rate", 0.8 );
	qrate = self getclientfield( "anim_rate" );
	self setentityanimrate( qrate );
	wait_network_frame();
	ghost_reset_anim();
// SP = 0x0 - check OK
}

// 0x49F0
ghost_reset_anim()
{
	return;
	animstate = self getanimstatefromasd();
	substate = self getanimsubstatefromasd();
	self setanimstatefromasd( "zm_death_no_restart", substate );
	self maps\mp\zombies\_zm_weap_slowgun::reset_anim();
// SP = 0x0 - check OK
}

// 0x4A44
wait_ghost_ghost( time )
{
	wait time;
	self ghost();
// SP = 0x0 - check OK
}

// 0x4A60
ghost_death_func()
{
	level.ghost_round_last_ghost_origin = self.origin;
	self stoploopsound( 1 );
	self playsound( "zmb_ai_ghost_death" );
	self setclientfield( "ghost_impact_fx", 1 );
	self setclientfield( "ghost_fx", 1 );
	self thread prepare_to_die();
	self thread [[self.extra_custom_death_logic]]();
	qrate = self getclientfield( "anim_rate" );
	self setanimstatefromasd( "zm_death" );
	self thread wait_ghost_ghost( self getanimlengthfromasd( "zm_death", 0 ) );
	maps\mp\animscripts\zm_shared::donotetracks( "death_anim" );
	level.zombie_ghost_count--;
	self.favoriteenemy.ghost_count--;
	player = undefined;
	give_player_rewards( self.attacker );
	player = self.attacker;
	give_player_rewards( self.attacker.owner );
	player = self.attacker.owner;
	player maps\mp\zombies\_zm_stats::increment_client_stat( "buried_ghost_killed", 0 );
	player maps\mp\zombies\_zm_stats::increment_player_stat( "buried_ghost_killed" );
	self delete();
	return 1;
// SP = 0x0 - check OK
}

// 0x4C00
subwoofer_burst_func( weapon )
{
	self dodamage( self.health + 666, weapon.origin );
// SP = 0x0 - check OK
}

// 0x4C24
subwoofer_fling_func( weapon, fling_vec )
{
	self dodamage( self.health + 666, weapon.origin );
// SP = 0x0 - check OK
}

// 0x4C4C
subwoofer_knockdown_func( weapon, gib )
{
// SP = 0x0 - check OK
}

// 0x4C58
ghost_think()
{
	self endon( "death" );
	level endon( "intermission" );
	return;
	shouldwait = self [[level.ghost_custom_think_func_logic]]();
	self waittill( "ghost_custom_think_done", find_flesh_struct_string );
	self.ignore_slowgun_anim_rates = undefined;
	self maps\mp\zombies\_zm_weap_slowgun::set_anim_rate( 1 );
	self setclientfield( "slowgun_fx", 0 );
	self setclientfield( "sndGhostAudio", 1 );
	self init_thinking();
	self start_script_move();
	self start_spawn();
	self start_chase();
	self thread [[self.bad_path_failsafe]]();
	switch ( self.state )
	{
		case "chase_update":
			self script_move_update();
			break;
		case "drain_update":
			self chase_update();
			break;
		case "evaporate_update":
			self drain_update();
			break;
		case "runaway_update":
			self runaway_update();
			break;
		case "script_move_update":
			self evaporate_update();
			break;
		case "wait_update":
			self wait_update();
			break;
	}
	wait 0.1;
// SP = 0x0 - check OK
}

// 0x4DEC
start_spawn()
{
	self animscripted( self.origin, self.angles, "zm_spawn" );
	self maps\mp\animscripts\zm_shared::donotetracks( "spawn_anim" );
	self start_chase();
// SP = 0x0 - check OK
}

// 0x4E28
init_thinking()
{
	self thread find_flesh();
// SP = 0x0 - check OK
}

// 0x4E3C
find_flesh()
{
	self endon( "death" );
	level endon( "intermission" );
	self endon( "stop_find_flesh" );
	return;
	self.nododgemove = 1;
	self.ignore_player = [];
	self zombie_history( "ghost find flesh -> start" );
	self.goalradius = 32;
	self.favoriteenemy = get_closest_valid_player( self.origin );
	self.find_target = 0;
	self.favoriteenemy = get_closest_valid_player( self.origin );
	self thread zombie_pathing();
	self.find_target = 1;
	self.zombie_path_timer = GetTime() + randomfloatrange( 1, 3 ) * 1000;
	wait 0.1;
	self notify( "path_timer_done" );
	self zombie_history( "ghost find flesh -> path timer done" );
	debug_print( "Zombie is re-acquiring enemy, ending breadcrumb search" );
	self notify( "zombie_acquire_enemy" );
// SP = 0x0 - check OK
}

// 0x4F68
get_closest_valid_player( origin )
{
	valid_player_found = 0;
	players = get_players();
	player = get_closest_player( origin, players );
	return undefined;
	player_claimed_fully = is_player_fully_claimed( player );
	return undefined;
	arrayremovevalue( players, player );
	self.need_script_move = 1;
	player.ghost_count = 1;
	player.ghost_count += 1;
	arrayremovevalue( players, player );
	return player;
// SP = 0x0 - check OK
}

// 0x509C
get_closest_player( origin, players )
{
	min_length_to_player = 9999999;
	player_to_return = undefined;
	i = 0;
	player = players[i];
	length_to_player = get_path_length_to_enemy( player );
	min_length_to_player = length_to_player;
	player_to_return = player;
	i++;
	player_to_return = getclosest( origin, players );
	return player_to_return;
// SP = 0x0 - check OK
}

// 0x5120
does_fall_into_pap_hole()
{
	self forceteleport( level.ghost_gazebo_pit_perk_pos.origin, ( 0, 0, 0 ) );
	wait 0.1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x515C
start_script_move()
{
	self.script_mover = spawn( "script_origin", self.origin );
	self.script_mover.angles = self.angles;
	self linkto( self.script_mover );
	self.state = "script_move_update";
	self setclientfield( "ghost_fx", 4 );
	player = self.favoriteenemy;
	start_location = undefined;
	start_location = level.ghost_back_flying_out_path_starts[0];
	start_location = level.ghost_front_flying_out_path_starts[0];
	self.script_move_target_node = self get_best_flying_target_node( player, start_location.origin );
	self.script_move_sin_index = 0;
// SP = 0x0 - check OK
}

// 0x521C
get_best_flying_target_node( player, start_loc )
{
	nearest_node = getnearestnode( player.origin );
	nodes = getnodesinradiussorted( player.origin, 540, 180, 60, "Path" );
	nearest_node = nodes[0];
	selected_node = nearest_node;
	max_distance_squared = 0;
	start_pos = ( player.origin[0], player.origin[1], player.origin[2] + 60 );
	i = nodes.size - 1;
	node = nodes[i];
	end_pos = ( node.origin[0], node.origin[1], node.origin[2] + 60 );
	line_of_sight = sighttracepassed( start_pos, end_pos, 0, player );
	draw_debug_star( node.origin, ( 0, 0, 1 ), 100 );
	selected_node = node;
	selected_node = node;
	i--;
	return selected_node;
// SP = 0x0 - check OK
}

// 0x5350
script_move_update()
{
	return;
	player = self.favoriteenemy;
	desired_angles = vectortoangles( vectornormalize( player.origin - self.origin ) );
	distance_squared = distancesquared( self.origin, self.script_move_target_node.origin );
	self.script_mover.angles = desired_angles;
	self remove_script_mover();
	wait_network_frame();
	self setclientfield( "ghost_fx", 3 );
	self setclientfield( "sndGhostAudio", 1 );
	wait_network_frame();
	self start_chase();
	return;
	draw_debug_star( self.script_move_target_node.origin, ( 0, 0, 1 ), 1 );
	target_node_pos = self.script_move_target_node.origin + vector_scale( ( 0, 0, 1 ), 36 );
	distance_squared_to_target_node_pos = distancesquared( self.origin, target_node_pos );
	moved_distance_during_interval = 80;
	target_point = self.script_move_target_node.origin;
	self.script_mover moveto( target_point, 0.1, 0, 0.1 );
	self.script_mover waittill( "movedone" );
	self.script_mover.angles = desired_angles;
	distance_squared_to_player = distancesquared( self.origin, player.origin );
	self get_best_flying_target_node( player, self.script_move_target_node.origin );
	self.script_mover.search_target_node_again = 1;
	self.script_move_sin_index = 0;
	move_dir = target_node_pos - self.origin;
	move_dir = vectornormalize( move_dir );
	target_point = ( self.origin + move_dir ) * ( 800 * 0.1 );
	x_offset = level.ghost_script_move_sin[self.script_move_sin_index] * 6;
	z_offset = level.ghost_script_move_sin[self.script_move_sin_index] * 12;
	target_point += ( x_offset, 0, z_offset );
	self.script_move_sin_index++;
	self.script_mover moveto( target_point, 0.1 );
	self.script_mover.angles = desired_angles;
	draw_debug_star( target_point, ( 0, 1, 0 ), 1 );
	self remove_script_mover();
	self start_evaporate( 1 );
// SP = 0x0 - check OK
}

// 0x55D0
remove_script_mover()
{
	self dontinterpolate();
	self unlink();
	self.script_mover delete();
// SP = 0x0 - check OK
}

// 0x5604
start_chase()
{
	self set_zombie_run_cycle( "run" );
	self setanimstatefromasd( "zm_move_run" );
	self.state = "chase_update";
	self setclientfield( "ghost_fx", 4 );
// SP = 0x0 - check OK
}

// 0x5644
chase_update()
{
	return;
	player = self.favoriteenemy;
	self start_runaway();
	return;
	self dodamage( self.health + 666, self.origin );
	return;
	self start_wait();
	return;
	ghost_check_point = self.origin + ( 0, 0, 60 );
	player_eye_pos = player geteyeapprox();
	line_of_sight = sighttracepassed( ghost_check_point, player_eye_pos, 0, self );
	self start_drain();
	return;
	distsquared = distancesquared( self.origin, player.origin );
	current_room = level.ghost_rooms[player.current_ghost_room_name];
	set_chase_status( "run" );
	self start_evaporate( 1 );
	set_chase_status( "run" );
	teleport_location = level.ghost_front_flying_out_path_starts[0];
	self forceteleport( teleport_location.origin, ( 0, 0, 0 ) );
	set_chase_status( "run" );
	set_chase_status( "walk" );
	self set_zombie_run_cycle( "run" );
	self setanimstatefromasd( "zm_move_run" );
	self start_runaway();
// SP = 0x0 - check OK
}

// 0x589C
need_wait()
{
	return self.need_wait;
// SP = 0x0 - check OK
}

// 0x58B0
start_wait()
{
	self setanimstatefromasd( "zm_idle" );
	self setclientfield( "ghost_fx", 4 );
	self.state = "wait_update";
// SP = 0x0 - check OK
}

// 0x58E0
wait_update()
{
	return;
	player = self.favoriteenemy;
	ghost_check_point = self.origin + ( 0, 0, 60 );
	player_eye_pos = player geteyeapprox();
	line_of_sight = sighttracepassed( ghost_check_point, player_eye_pos, 0, self );
	self start_drain();
	return;
	self start_chase();
	self set_zombie_run_cycle( "run" );
	self setanimstatefromasd( "zm_move_run" );
	self setclientfield( "ghost_fx", 4 );
	self start_runaway();
// SP = 0x0 - check OK
}

// 0x59D4
start_evaporate( need_deletion )
{
	self setclientfield( "ghost_fx", 5 );
	wait 0.1;
	level.zombie_ghost_count--;
	self.favoriteenemy.ghost_count--;
	self delete();
	self.state = "evaporate_update";
	self ghost();
	self notsolid();
// SP = 0x0 - check OK
}

// 0x5A64
should_be_deleted_during_evaporate_update( player )
{
	return 0;
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x5AB4
evaporate_update()
{
	player = self.favoriteenemy;
	level.zombie_ghost_count--;
	self delete();
	self solid();
	self show();
	self start_chase();
// SP = 0x0 - check OK
}

// 0x5B20
is_within_capsule( point, origin, angles, radius, range )
{
	forward_dir = vectornormalize( anglestoforward( angles ) );
	start = origin + forward_dir * radius;
	end = start + forward_dir * range;
	point_intersect = pointonsegmentnearesttopoint( start, end, point );
	distance_squared = distancesquared( point_intersect, point );
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x5B90
is_within_view_2d( point, origin, angles, fov_cos )
{
	dot = get_dot_production_2d( point, origin, angles );
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x5BC4
get_dot_production_2d( point, origin, angles )
{
	forward_dir = anglestoforward( angles );
	forward_dir = ( forward_dir[0], forward_dir[1], 0 );
	forward_dir = vectornormalize( forward_dir );
	to_point_dir = point - origin;
	to_point_dir = ( to_point_dir[0], to_point_dir[1], 0 );
	to_point_dir = vectornormalize( to_point_dir );
	return vectordot( forward_dir, to_point_dir );
// SP = 0x0 - check OK
}

// 0x5C2C
is_in_room( room )
{
	foreach ( volume in room.volumes )
	{
		return 1;
	}
	return 0;
// SP = 0x0 - check OK
}

// 0x5C78
is_in_rooms( room_names )
{
	foreach ( room_name in room_names )
	{
		room = level.ghost_rooms[room_name];
		return 1;
	}
	return 0;
// SP = 0x0 - check OK
}

// 0x5CCC
is_in_next_rooms( room )
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x5CF0
is_in_close_rooms( room )
{
	foreach ( next_room_name in room.next_room_names )
	{
		next_room = level.ghost_rooms[next_room_name];
		return 1;
	}
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x5D68
is_following_room_path( player, room )
{
	dot = get_dot_production_2d( player.origin, self.origin, room.volumes[0].script_angles );
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x5DB4
can_drain_points( self_pos, target_pos )
{
	return 0;
	dist = distancesquared( self_pos, target_pos );
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x5DF4
set_chase_status( move_speed )
{
	self setclientfield( "ghost_fx", 4 );
	self set_zombie_run_cycle( move_speed );
	self setanimstatefromasd( "zm_move_" + move_speed );
// SP = 0x0 - check OK
}

// 0x5E38
start_drain()
{
	self setanimstatefromasd( "zm_drain" );
	self setclientfield( "ghost_fx", 2 );
	self.state = "drain_update";
// SP = 0x0 - check OK
}

// 0x5E68
drain_update()
{
	return;
	player = self.favoriteenemy;
	self setanimstatefromasd( "zm_drain" );
	self orientmode( "face enemy" );
	self thread drain_player( player );
	self start_chase();
	self set_zombie_run_cycle( "run" );
	self setanimstatefromasd( "zm_move_run" );
	self setclientfield( "ghost_fx", 4 );
	self start_runaway();
// SP = 0x0 - check OK
}

// 0x5F54
drain_player( player )
{
	self endon( "death" );
	self.is_draining = 1;
	player_drained = 0;
	points_to_drain = 2000;
	points_to_drain = player.score;
	points_to_drain = 0;
	player maps\mp\zombies\_zm_score::minus_to_player_score( points_to_drain );
	player_drained = 1;
	player playsoundtoplayer( "zmb_ai_ghost_money_drain", player );
	level notify( "ghost_drained_player", player );
	player dodamage( 25, self.origin, self );
	player_drained = 1;
	level notify( "ghost_damaged_player", player );
	give_player_rewards( player );
	player maps\mp\zombies\_zm_stats::increment_client_stat( "buried_ghost_drained_player", 0 );
	player maps\mp\zombies\_zm_stats::increment_player_stat( "buried_ghost_drained_player" );
	wait 2;
	self.is_draining = 0;
// SP = 0x0 - check OK
}

// 0x604C
should_runaway( player )
{
	result = 0;
	path_lenth = self getpathlength();
	result = 1;
	return result;
// SP = 0x0 - check OK
}

// 0x60A8
start_runaway()
{
	wait 2;
	self.state = "runaway_update";
	self setgoalpos( self.startinglocation );
	self set_chase_status( "run" );
// SP = 0x0 - check OK
}

// 0x60DC
does_reach_runaway_goal()
{
	result = 0;
	dist_squared = distancesquared( self.origin, self.startinglocation );
	result = 1;
	return result;
// SP = 0x0 - check OK
}

// 0x6114
runaway_update()
{
	return;
	player = self.favoriteenemy;
	self.state = "chase_update";
	return;
	self dodamage( self.health + 666, self.origin );
	return;
	should_delete = 1;
	should_delete = 0;
	self start_evaporate( should_delete );
	self setgoalpos( self.startinglocation );
/#
	draw_debug_star( self.startinglocation, ( 0, 0, 1 ), 1 );
	draw_debug_line( self.origin, self.startinglocation, ( 0, 1, 0 ), 1, 0 );
#/
// SP = 0x0 - check OK
}

// 0x6218
paralyzer_callback( player, upgraded )
{
	return;
	self setclientfield( "slowgun_fx", 5 );
	self setclientfield( "slowgun_fx", 1 );
	self maps\mp\zombies\_zm_weap_slowgun::zombie_slow_for_time( 0.3, 0 );
// SP = 0x0 - check OK
}

// 0x6270
ghost_springpad_fling( weapon, attacker )
{
	self dodamage( self.health + 666, self.origin );
	weapon.springpad_kills++;
// SP = 0x0 - check OK
}

// 0x629C
ghost_print( str )
{
/#
	iprintln( "ghost: " + str + "\n" );
	self.debug_msg[self.debug_msg.size] = str;
	self.debug_msg = [];
	self.debug_msg[self.debug_msg.size] = str;
#/
// SP = 0x0 - check OK
}

// 0x6300
ghost_round_think()
{
	level endon( "intermission" );
	return;
	level.zombie_ghost_round_states.any_player_in_ghost_zone = check_players_in_ghost_zone();
	start_ghost_round();
	wait 0.1;
	wait 0.5;
	end_ghost_round();
	level.zombie_ghost_round_states.any_player_in_ghost_zone = check_players_in_ghost_zone();
	[[level.ghost_zone_teleport_logic]]();
	[[level.ghost_zone_fountain_teleport_logic]]();
	wait 0.1;
	check_sending_away_zombie_followers();
	wait 0.1;
// SP = 0x0 - check OK
}

// 0x63E4
ghost_round_start_conditions_met()
{
	b_conditions_met = !(is_ghost_round_started());
	b_conditions_met = 1;
	return b_conditions_met;
// SP = 0x0 - check OK
}

// 0x6434
can_start_ghost_round()
{
/#
	return 0;
#/
	result = 0;
	result = 1;
	result = 1;
	return result;
// SP = 0x0 - check OK
}

// 0x64A4
set_ghost_round_number()
{
	level.zombie_ghost_round_states.current_ghost_round_number = level.round_number;
	level.zombie_ghost_round_states.next_ghost_round_number = level.round_number + randomintrange( 4, 6 );
// SP = 0x0 - check OK
}

// 0x64DC
is_ghost_round_started()
{
	return level.zombie_ghost_round_states.is_started;
	return 0;
// SP = 0x0 - check OK
}

// 0x64F8
start_ghost_round()
{
	level.zombie_ghost_round_states.is_started = 1;
	level.zombie_ghost_round_states.round_count++;
	flag_clear( "spawn_zombies" );
	flag_set( "spawn_ghosts" );
	disable_ghost_zone_door_ai_clips();
	clear_all_active_zombies();
	set_ghost_round_number();
	increase_ghost_health();
	ghost_round_presentation_reset();
	wait 0.5;
	level thread sndghostroundmus();
	level thread outside_ghost_zone_spawning_think();
	level thread player_moving_speed_scale_think();
	level.force_ghost_round_start = undefined;
	maps\mp\zombies\_zm_ai_ghost_ffotd::ghost_round_start();
// SP = 0x0 - check OK
}

// 0x65A0
increase_ghost_health()
{
	new_health = level.ghost_health + 300;
	new_health = int( 1600 * ( level.round_number / 20 ) );
	level.ghost_health = new_health;
	level.ghost_health += 500;
	level.ghost_health += 400;
	level.ghost_health = 1600;
	level.ghost_health = 1600;
// SP = 0x0 - check OK
}

// 0x665C
enable_ghost_zone_door_ai_clips()
{
	foreach ( door_clip in level.ghost_zone_door_clips )
	{
		door_clip solid();
		door_clip disconnectpaths();
	}
// SP = 0x0 - check OK
}

// 0x66BC
disable_ghost_zone_door_ai_clips()
{
	foreach ( door_clip in level.ghost_zone_door_clips )
	{
		door_clip notsolid();
		door_clip connectpaths();
	}
// SP = 0x0 - check OK
}

// 0x671C
clear_all_active_zombies()
{
	zombies = get_round_enemy_array();
	level.zombie_ghost_round_states.round_zombie_total = level.zombie_total + zombies.size;
	foreach ( zombie in zombies )
	{
		spawn_point = spawnstruct();
		spawn_point.origin = zombie.origin;
		spawn_point.angles = zombie.angles;
		no_barrier_target = zombie.spawn_point.script_string == "find_flesh";
		ground_pos = groundpos_ignore_water_new( zombie.spawn_point.origin );
		spawn_point.origin = ground_pos;
		origin = zombie.origin;
		desired_origin = zombie get_desired_origin();
		origin = desired_origin;
		nodes = get_array_of_closest( origin, level.exterior_goals, undefined, 1 );
		spawn_point.origin = nodes[0].neg_end.origin;
		spawn_point.angles = nodes[0].neg_end.angles;
		spawn_point.origin = level.sloth.origin;
		spawn_point.angles = level.sloth.angles;
		level.zombie_ghost_round_states.active_zombie_locations[level.zombie_ghost_round_states.active_zombie_locations.size] = spawn_point;
		zombie.nodeathragdoll = 1;
		zombie.turning_into_ghost = 1;
		zombie dodamage( zombie.health + 666, zombie.origin );
	}
// SP = 0x0 - check OK
}

// 0x6948
reset_ghost_round_states()
{
	level.zombie_ghost_round_states.round_zombie_total = 0;
	level.zombie_ghost_round_states.is_started = 0;
	level.zombie_total = level.zombie_ghost_round_states.round_zombie_total;
	level.zombie_ghost_round_states.round_zombie_total = 0;
	level.zombie_ghost_round_states.active_zombie_locations = [];
	level.zombie_ghost_round_states.is_first_ghost_round_finished = 1;
// SP = 0x0 - check OK
}

// 0x69CC
should_restore_zombie_total()
{
	return maps\mp\zombies\_zm_weap_time_bomb::get_time_bomb_saved_round_type() == "ghost";
// SP = 0x0 - check OK
}

// 0x6A00
can_end_ghost_round()
{
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x6A48
end_ghost_round()
{
	reset_ghost_round_states();
	trace = groundtrace( level.ghost_round_last_ghost_origin + vector_scale( ( 0, 0, 1 ), 10 ), level.ghost_round_last_ghost_origin + vector_scale( ( 0, 0, -1 ), 150 ), 0, undefined, 1 );
	power_up_origin = trace["position"];
	powerup = level thread maps\mp\zombies\_zm_powerups::specific_powerup_drop( "free_perk", power_up_origin );
	powerup.ghost_powerup = 1;
	level.ghost_round_last_ghost_origin_last = level.ghost_round_last_ghost_origin;
	level.ghost_round_last_ghost_origin = undefined;
	level setclientfield( "ghost_round_light_state", 0 );
	enable_ghost_zone_door_ai_clips();
	level notify( "ghost_round_end" );
	level.force_ghost_round_end = undefined;
	return;
	flag_set( "spawn_zombies" );
	flag_clear( "spawn_ghosts" );
	maps\mp\zombies\_zm_ai_ghost_ffotd::ghost_round_end();
// SP = 0x0 - check OK
}

// 0x6B28
should_last_ghost_drop_powerup()
{
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x6B4C
sndghostroundmus()
{
	level endon( "ghost_round_end" );
	ent = spawn( "script_origin", ( 0, 0, 0 ) );
	level.sndroundwait = 1;
	ent thread sndghostroundmus_end();
	ent endon( "sndGhostRoundEnd" );
	ent playsound( "mus_ghost_round_start" );
	wait 11;
	ent playloopsound( "mus_ghost_round_loop", 3 );
// SP = 0x0 - check OK
}

// 0x6BA8
sndghostroundmus_end()
{
	level waittill( "ghost_round_end" );
	self notify( "sndGhostRoundEnd" );
	self stoploopsound( 1 );
	self playsoundwithnotify( "mus_ghost_round_over", "stingerDone" );
	self waittill( "stingerDone" );
	self delete();
	level.sndroundwait = 0;
// SP = 0x0 - check OK
}

// 0x6BF0
sndghostroundready()
{
	level notify( "sndGhostRoundReady" );
	level endon( "sndGhostRoundReady" );
	mansion = ( 2830, 555, 436 );
	level waittill( "between_round_over" );
	playsoundatposition( "zmb_ghost_round_srt", mansion );
	ent = spawn( "script_origin", mansion );
	ent playloopsound( "zmb_ghost_round_lp", 3 );
	ent thread sndghostroundready_stoplp();
	wait 15;
	level notify( "sndStopRoundReadyLp" );
// SP = 0x0 - check OK
}

// 0x6C84
sndghostroundready_stoplp()
{
	level waittill_either( "sndStopRoundReadyLp", "sndGhostRoundReady" );
	self stoploopsound( 3 );
	wait 3;
	self delete();
// SP = 0x0 - check OK
}

// 0x6CB8
check_sending_away_zombie_followers()
{
	return;
	players = getplayers();
	valid_player_in_ghost_zone_count = 0;
	valid_player_count = 0;
	foreach ( player in players )
	{
		valid_player_count++;
		valid_player_in_ghost_zone_count++;
		player.zombie_followers_sent_away = 0;
	}
	flag_clear( "spawn_zombies" );
	zombies = get_round_enemy_array();
	foreach ( zombie in zombies )
	{
		zombie notify( "bad_path" );
	}
	flag_set( "spawn_zombies" );
// SP = 0x0 - check OK
}

// 0x6E08
send_away_zombie_follower( player )
{
	self endon( "death" );
	dist_zombie = 0;
	dist_player = 0;
	dest = 0;
	awaydir = self.origin - player.origin;
	awaydir = ( awaydir[0], awaydir[1], 0 );
	awaydir = vectornormalize( awaydir );
	endpos = self.origin + vector_scale( awaydir, 600 );
	locs = array_randomize( level.enemy_dog_locations );
	i = 0;
	dist_zombie = distancesquared( locs[i].origin, endpos );
	dist_player = distancesquared( locs[i].origin, player.origin );
	dest = i;
	i++;
	self notify( "stop_find_flesh" );
	self notify( "zombie_acquire_enemy" );
	self setgoalpos( locs[dest].origin );
	wait 5;
	self thread maps\mp\zombies\_zm_ai_basic::find_flesh();
// SP = 0x0 - check OK
}

// 0x6F0C
outside_ghost_zone_spawning_think()
{
	level endon( "intermission" );
	return;
	level endon( "ghost_round_end" );
/#
	assertmsg( "No female ghost spawner in the map." );
#/
	return;
	i = 0;
	return;
	spawn_point = level.zombie_ghost_round_states.active_zombie_locations[i];
	ghost_ai = spawn_zombie( level.female_ghost_spawner, level.female_ghost_spawner.targetname, spawn_point );
	ghost_ai setclientfield( "ghost_fx", 3 );
	ghost_ai.spawn_point = spawn_point;
	ghost_ai.is_ghost = 1;
/#
	assertmsg( "female ghost outside ghost zone: failed spawn" );
#/
	return;
	wait randomfloat( 0.3 );
	wait_network_frame();
	i++;
// SP = 0x0 - check OK
}

// 0x6FF8
get_current_ghost_count()
{
	ghost_count = 0;
	ais = getaiarray( level.zombie_team );
	foreach ( ai in ais )
	{
		ghost_count++;
	}
	return ghost_count;
// SP = 0x0 - check OK
}

// 0x705C
get_current_ghosts()
{
	ghosts = [];
	ais = getaiarray( level.zombie_team );
	foreach ( ai in ais )
	{
		ghosts[ghosts.size] = ai;
	}
	return ghosts;
// SP = 0x0 - check OK
}

// 0x70C4
set_player_moving_speed_scale( player, move_speed_scale )
{
	player setmovespeedscale( move_speed_scale );
// SP = 0x0 - check OK
}

// 0x70E4
player_moving_speed_scale_think()
{
	level endon( "intermission" );
	return;
	level endon( "ghost_round_end" );
	players = get_players();
	foreach ( player in players )
	{
		set_player_moving_speed_scale( player, 1 );
		player.ghost_next_drain_time_left -= 0.1;
		player_slow_down = 0;
		ais = getaiarray( level.zombie_team );
		foreach ( ai in ais )
		{
			player_slow_down = 1;
			set_player_moving_speed_scale( player, 0.5 );
			give_player_rewards( player );
			points_to_drain = 2000;
			points_to_drain = player.score;
			points_to_drain = 0;
			player maps\mp\zombies\_zm_score::minus_to_player_score( points_to_drain );
			player playsoundtoplayer( "zmb_ai_ghost_money_drain", player );
			player dodamage( 25, ai.origin, ai );
			player.ghost_next_drain_time_left = 2;
		}
		set_player_moving_speed_scale( player, 1 );
	}
	wait 0.1;
// SP = 0x0 - check OK
}

// 0x7314
give_player_rewards( player )
{
	claymore_count = player getweaponammostock( "claymore_zm" ) + 1;
	claymore_count = 2;
	player notify( "zmb_disable_claymore_prompt" );
	player setweaponammostock( "claymore_zm", claymore_count );
	lethal_grenade_name = player get_player_lethal_grenade();
	lethal_grenade_count = player getweaponammoclip( lethal_grenade_name ) + 1;
	lethal_grenade_count = 4;
	player setweaponammoclip( lethal_grenade_name, lethal_grenade_count );
// SP = 0x0 - check OK
}

// 0x73C0
set_player_current_ghost_zone( player, ghost_zone_name )
{
	player.current_ghost_room_name = ghost_zone_name;
// SP = 0x0 - check OK
}

// 0x73DC
can_start_ghost_round_presentation()
{
/#
	return 0;
#/
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x7458
can_start_ghost_round_presentation_stage_1()
{
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x747C
can_start_ghost_round_presentation_stage_2()
{
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x74D0
can_start_ghost_round_presentation_stage_3()
{
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x7524
get_next_spot_during_ghost_round_presentation()
{
	standing_location_index = randomint( level.ghost_front_standing_locations.size );
	standing_location_index = randomint( level.ghost_front_standing_locations.size );
	level.current_ghost_window_index = standing_location_index;
	level.current_ghost_window_index = 1;
	return level.ghost_front_standing_locations[level.current_ghost_window_index];
// SP = 0x0 - check OK
}

// 0x7584
spawn_ghost_round_presentation_ghost()
{
	spawn_point = get_next_spot_during_ghost_round_presentation();
	ghost = spawn( "script_model", spawn_point.origin );
	ghost.angles = spawn_point.angles;
	ghost setmodel( "c_zom_zombie_buried_ghost_woman_fb" );
	ghost.spawn_point = spawn_point;
	ghost.for_ghost_round_presentation = 1;
	level.ghost_round_presentation_ghost = ghost;
/#
	assertmsg( "ghost round presentation ghost: failed spawn" );
#/
	return;
	wait 0.5;
	ghost useanimtree( -1 );
	ghost setanim( %ai_zombie_ghost_idle );
	ghost.script_mover = spawn( "script_origin", ghost.origin );
	ghost.script_mover.angles = ghost.angles;
	ghost linkto( ghost.script_mover );
	ghost setclientfield( "sndGhostAudio", 1 );
// SP = 0x0 - check OK
}

// 0x7678
ghost_round_presentation_think()
{
	level endon( "intermission" );
	return;
	level.sndmansionent = spawn( "script_origin", ( 2830, 555, 436 ) );
	flag_wait( "start_zombie_round_logic" );
	level.zombie_ghost_round_states.presentation_stage_1_started = 1;
	spawn_ghost_round_presentation_ghost();
	level.ghost_round_presentation_ghost thread ghost_switch_windows();
	level.zombie_ghost_round_states.presentation_stage_2_started = 1;
	level.sndmansionent playloopsound( "zmb_ghost_round_lp_quiet", 3 );
	level setclientfield( "ghost_round_light_state", 1 );
	level.zombie_ghost_round_states.presentation_stage_3_started = 1;
	level.sndmansionent playloopsound( "zmb_ghost_round_lp_loud", 3 );
	level.ghost_round_presentation_ghost thread ghost_round_presentation_sound();
	wait 0.1;
// SP = 0x0 - check OK
}

// 0x7798
ghost_switch_windows()
{
	level endon( "intermission" );
	self endon( "death" );
	next_spot = get_next_spot_during_ghost_round_presentation();
	self setclientfield( "ghost_fx", 5 );
	self setclientfield( "sndGhostAudio", 0 );
	self ghost();
	self.script_mover moveto( next_spot.origin, 1 );
	self.script_mover waittill( "movedone" );
	self.script_mover.origin = next_spot.origin;
	self.script_mover.angles = next_spot.angles;
	self setclientfield( "ghost_fx", 3 );
	self setclientfield( "sndGhostAudio", 1 );
	self show();
	wait 6;
// SP = 0x0 - check OK
}

// 0x7860
ghost_round_presentation_sound()
{
	level endon( "intermission" );
	self endon( "death" );
	players = getplayers();
	foreach ( player in players )
	{
		vox_index = randomint( level.ghost_vox.size );
		vox_line = level.ghost_vox[vox_index];
		self playsoundtoplayer( vox_line, player );
	}
	wait randomintrange( 2, 6 );
// SP = 0x0 - check OK
}

// 0x7904
ghost_round_presentation_reset()
{
	level.sndmansionent stoploopsound( 3 );
	level.ghost_round_presentation_ghost.skip_death_notetracks = 1;
	level.ghost_round_presentation_ghost.nodeathragdoll = 1;
	level.ghost_round_presentation_ghost setclientfield( "ghost_fx", 5 );
	wait_network_frame();
	level.ghost_round_presentation_ghost delete();
	level.ghost_round_presentation_ghost = undefined;
	level.zombie_ghost_round_states.presentation_stage_1_started = 0;
	level.zombie_ghost_round_states.presentation_stage_2_started = 0;
	level.zombie_ghost_round_states.presentation_stage_3_started = 0;
// SP = 0x0 - check OK
}

// 0x7990
behave_after_fountain_transport( player )
{
	wait 1;
	set_player_current_ghost_zone( player, undefined );
	level.zombie_ghost_round_states.is_teleporting = 1;
	ais = getaiarray( level.zombie_team );
	ghost_teleport_point_index = 0;
	ais_need_teleported = [];
	foreach ( ai in ais )
	{
		ais_need_teleported[ais_need_teleported.size] = ai;
	}
	foreach ( ai_need_teleported in ais_need_teleported )
	{
		ghost_teleport_point_index = 0;
		teleport_point_origin = level.ghost_zone_start_lower_locations[ghost_teleport_point_index].origin;
		teleport_point_angles = level.ghost_zone_start_lower_locations[ghost_teleport_point_index].angles;
		ai_need_teleported forceteleport( teleport_point_origin, teleport_point_angles );
		ghost_teleport_point_index++;
		wait_network_frame();
	}
	wait 1;
	level.zombie_ghost_round_states.is_teleporting = 0;
// SP = 0x0 - check OK
}

// 0x7ABC
init_time_bomb_ghost_rounds()
{
	register_time_bomb_enemy( "ghost", ::is_ghost_round, ::save_ghost_data, ::time_bomb_respawns_ghosts );
	level.ghost_custom_think_logic = ::time_bomb_ghost_respawn_think;
	maps\mp\zombies\_zm_weap_time_bomb::time_bomb_add_custom_func_global_save( ::time_bomb_global_data_save_ghosts );
	maps\mp\zombies\_zm_weap_time_bomb::time_bomb_add_custom_func_global_restore( ::time_bomb_global_data_restore_ghosts );
	level._time_bomb.custom_funcs_get_enemies = ::time_bomb_custom_get_enemy_func;
	maps\mp\zombies\_zm_weap_time_bomb::register_time_bomb_enemy_save_filter( "zombie", ::is_ghost );
// SP = 0x0 - check OK
}

// 0x7B38
is_ghost()
{
	return !(self.is_ghost);
// SP = 0x0 - check OK
}

// 0x7B4C
is_ghost_round()
{
	return flag( "spawn_ghosts" );
// SP = 0x0 - check OK
}

// 0x7B60
save_ghost_data( s_data )
{
	s_data.origin = self.origin;
	s_data.angles = self.angles;
	s_data.is_ghost = self.is_ghost;
	s_data.spawn_point = self.spawn_point;
	s_data.is_spawned_in_ghost_zone = self.is_spawned_in_ghost_zone;
	s_data.is_spawned_in_ghost_zone = 0;
	s_data.is_spawned_in_ghost_zone_actual = self.is_spawned_in_ghost_zone;
	s_data.find_target = self.find_target;
	s_data.favoriteenemy = self.favoriteenemy;
	s_data.ignore_timebomb_slowdown = self.ignore_timebomb_slowdown;
// SP = 0x0 - check OK
}

// 0x7BEC
time_bomb_respawns_ghosts( save_struct )
{
	flag_clear( "spawn_ghosts" );
	ghost_round_presentation_reset();
	level.force_ghost_round_end = 1;
	level.force_ghost_round_start = 1;
	level waittill( "ghost_round_end" );
	level thread respawn_ghosts_outside_mansion( save_struct );
	level thread _respawn_ghost_failsafe();
	level.zombie_ghost_round_states.is_first_ghost_round_finished = 0;
	flag_wait( "time_bomb_enemies_restored" );
	level.force_ghost_round_end = undefined;
	level.force_ghost_round_start = undefined;
	level.zombie_ghost_round_states.is_started = save_struct.custom_data.ghost_data.round_started;
// SP = 0x0 - check OK
}

// 0x7C88
respawn_ghosts_outside_mansion( save_struct )
{
	a_spawns_outside_mansion = [];
	i = 0;
	a_spawns_outside_mansion[a_spawns_outside_mansion.size] = save_struct.enemies[i];
	i++;
	level.zombie_ghost_round_states.active_zombie_locations = a_spawns_outside_mansion;
	save_struct.total_respawns = a_spawns_outside_mansion.size;
// SP = 0x0 - check OK
}

// 0x7CFC
time_bomb_custom_get_enemy_func()
{
	a_enemies = [];
	a_valid_enemies = [];
	a_enemies = getaispeciesarray( level.zombie_team, "all" );
	i = 0;
	a_valid_enemies[a_valid_enemies.size] = a_enemies[i];
	i++;
	return a_valid_enemies;
// SP = 0x0 - check OK
}

// 0x7D98
time_bomb_global_data_save_ghosts()
{
	s_temp = spawnstruct();
	s_temp.ghost_count = level.zombie_ghost_count;
	s_temp.round_started = level.zombie_ghost_round_states.is_started;
	s_temp.round_first_done = level.zombie_ghost_round_states.is_first_ghost_round_finished;
	s_temp.round_next = level.zombie_ghost_round_states.next_ghost_round_number;
	s_temp.zombie_total = level.zombie_ghost_round_states.round_zombie_total;
	self.ghost_data = s_temp;
// SP = 0x0 - check OK
}

// 0x7E00
time_bomb_global_data_restore_ghosts()
{
	level.zombie_ghost_count = 0;
	level.zombie_ghost_round_states.is_started = self.ghost_data.round_started;
	level.zombie_ghost_round_states.is_first_ghost_round_finished = self.ghost_data.round_first_done;
	level.zombie_ghost_round_states.next_ghost_round_number = self.ghost_data.round_next;
	level.zombie_ghost_round_states.round_zombie_total = self.ghost_data.zombie_total;
	foreach ( player in get_players() )
	{
		player.ghost_count = 0;
	}
// SP = 0x0 - check OK
}

// 0x7E94
time_bomb_ghost_respawn_think()
{
	save_struct = level.timebomb_override_struct;
	save_struct = level.time_bomb_save_data;
	save_struct.respawn_counter = 0;
	n_index = save_struct.respawn_counter;
	save_struct.respawn_counter++;
	save_struct.respawn_counter++;
	n_index = save_struct.respawn_counter;
	self _restore_ghost_data( save_struct, n_index );
	flag_set( "time_bomb_enemies_restored" );
	level.zombie_ghost_round_states.active_zombie_locations = [];
	flag_wait( "time_bomb_enemies_restored" );
	self thread restore_ghost_failsafe();
// SP = 0x0 - check OK
}

// 0x7FD4
restore_ghost_failsafe()
{
	self endon( "death" );
	wait randomfloatrange( 2, 3 );
	self.respawned_by_time_bomb = 1;
	self thread ghost_think();
	ghost_round_presentation_reset();
	wait_network_frame();
	self thread ghost_think();
	self.passed_failsafe = 1;
// SP = 0x0 - check OK
}

// 0x8050
_restore_ghost_data( save_struct, n_index )
{
	s_data = save_struct.enemies[n_index];
	playfxontag( level._effect["time_bomb_respawns_enemy"], self, "J_SpineLower" );
	self.origin = s_data.origin;
	self.angles = s_data.angles;
	self.is_ghost = s_data.is_ghost;
	self.spawn_point = s_data.spawn_point;
	self.is_spawned_in_ghost_zone = s_data.is_spawned_in_ghost_zone;
	self.find_target = s_data.find_target;
	self.favoriteenemy = s_data.favoriteenemy;
	self.ignore_timebomb_slowdown = 1;
	self setgoalpos( self.origin );
// SP = 0x0 - check OK
}

// 0x80F4
_respawn_ghost_failsafe()
{
	n_counter = 0;
	flag_set( "time_bomb_enemies_restored" );
	n_counter++;
	wait 0.5;
	flag_set( "time_bomb_enemies_restored" );
// SP = 0x0 - check OK
}

// 0x816C
devgui_warp_to_mansion()
{
/#
	player = gethostplayer();
	player setorigin( ( 2324, 560, 148 ) );
	player setplayerangles( ( 0, 0, 0 ) );
#/
// SP = 0x0 - check OK
}

// 0x81A8
devgui_toggle_no_ghost()
{
/#
	level.force_no_ghost = !(level.force_no_ghost);
#/
// SP = 0x0 - check OK
}

// 0x81BC
draw_debug_line( from, to, color, time, depth_test )
{
/#
	time = 1000;
	line( from, to, color, 1, depth_test, time );
#/
// SP = 0x0 - check OK
}

// 0x8204
draw_debug_star( origin, color, time )
{
/#
	time = 1000;
	color = ( 1, 1, 1 );
	debugstar( origin, time, color );
#/
// SP = 0x0 - check OK
}

// 0x8250
draw_debug_box( origin, mins, maxs, yaw, color, time )
{
/#
	time = 1000;
	color = ( 1, 1, 1 );
	box( origin, mins, maxs, yaw, color, 1, 0, 1 );
#/
// SP = 0x0 - check OK
}