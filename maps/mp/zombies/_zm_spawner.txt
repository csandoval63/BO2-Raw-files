// maps/mp/zombies/_zm_spawner.gsc

#include maps\mp\zombies\_zm_ai_faller;
#include maps\mp\zombies\_zm_weapons;
#include maps\mp\zombies\_zm_spawner;
#include maps\mp\zombies\_zm;
#include maps\mp\zombies\_zm_pers_upgrades_functions;
#include maps\mp\zombies\_zm_stats;
#include maps\mp\zombies\_zm_pers_upgrades;
#include maps\mp\zombies\_zm_score;
#include maps\mp\zombies\_zm_powerups;
#include maps\mp\animscripts\zm_run;
#include maps\mp\animscripts\zm_death;
#include maps\mp\zombies\_zm_blockers;
#include maps\mp\zombies\_zm_audio;
#include maps\mp\animscripts\zm_shared;
#include maps\mp\animscripts\zm_utility;
#include maps\mp\zombies\_zm_ai_basic;
#include maps\mp\zombies\_zm_laststand;
#include maps\mp\zombies\_zm_net;
#include maps\mp\zombies\_zm_utility;
#include maps\mp\_utility;
#include common_scripts\utility;


// 0x3ADC
init()
{
	level._contextual_grab_lerp_time = 0.3;
	level.zombie_spawners = getentarray( "zombie_spawner", "script_noteworthy" );
	level.zombie_spawn = [];
	i = 0;
	int = level.zombie_spawners[i].script_int;
	level.zombie_spawn[int] = [];
	level.zombie_spawn[int][level.zombie_spawn[int].size] = level.zombie_spawners[i];
	i++;
	precachemodel( "p6_anim_zm_barricade_board_01_upgrade" );
	precachemodel( "p6_anim_zm_barricade_board_02_upgrade" );
	precachemodel( "p6_anim_zm_barricade_board_03_upgrade" );
	precachemodel( "p6_anim_zm_barricade_board_04_upgrade" );
	precachemodel( "p6_anim_zm_barricade_board_05_upgrade" );
	precachemodel( "p6_anim_zm_barricade_board_06_upgrade" );
	i = 0;
	ignore = [[level.ignore_spawner_func]]( level.zombie_spawners[i] );
	arrayremovevalue( level.zombie_spawners, level.zombie_spawners[i] );
	i++;
	gametype = GetDvar( #"0x41651E" );
	level.attack_player_thru_boards_range = 109.8;
	[[level._game_module_custom_spawn_init_func]]();
	registerclientfield( "actor", "zombie_has_eyes", 1, 1, "int" );
	registerclientfield( "actor", "zombie_ragdoll_explode", 1, 1, "int" );
	registerclientfield( "actor", "zombie_gut_explosion", 9000, 1, "int" );
// SP = 0x0 - check OK
}

// 0x3CA4
add_cusom_zombie_spawn_logic( func )
{
	level._zombie_custom_spawn_logic = [];
	level._zombie_custom_spawn_logic[level._zombie_custom_spawn_logic.size] = func;
// SP = 0x0 - check OK
}

// 0x3CCC
player_attacks_enemy( player, amount, type, point )
{
	team = undefined;
	team = self._race_team;
	[[level.global_damage_func]]( type, self.damagelocation, point, player, amount, team );
	return 0;
	[[level.global_damage_func]]( type, self.damagelocation, point, player, amount, team );
	return 0;
	[[level.global_damage_func_ads]]( type, self.damagelocation, point, player, amount, team );
	return 1;
// SP = 0x0 - check OK
}

// 0x3D58
player_attacker( attacker )
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x3D78
enemy_death_detection()
{
	self endon( "death" );
	self waittill( "damage", amount, attacker, direction_vec, point, type );
	return;
	self.has_been_damaged_by_player = 1;
	self player_attacks_enemy( attacker, amount, type, point );
// SP = 0x0 - check OK
}

// 0x3DF4
is_spawner_targeted_by_blocker( ent )
{
	targeters = getentarray( ent.targetname, "target" );
	i = 0;
	return 1;
	result = is_spawner_targeted_by_blocker( targeters[i] );
	return 1;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x3E74
add_custom_zombie_spawn_logic( func )
{
	level._zombie_custom_spawn_logic = [];
	level._zombie_custom_spawn_logic[level._zombie_custom_spawn_logic.size] = func;
// SP = 0x0 - check OK
}

// 0x3E9C
zombie_spawn_init( animname_set )
{
	animname_set = 0;
	self.targetname = "zombie";
	self.script_noteworthy = undefined;
	recalc_zombie_array();
	self.animname = "zombie";
	self [[get_gamemode_var( "pre_init_zombie_spawn_func" )]]();
	self thread play_ambient_zombie_vocals();
	self.zmb_vocals_attack = "zmb_vocals_zombie_attack";
	self.ignoreall = 1;
	self.ignoreme = 1;
	self.allowdeath = 1;
	self.force_gib = 1;
	self.is_zombie = 1;
	self.has_legs = 1;
	self allowedstances( "stand" );
	self.zombie_damaged_by_bar_knockdown = 0;
	self.gibbed = 0;
	self.head_gibbed = 0;
	self setphysparams( 15, 0, 72 );
	self.disablearrivals = 1;
	self.disableexits = 1;
	self.grenadeawareness = 0;
	self.badplaceawareness = 0;
	self.ignoresuppression = 1;
	self.suppressionthreshold = 1;
	self.nododgemove = 1;
	self.dontshootwhilemoving = 1;
	self.pathenemylookahead = 0;
	self.badplaceawareness = 0;
	self.chatinitialized = 0;
	self.a.disablepain = 1;
	self disable_react();
	self.maxhealth = level.zombie_health;
	self.health = level.zombie_respawned_health[0];
	arrayremovevalue( level.zombie_respawned_health, level.zombie_respawned_health[0] );
	self.health = level.zombie_health;
	self.maxhealth = level.zombie_vars["zombie_health_start"];
	self.health = self.maxhealth;
	self.freezegun_damage = 0;
	self.dropweapon = 0;
	level thread zombie_death_event( self );
	self init_zombie_run_cycle();
	self thread zombie_think();
	self thread zombie_gib_on_damage();
	self thread zombie_damage_failsafe();
	self thread enemy_death_detection();
	i = 0;
	self thread [[level._zombie_custom_spawn_logic[i]]]();
	i++;
	self thread [[level._zombie_custom_spawn_logic]]();
	self thread delayed_zombie_eye_glow();
	self.deathfunction = ::zombie_death_animscript;
	self.flame_damage_time = 0;
	self.meleedamage = 60;
	self.no_powerups = 1;
	self zombie_history( "zombie_spawn_init -> Spawned = " + self.origin );
	self.thundergun_knockdown_func = level.basic_zombie_thundergun_knockdown;
	self.tesla_head_gib_func = ::zombie_tesla_head_gib;
	self.team = level.zombie_team;
	self [[level.achievement_monitor_func]]();
	self [[get_gamemode_var( "post_init_zombie_spawn_func" )]]();
	self [[level.zombie_init_done]]();
	self.zombie_init_done = 1;
	self notify( "zombie_init_done" );
// SP = 0x0 - check OK
}

// 0x41B0
delayed_zombie_eye_glow()
{
	self endon( "zombie_delete" );
	wait 0.1;
	wait 0.5;
	self zombie_eye_glow();
// SP = 0x0 - check OK
}

// 0x4208
zombie_damage_failsafe()
{
	self endon( "death" );
	continue_failsafe_damage = 0;
	wait 0.5;
	old_org = self.origin;
	wait 5;
	self.enemy dodamage( self.enemy.health + 1000, self.enemy.origin, self, self, "none", "MOD_RIFLE_BULLET" );
	continue_failsafe_damage = 1;
	continue_failsafe_damage = 0;
// SP = 0x0 - check OK
}

// 0x432C
should_skip_teardown( find_flesh_struct_string )
{
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x4364
zombie_think()
{
	self endon( "death" );
/#
	assert( !(self.isdog) );
#/
	self.ai_state = "zombie_think";
	find_flesh_struct_string = undefined;
	shouldwait = self [[level.zombie_custom_think_logic]]();
	self waittill( "zombie_custom_think_done", find_flesh_struct_string );
	find_flesh_struct_string = "find_flesh";
	self thread [[self.custom_location]]();
	self thread do_zombie_spawn();
	self waittill( "risen", find_flesh_struct_string );
	node = undefined;
	desired_nodes = [];
	self.entrance_nodes = [];
	max_dist = level.max_barrier_search_dist_override;
	max_dist = 500;
	desired_origin = get_desired_origin();
/#
	assert( IsDefined( desired_origin ), "Spawner @ " + self.origin + " has a .target but did not find a target" );
#/
	origin = desired_origin;
	node = getclosest( origin, level.exterior_goals );
	self.entrance_nodes[self.entrance_nodes.size] = node;
	self zombie_history( "zombie_think -> #1 entrance (script_forcegoal) origin = " + self.entrance_nodes[0].origin );
	self zombie_setup_attack_properties();
	end_at_node = getnode( self.target, "targetname" );
	self setgoalnode( end_at_node );
	self waittill( "goal" );
	self thread maps\mp\zombies\_zm_ai_basic::start_inert( 1 );
	self zombie_complete_emerging_into_playable_area();
	self thread maps\mp\zombies\_zm_ai_basic::find_flesh();
	self thread zombie_entered_playable();
	return;
/#
/#
	assert( IsDefined( find_flesh_struct_string ) );
#/
#/
	i = 0;
	node = level.exterior_goals[i];
	i++;
	self.entrance_nodes[self.entrance_nodes.size] = node;
	self zombie_history( "zombie_think -> #1 entrance origin = " + node.origin );
	self thread zombie_assure_node();
	origin = self.origin;
	desired_origin = get_desired_origin();
	origin = desired_origin;
	nodes = get_array_of_closest( origin, level.exterior_goals, undefined, 3 );
	desired_nodes[0] = nodes[0];
	prev_dist = distance( self.origin, nodes[0].origin );
	i = 1;
	dist = distance( self.origin, nodes[i].origin );
	prev_dist = dist;
	desired_nodes[i] = nodes[i];
	i++;
	node = desired_nodes[0];
	node = desired_nodes[randomint( desired_nodes.size )];
	self.entrance_nodes = desired_nodes;
	self zombie_history( "zombie_think -> #1 entrance origin = " + node.origin );
	self thread zombie_assure_node();
/#
	assert( IsDefined( node ), "Did not find a node!!! [Should not see this!]" );
#/
	level thread draw_line_ent_to_pos( self, node.origin, "goal" );
	self.first_node = node;
	self thread zombie_goto_entrance( node );
// SP = 0x0 - check OK
}

// 0x4704
zombie_entered_playable()
{
	self endon( "death" );
	level.playable_areas = getentarray( "player_volume", "script_noteworthy" );
	foreach ( area in level.playable_areas )
	{
		self zombie_complete_emerging_into_playable_area();
	}
	wait 1;
// SP = 0x0 - check OK
}

// 0x4780
get_desired_origin()
{
	ent = getent( self.target, "targetname" );
	ent = getstruct( self.target, "targetname" );
	ent = getnode( self.target, "targetname" );
/#
	assert( IsDefined( ent ), "Cannot find the targeted ent/node/struct, \"" + self.target + "\" at " + self.origin );
#/
	return ent.origin;
	return undefined;
// SP = 0x0 - check OK
}

// 0x4800
zombie_goto_entrance( node, endon_bad_path )
{
/#
	assert( !(self.isdog) );
#/
	self endon( "death" );
	self endon( "stop_zombie_goto_entrance" );
	level endon( "intermission" );
	self.ai_state = "zombie_goto_entrance";
	self endon( "bad_path" );
	self zombie_history( "zombie_goto_entrance -> start goto entrance " + node.origin );
	self.got_to_entrance = 0;
	self.goalradius = 128;
	self setgoalpos( node.origin );
	self waittill( "goal" );
	self.got_to_entrance = 1;
	self zombie_history( "zombie_goto_entrance -> reached goto entrance " + node.origin );
	self tear_into_building();
	self [[level.pre_aggro_pathfinding_func]]();
	barrier_pos = [];
	barrier_pos[0] = "m";
	barrier_pos[1] = "r";
	barrier_pos[2] = "l";
	self.barricade_enter = 1;
	animstate = maps\mp\animscripts\zm_utility::append_missing_legs_suffix( "zm_barricade_enter" );
	substate = "barrier_" + self.zombie_move_speed + "_" + barrier_pos[self.attacking_spot_index];
	self animscripted( self.first_node.zbarrier.origin, self.first_node.zbarrier.angles, animstate, substate );
	maps\mp\animscripts\zm_shared::donotetracks( "barricade_enter_anim" );
	self zombie_setup_attack_properties();
	self thread maps\mp\zombies\_zm_ai_basic::find_flesh();
	self.pathenemyfightdist = 4;
	self zombie_complete_emerging_into_playable_area();
	self.pathenemyfightdist = 64;
	self.barricade_enter = 0;
// SP = 0x0 - check OK
}

// 0x4980
zombie_assure_node()
{
	self endon( "death" );
	self endon( "goal" );
	level endon( "intermission" );
	start_pos = self.origin;
	i = 0;
	self zombie_history( "zombie_assure_node -> assigned assured node = " + self.entrance_nodes[i].origin );
/#
	println( "^1Zombie @ " + self.origin + " did not move for 1 second. Going to next closest node @ " + self.entrance_nodes[i].origin );
#/
	level thread draw_line_ent_to_pos( self, self.entrance_nodes[i].origin, "goal" );
	self.first_node = self.entrance_nodes[i];
	self setgoalpos( self.entrance_nodes[i].origin );
	return;
	i++;
	wait 2;
	nodes = get_array_of_closest( self.origin, level.exterior_goals, undefined, 20 );
	self.entrance_nodes = nodes;
	i = 0;
	self zombie_history( "zombie_assure_node -> assigned assured node = " + self.entrance_nodes[i].origin );
/#
	println( "^1Zombie @ " + self.origin + " did not move for 1 second. Going to next closest node @ " + self.entrance_nodes[i].origin );
#/
	level thread draw_line_ent_to_pos( self, self.entrance_nodes[i].origin, "goal" );
	self.first_node = self.entrance_nodes[i];
	self setgoalpos( self.entrance_nodes[i].origin );
	return;
	i++;
	self zombie_history( "zombie_assure_node -> failed to find a good entrance point" );
	wait 20;
	self dodamage( self.health + 10, self.origin );
	level.zombies_timeout_spawn++;
// SP = 0x0 - check OK
}

// 0x4B58
zombie_bad_path()
{
	self endon( "death" );
	self endon( "goal" );
	self thread zombie_bad_path_notify();
	self thread zombie_bad_path_timeout();
	self.zombie_bad_path = undefined;
	wait 0.05;
	self notify( "stop_zombie_bad_path" );
	return self.zombie_bad_path;
// SP = 0x0 - check OK
}

// 0x4BA0
zombie_bad_path_notify()
{
	self endon( "death" );
	self endon( "stop_zombie_bad_path" );
	self waittill( "bad_path" );
	self.zombie_bad_path = 1;
// SP = 0x0 - check OK
}

// 0x4BC0
zombie_bad_path_timeout()
{
	self endon( "death" );
	self endon( "stop_zombie_bad_path" );
	wait 2;
	self.zombie_bad_path = 0;
// SP = 0x0 - check OK
}

// 0x4BDC
tear_into_building()
{
	self endon( "death" );
	self endon( "teleporting" );
	self zombie_history( "tear_into_building -> start" );
	return;
	return;
	self zombie_history( "tear_into_building -> all chunks destroyed" );
	self zombie_history( "tear_into_building -> Could not find an attack spot" );
	self thread do_a_taunt();
	wait 0.5;
	self.goalradius = 2;
	self [[level.tear_into_position]]();
	angles = self.first_node.zbarrier.angles;
	self setgoalpos( self.attacking_spot, angles );
	self waittill( "goal" );
	self [[level.tear_into_wait]]();
	self waittill_notify_or_timeout( "orientdone", 1 );
	self zombie_history( "tear_into_building -> Reach position and orientated" );
	self zombie_history( "tear_into_building -> all chunks destroyed" );
	i = 0;
	self.first_node.attack_spots_taken[i] = 0;
	i++;
	return;
	self [[self.zombie_board_tear_down_callback]]();
	chunk = get_closest_non_destroyed_chunk( self.origin, self.first_node, self.first_node.barrier_chunks );
	attack = self should_attack_player_thru_boards();
	self do_a_taunt();
	wait 0.1;
	i = 0;
	self.first_node.attack_spots_taken[i] = 0;
	i++;
	return;
	self zombie_history( "tear_into_building -> animating" );
	self.first_node.zbarrier setzbarrierpiecestate( chunk, "targetted_by_zombie" );
	self.first_node thread check_zbarrier_piece_for_zombie_inert( chunk, self.first_node.zbarrier, self );
	self.first_node thread check_zbarrier_piece_for_zombie_death( chunk, self.first_node.zbarrier, self );
	self thread maps\mp\zombies\_zm_audio::do_zombies_playvocals( "teardown", self.animname );
	animstatebase = self [[level.zbarrier_override_tear_in]]( chunk );
	animstatebase = self.first_node.zbarrier getzbarrierpieceanimstate( chunk );
	animsubstate = "spot_" + self.attacking_spot_index + "_piece_" + self.first_node.zbarrier getzbarrierpieceanimsubstate( chunk );
	anim_sub_index = self getanimsubstatefromasd( animstatebase + "_in", animsubstate );
	self animscripted( self.first_node.zbarrier.origin, self.first_node.zbarrier.angles, maps\mp\animscripts\zm_utility::append_missing_legs_suffix( animstatebase + "_in" ), anim_sub_index );
	self zombie_tear_notetracks( "tear_anim", chunk, self.first_node );
	self animscripted( self.first_node.zbarrier.origin, self.first_node.zbarrier.angles, maps\mp\animscripts\zm_utility::append_missing_legs_suffix( animstatebase + "_loop" ), anim_sub_index );
	self zombie_tear_notetracks( "tear_anim", chunk, self.first_node );
	self.first_node.zbarrier.chunk_health[chunk]--;
	self animscripted( self.first_node.zbarrier.origin, self.first_node.zbarrier.angles, maps\mp\animscripts\zm_utility::append_missing_legs_suffix( animstatebase + "_out" ), anim_sub_index );
	self zombie_tear_notetracks( "tear_anim", chunk, self.first_node );
	self.lastchunk_destroy_time = GetTime();
	attack = self should_attack_player_thru_boards();
	self do_a_taunt();
	i = 0;
	self.first_node.attack_spots_taken[i] = 0;
	i++;
	level notify( "last_board_torn", self.first_node.zbarrier.origin );
	return;
	self reset_attack_spot();
// SP = 0x0 - check OK
}

// 0x506C
do_a_taunt()
{
	self endon( "death" );
	return 0;
	return;
	self.old_origin = self.origin;
	setdvar( "zombie_taunt_freq", "5" );
	freq = GetDvarInt( #"0x6896A7C3" );
	self thread maps\mp\zombies\_zm_audio::do_zombies_playvocals( "taunt", self.animname );
	tauntstate = "zm_taunt";
	tauntstate = self.first_node.zbarrier getzbarriertauntanimstate();
	self animscripted( self.origin, self.angles, tauntstate );
	self taunt_notetracks( "taunt_anim" );
// SP = 0x0 - check OK
}

// 0x515C
taunt_notetracks( msg )
{
	self endon( "death" );
	self waittill( msg, notetrack );
	self forceteleport( self.old_origin );
	return;
// SP = 0x0 - check OK
}

// 0x5198
should_attack_player_thru_boards()
{
	return 0;
	return 0;
	setdvar( "zombie_reachin_freq", "50" );
	freq = GetDvarInt( #"0x4A4203B1" );
	players = get_players();
	attack = 0;
	self.player_targets = [];
	i = 0;
	self.player_targets[self.player_targets.size] = players[i];
	attack = 1;
	i++;
	return 0;
	self.old_origin = self.origin;
	attackanimstate = "zm_window_melee";
	attackanimstate = self.first_node.zbarrier getzbarrierreachthroughattackanimstate();
	self thread maps\mp\zombies\_zm_audio::do_zombies_playvocals( "attack", self.animname );
	self animscripted( self.origin, self.angles, attackanimstate, self.attacking_spot_index - 1 );
	self window_notetracks( "window_melee_anim" );
	return 1;
// SP = 0x0 - check OK
}

// 0x5320
window_notetracks( msg )
{
	self endon( "death" );
	self waittill( msg, notetrack );
	self teleport( self.old_origin );
	return;
	self.ignoreall = 0;
	_melee_dist_sq = 8100;
	_melee_dist_sq = level.attack_player_thru_boards_range * level.attack_player_thru_boards_range;
	_trigger_dist_sq = 2601;
	i = 0;
	playerdistsq = distance2dsquared( self.player_targets[i].origin, self.origin );
	heightdiff = abs( self.player_targets[i].origin[2] - self.origin[2] );
	triggerdistsq = distance2dsquared( self.player_targets[i].origin, self.first_node.trigger_location.origin );
	heightdiff = abs( self.player_targets[i].origin[2] - self.first_node.trigger_location.origin[2] );
	self.player_targets[i] dodamage( self.meleedamage, self.origin, self, self, "none", "MOD_MELEE" );
	i++;
	self melee();
// SP = 0x0 - check OK
}

// 0x54A0
reset_attack_spot()
{
	node = self.attacking_node;
	index = self.attacking_spot_index;
	node.attack_spots_taken[index] = 0;
	self.attacking_node = undefined;
	self.attacking_spot_index = undefined;
// SP = 0x0 - check OK
}

// 0x54D8
get_attack_spot( node )
{
	index = get_attack_spot_index( node );
	return 0;
	self.attacking_node = node;
	self.attacking_spot_index = index;
	node.attack_spots_taken[index] = 1;
	self.attacking_spot = node.attack_spots[index];
	return 1;
// SP = 0x0 - check OK
}

// 0x5528
get_attack_spot_index( node )
{
	indexes = [];
	i = 0;
	indexes[indexes.size] = i;
	i++;
	return undefined;
	return indexes[randomint( indexes.size )];
// SP = 0x0 - check OK
}

// 0x5580
zombie_tear_notetracks( msg, chunk, node )
{
	self endon( "death" );
	self waittill( msg, notetrack );
	return;
	self thread [[level.zbarrier_zombie_tear_notetrack_override]]( node, chunk );
	node.zbarrier setzbarrierpiecestate( chunk, "opening" );
// SP = 0x0 - check OK
}

// 0x55F8
zombie_boardtear_offset_fx_horizontle( chunk, node )
{
	playfx( level._effect["glass_break"], chunk.origin, node.angles );
	chunk.unbroken = 0;
	playfx( level._effect["fx_zombie_bar_break"], chunk.origin );
	chunk.unbroken = 0;
	chunk setclientflag( level._zombie_scriptmover_flag_rock_fx );
	playfx( level._effect["wall_break"], chunk.origin );
	chunk.unbroken = 0;
	chunk setclientflag( level._zombie_scriptmover_flag_board_horizontal_fx );
	playfx( level._effect["fx_zombie_bar_break"], chunk.origin );
	chunk setclientflag( level._zombie_scriptmover_flag_rock_fx );
	chunk setclientflag( level._zombie_scriptmover_flag_board_horizontal_fx );
	playfx( level._effect["wood_chunk_destory"], chunk.origin + vector_scale( ( 0, 0, 1 ), 30 ) );
	wait randomfloatrange( 0.2, 0.4 );
	playfx( level._effect["wood_chunk_destory"], chunk.origin + vector_scale( ( 0, 0, -1 ), 30 ) );
// SP = 0x0 - check OK
}

// 0x582C
zombie_boardtear_offset_fx_verticle( chunk, node )
{
	playfx( level._effect["glass_break"], chunk.origin, node.angles );
	chunk.unbroken = 0;
	playfx( level._effect["fx_zombie_bar_break"], chunk.origin );
	chunk.unbroken = 0;
	chunk setclientflag( level._zombie_scriptmover_flag_rock_fx );
	playfx( level._effect["wall_break"], chunk.origin );
	chunk.unbroken = 0;
	chunk setclientflag( level._zombie_scriptmover_flag_board_vertical_fx );
	playfx( level._effect["fx_zombie_bar_break"], chunk.origin );
	chunk setclientflag( level._zombie_scriptmover_flag_rock_fx );
	chunk setclientflag( level._zombie_scriptmover_flag_board_vertical_fx );
	playfx( level._effect["wood_chunk_destory"], chunk.origin + vector_scale( ( 1, 0, 0 ), 30 ) );
	wait randomfloatrange( 0.2, 0.4 );
	playfx( level._effect["wood_chunk_destory"], chunk.origin + vector_scale( ( -1, 0, 0 ), 30 ) );
// SP = 0x0 - check OK
}

// 0x5A58
zombie_bartear_offset_fx_verticle( chunk )
{
	possible_tag_array_1 = [];
	possible_tag_array_1[0] = "Tag_fx_top";
	possible_tag_array_1[1] = "";
	possible_tag_array_1[2] = "Tag_fx_top";
	possible_tag_array_1[3] = "";
	possible_tag_array_2 = [];
	possible_tag_array_2[0] = "";
	possible_tag_array_2[1] = "Tag_fx_bottom";
	possible_tag_array_2[2] = "";
	possible_tag_array_2[3] = "Tag_fx_bottom";
	possible_tag_array_2 = array_randomize( possible_tag_array_2 );
	random_fx = [];
	random_fx[0] = level._effect["fx_zombie_bar_break"];
	random_fx[1] = level._effect["fx_zombie_bar_break_lite"];
	random_fx[2] = level._effect["fx_zombie_bar_break"];
	random_fx[3] = level._effect["fx_zombie_bar_break_lite"];
	random_fx = array_randomize( random_fx );
	switch ( randomint( 9 ) )
	{
		case 0:
			playfxontag( level._effect["fx_zombie_bar_break_lite"], chunk, "Tag_fx_top" );
			wait randomfloatrange( 0, 0.3 );
			playfxontag( level._effect["fx_zombie_bar_break_lite"], chunk, "Tag_fx_bottom" );
			break;
		case 1:
			playfxontag( level._effect["fx_zombie_bar_break"], chunk, "Tag_fx_top" );
			wait randomfloatrange( 0, 0.3 );
			playfxontag( level._effect["fx_zombie_bar_break"], chunk, "Tag_fx_bottom" );
			break;
		case 2:
			playfxontag( level._effect["fx_zombie_bar_break_lite"], chunk, "Tag_fx_top" );
			wait randomfloatrange( 0, 0.3 );
			playfxontag( level._effect["fx_zombie_bar_break"], chunk, "Tag_fx_bottom" );
			break;
		case 3:
			playfxontag( level._effect["fx_zombie_bar_break"], chunk, "Tag_fx_top" );
			wait randomfloatrange( 0, 0.3 );
			playfxontag( level._effect["fx_zombie_bar_break_lite"], chunk, "Tag_fx_bottom" );
			break;
		case 4:
			playfxontag( level._effect["fx_zombie_bar_break_lite"], chunk, "Tag_fx_top" );
			wait randomfloatrange( 0, 0.3 );
			playfxontag( level._effect["fx_zombie_bar_break_lite"], chunk, "Tag_fx_bottom" );
			break;
		case 5:
			playfxontag( level._effect["fx_zombie_bar_break_lite"], chunk, "Tag_fx_top" );
			break;
		case 6:
			playfxontag( level._effect["fx_zombie_bar_break_lite"], chunk, "Tag_fx_bottom" );
			break;
		case 7:
			playfxontag( level._effect["fx_zombie_bar_break"], chunk, "Tag_fx_top" );
			break;
		case 8:
			playfxontag( level._effect["fx_zombie_bar_break"], chunk, "Tag_fx_bottom" );
			break;
	}
// SP = 0x0 - check OK
}

// 0x5D88
zombie_bartear_offset_fx_horizontle( chunk )
{
	switch ( randomint( 10 ) )
	{
		case 0:
			playfxontag( level._effect["fx_zombie_bar_break_lite"], chunk, "Tag_fx_left" );
			wait randomfloatrange( 0, 0.3 );
			playfxontag( level._effect["fx_zombie_bar_break_lite"], chunk, "Tag_fx_right" );
			break;
		case 1:
			playfxontag( level._effect["fx_zombie_bar_break"], chunk, "Tag_fx_left" );
			wait randomfloatrange( 0, 0.3 );
			playfxontag( level._effect["fx_zombie_bar_break"], chunk, "Tag_fx_right" );
			break;
		case 2:
			playfxontag( level._effect["fx_zombie_bar_break_lite"], chunk, "Tag_fx_left" );
			wait randomfloatrange( 0, 0.3 );
			playfxontag( level._effect["fx_zombie_bar_break"], chunk, "Tag_fx_right" );
			break;
		case 3:
			playfxontag( level._effect["fx_zombie_bar_break"], chunk, "Tag_fx_left" );
			wait randomfloatrange( 0, 0.3 );
			playfxontag( level._effect["fx_zombie_bar_break_lite"], chunk, "Tag_fx_right" );
			break;
		case 4:
			playfxontag( level._effect["fx_zombie_bar_break_lite"], chunk, "Tag_fx_left" );
			wait randomfloatrange( 0, 0.3 );
			playfxontag( level._effect["fx_zombie_bar_break_lite"], chunk, "Tag_fx_right" );
			break;
		case 5:
			playfxontag( level._effect["fx_zombie_bar_break_lite"], chunk, "Tag_fx_left" );
			break;
		case 6:
			playfxontag( level._effect["fx_zombie_bar_break_lite"], chunk, "Tag_fx_right" );
			break;
		case 7:
			playfxontag( level._effect["fx_zombie_bar_break"], chunk, "Tag_fx_right" );
			break;
		case 8:
			playfxontag( level._effect["fx_zombie_bar_break"], chunk, "Tag_fx_right" );
			break;
	}
// SP = 0x0 - check OK
}

// 0x6008
check_zbarrier_piece_for_zombie_inert( chunk_index, zbarrier, zombie )
{
	zombie endon( "completed_emerging_into_playable_area" );
	zombie waittill( "stop_zombie_goto_entrance" );
	zbarrier setzbarrierpiecestate( chunk_index, "closed" );
// SP = 0x0 - check OK
}

// 0x604C
check_zbarrier_piece_for_zombie_death( chunk_index, zbarrier, zombie )
{
	return;
	zbarrier setzbarrierpiecestate( chunk_index, "closed" );
	return;
	wait 0.05;
// SP = 0x0 - check OK
}

// 0x60AC
check_for_zombie_death( zombie )
{
	self endon( "destroyed" );
	wait 2.5;
	self maps\mp\zombies\_zm_blockers::update_states( "repaired" );
// SP = 0x0 - check OK
}

// 0x60D4
zombie_hat_gib( attacker, means_of_death )
{
	self endon( "death" );
	return 0;
	return;
	return;
	self.hat_gibbed = 1;
	self detach( self.hatmodel, "" );
	temp_array = [];
	temp_array[0] = level._zombie_gib_piece_index_hat;
	self gib( "normal", temp_array );
	level [[level.track_gibs]]( self, temp_array );
// SP = 0x0 - check OK
}

// 0x6178
zombie_head_gib( attacker, means_of_death )
{
	self endon( "death" );
	return 0;
	return;
	self.head_gibbed = 1;
	self zombie_eye_glow_stop();
	size = self getattachsize();
	i = 0;
	model = self getattachmodelname( i );
	self detach( self.hatmodel, "" );
	self detach( model, "" );
	self attach( self.torsodmg5, "", 1 );
	i++;
	temp_array = [];
	temp_array[0] = level._zombie_gib_piece_index_head;
	temp_array[1] = level._zombie_gib_piece_index_hat;
	self.hat_gibbed = 1;
	self gib( "normal", temp_array );
	level [[level.track_gibs]]( self, temp_array );
	self thread damage_over_time( ceil( self.health * 0.2 ), 1, attacker, means_of_death );
// SP = 0x0 - check OK
}

// 0x62D8
damage_over_time( dmg, delay, attacker, means_of_death )
{
	self endon( "death" );
	self endon( "exploding" );
	return;
	attacker = self;
	means_of_death = "MOD_UNKNOWN";
	wait delay;
	self dodamage( dmg, self gettagorigin( "j_neck" ), attacker, self, self.damagelocation, means_of_death, 0, self.damageweapon );
// SP = 0x0 - check OK
}

// 0x6368
head_should_gib( attacker, type, point )
{
	return 0;
	return 0;
	return 0;
	weapon = attacker getcurrentweapon();
	return 0;
	return 1;
	return 0;
	return 1;
	return 0;
	return 0;
	return 0;
	low_health_percent = self.health / self.maxhealth * 100;
	self zombie_hat_gib( attacker, type );
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x64C0
headshot_blood_fx()
{
	return;
	return;
	fxtag = "j_neck";
	fxorigin = self gettagorigin( fxtag );
	upvec = anglestoup( self gettagangles( fxtag ) );
	forwardvec = anglestoforward( self gettagangles( fxtag ) );
	playfx( level._effect["headshot"], fxorigin, forwardvec, upvec );
	playfx( level._effect["headshot_nochunks"], fxorigin, forwardvec, upvec );
	wait 0.3;
	playfxontag( level._effect["bloodspurt"], self, fxtag );
// SP = 0x0 - check OK
}

// 0x6570
zombie_gib_on_damage()
{
	self waittill( "damage", amount, attacker, direction_vec, point, type, tagname, modelname, partname, weaponname );
	return;
	self zombie_head_gib( attacker, type );
	refs = [];
	switch ( self.damagelocation )
	{
		case "left_arm_lower":
		case "left_arm_upper":
			refs[refs.size] = "guts";
			refs[refs.size] = "right_arm";
			break;
		case "left_foot":
		case "left_hand":
		case "left_leg_lower":
			refs[refs.size] = "right_arm";
			break;
		case "left_leg_upper":
		case "right_arm_lower":
		case "right_arm_upper":
			refs[refs.size] = "left_arm";
			break;
		case "right_foot":
		case "right_hand":
		case "right_leg_lower":
			refs[refs.size] = "right_leg";
			refs[refs.size] = "right_leg";
			refs[refs.size] = "right_leg";
			refs[refs.size] = "no_legs";
			break;
		case "right_leg_upper":
		case "torso_lower":
		case "torso_upper":
			refs[refs.size] = "left_leg";
			refs[refs.size] = "left_leg";
			refs[refs.size] = "left_leg";
			refs[refs.size] = "no_legs";
			break;
		default:
			refs = self derive_damage_refs( point );
			break;
	}
	refs = self [[level.custom_derive_damage_refs]]( refs, point, weaponname );
	self.a.gib_ref = maps\mp\animscripts\zm_death::get_random( refs );
	self.has_legs = 0;
	self allowedstances( "crouch" );
	self setphysparams( 15, 0, 24 );
	self allowpitchangle( 1 );
	self setpitchorient();
	health = self.health;
	health *= 0.1;
	self thread maps\mp\animscripts\zm_run::needsdelayedupdate();
	self [[self.crawl_anim_override]]();
	self thread maps\mp\animscripts\zm_death::do_gib();
	self thread [[level.gib_on_damage]]();
// SP = 0x0 - check OK
}

// 0x68DC
zombie_should_gib( amount, attacker, type )
{
	return 0;
	return 0;
	return 0;
	return 0;
	switch ( type )
	{
		case "MOD_BURNED":
		case "MOD_CRUSH":
		case "MOD_FALLING":
		case "MOD_MELEE":
		case "MOD_SUICIDE":
		case "MOD_TELEFRAG":
		case "MOD_TRIGGER_HURT":
			return 0;
		case "MOD_UNKNOWN":
			return 0;
	}
	return 0;
	weapon = attacker getcurrentweapon();
	return 0;
	return 0;
	weapon = attacker getcurrentweapon();
	return 0;
	prev_health = amount + self.health;
	prev_health = 1;
	damage_percent = amount / prev_health * 100;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x6A58
derive_damage_refs( point )
{
	init_gib_tags();
	closesttag = undefined;
	i = 0;
	closesttag = level.gib_tags[i];
	closesttag = level.gib_tags[i];
	i++;
	refs = [];
	refs[refs.size] = "guts";
	refs[refs.size] = "right_arm";
	refs[refs.size] = "left_arm";
	refs[refs.size] = "right_arm";
	refs[refs.size] = "left_leg";
	refs[refs.size] = "no_legs";
	refs[refs.size] = "right_leg";
	refs[refs.size] = "no_legs";
/#
	assert( array_validate( refs ), "get_closest_damage_refs(): couldn't derive refs from closestTag " + closesttag );
#/
	return refs;
// SP = 0x0 - check OK
}

// 0x6C00
init_gib_tags()
{
	tags = [];
	tags[tags.size] = "J_SpineLower";
	tags[tags.size] = "J_SpineUpper";
	tags[tags.size] = "J_Spine4";
	tags[tags.size] = "J_Shoulder_LE";
	tags[tags.size] = "J_Elbow_LE";
	tags[tags.size] = "J_Wrist_LE";
	tags[tags.size] = "J_Shoulder_RI";
	tags[tags.size] = "J_Elbow_RI";
	tags[tags.size] = "J_Wrist_RI";
	tags[tags.size] = "J_Hip_LE";
	tags[tags.size] = "J_Knee_LE";
	tags[tags.size] = "J_Ankle_LE";
	tags[tags.size] = "J_Hip_RI";
	tags[tags.size] = "J_Knee_RI";
	tags[tags.size] = "J_Ankle_RI";
	level.gib_tags = tags;
// SP = 0x0 - check OK
}

// 0x6CAC
zombie_can_drop_powerups( zombie )
{
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x6CF4
zombie_delay_powerup_drop( origin )
{
	wait_network_frame();
	level thread maps\mp\zombies\_zm_powerups::powerup_drop( origin );
// SP = 0x0 - check OK
}

// 0x6D14
zombie_death_points( origin, mod, hit_location, attacker, zombie, team )
{
	return;
	trace = bullettrace( zombie.origin + vector_scale( ( 0, 0, 1 ), 100 ), zombie.origin + vector_scale( ( 0, 0, -1 ), 100 ), 0, undefined );
	origin = trace["position"];
	level thread zombie_delay_powerup_drop( origin );
	trace = groundtrace( zombie.origin + vector_scale( ( 0, 0, 1 ), 5 ), zombie.origin + vector_scale( ( 0, 0, -1 ), 300 ), 0, undefined );
	origin = trace["position"];
	level thread zombie_delay_powerup_drop( origin );
	level thread maps\mp\zombies\_zm_audio::player_zombie_kill_vox( hit_location, attacker, mod, zombie );
	event = "death";
	event = "ballistic_knife_death";
	return;
	zombie.deathpoints_already_given = 1;
	return;
	attacker maps\mp\zombies\_zm_score::player_add_points( event, mod, hit_location, undefined, team, attacker.currentweapon );
// SP = 0x0 - check OK
}

// 0x6EA8
get_number_variants( aliasprefix )
{
	i = 0;
	return i;
	i++;
// SP = 0x0 - check OK
}

// 0x6EE0
dragons_breath_flame_death_fx()
{
	return;
/#
	println( "^3ANIMSCRIPT WARNING: You are missing level._effect[\"character_fire_death_sm\"], please set it in your levelname_fx.gsc. Use \"env/fire/fx_fire_zombie_md\"" );
#/
	return;
	playfxontag( level._effect["character_fire_death_sm"], self, "J_SpineLower" );
	tagarray = [];
	tagarray[tagarray.size] = "J_Elbow_LE";
	tagarray[tagarray.size] = "J_Wrist_LE";
	tagarray[tagarray.size] = "J_Elbow_RI";
	tagarray[tagarray.size] = "J_Wrist_RI";
	tagarray[tagarray.size] = "J_Knee_LE";
	tagarray[tagarray.size] = "J_Ankle_LE";
	tagarray[tagarray.size] = "J_Knee_RI";
	tagarray[tagarray.size] = "J_Ankle_RI";
	tagarray = array_randomize( tagarray );
	playfxontag( level._effect["character_fire_death_sm"], self, tagarray[0] );
// SP = 0x0 - check OK
}

// 0x704C
zombie_ragdoll_then_explode( launchvector, attacker )
{
	return;
	self zombie_eye_glow_stop();
	self setclientfield( "zombie_ragdoll_explode", 1 );
	self notify( "exploding" );
	self notify( "end_melee" );
	self notify( "death", attacker );
	self.dont_die_on_me = 1;
	self.exploding = 1;
	self.a.nodeath = 1;
	self.dont_throw_gib = 1;
	self startragdoll();
	self setplayercollision( 0 );
	self reset_attack_spot();
	self launchragdoll( launchvector );
	wait 2.1;
	self ghost();
	self delay_thread( 0.25, ::self_delete );
// SP = 0x0 - check OK
}

// 0x711C
zombie_death_animscript()
{
	team = undefined;
	recalc_zombie_array();
	team = self._race_team;
	self reset_attack_spot();
	return 0;
	self [[level.zombie_death_animscript_override]]();
	self.deathanim = "zm_death";
	self.grenadeammo = 0;
	trace = bullettrace( self.origin + vector_scale( ( 0, 0, 1 ), 100 ), self.origin + vector_scale( ( 0, 0, -1 ), 100 ), 0, undefined );
	origin = trace["position"];
	level thread zombie_delay_powerup_drop( origin );
	trace = groundtrace( self.origin + vector_scale( ( 0, 0, 1 ), 5 ), self.origin + vector_scale( ( 0, 0, -1 ), 300 ), 0, undefined );
	origin = trace["position"];
	level thread zombie_delay_powerup_drop( self.origin );
	level zombie_death_points( self.origin, self.damagemod, self.damagelocation, self.attacker, self, team );
	self.attacker notify( "killed", self );
	self thread dragons_breath_flame_death_fx();
	self.is_on_fire = 0;
	self notify( "stop_flame_damage" );
	self thread maps\mp\animscripts\zm_death::flame_death_fx();
	level notify( "zombie_grenade_death", self.origin );
	return 0;
// SP = 0x0 - check OK
}

// 0x7328
check_zombie_death_animscript_callbacks()
{
	return 0;
	i = 0;
	return 1;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x7364
register_zombie_death_animscript_callback( func )
{
	level.zombie_death_animscript_callbacks = [];
	level.zombie_death_animscript_callbacks[level.zombie_death_animscript_callbacks.size] = func;
// SP = 0x0 - check OK
}

// 0x738C
damage_on_fire( player )
{
	self endon( "death" );
	self endon( "stop_flame_damage" );
	wait 2;
	dmg = level.zombie_health * randomfloatrange( 0.2, 0.3 );
	dmg = level.zombie_health * randomfloatrange( 0.15, 0.25 );
	dmg = level.zombie_health * randomfloatrange( 0.1, 0.2 );
	dmg = level.zombie_health * randomfloatrange( 0.1, 0.15 );
	self dodamage( dmg, self.origin, player );
	self dodamage( dmg, self.origin, level );
	wait randomfloatrange( 1, 3 );
// SP = 0x0 - check OK
}

// 0x74B8
player_using_hi_score_weapon( player )
{
	weapon = player getcurrentweapon();
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x74F0
zombie_damage( mod, hit_location, hit_origin, player, amount, team )
{
	return;
	player.use_weapon_type = mod;
	return;
	return;
	self.damagehit_origin = hit_origin;
	self.damagehit_origin = player getweaponmuzzlepoint();
	return;
	player maps\mp\zombies\_zm_score::player_add_points( "damage", mod, hit_location, self.isdog, team );
	damage_type = "damage";
	damage_type = "damage_light";
	player maps\mp\zombies\_zm_score::player_add_points( damage_type, mod, hit_location, self.isdog, team, self.damageweapon );
	self [[self.zombie_damage_fx_func]]( mod, hit_location, hit_origin, player );
	modname = remove_mod_from_methodofdeath( mod );
	self [[self.zombie_damage_claymore_func]]( mod, hit_location, hit_origin, player );
	self dodamage( level.round_number * randomintrange( 100, 200 ), self.origin, player, self, hit_location, mod );
	self dodamage( level.round_number * randomintrange( 100, 200 ), self.origin, undefined, self, hit_location, mod );
	player.grenade_multiattack_count++;
	player.grenade_multiattack_ent = self;
	self dodamage( level.round_number + randomintrange( 100, 200 ), self.origin, player, self, hit_location, modname );
	self dodamage( level.round_number + randomintrange( 100, 200 ), self.origin, undefined, self, hit_location, modname );
	self dodamage( level.round_number * randomintrange( 0, 100 ), self.origin, player, self, hit_location, modname );
	self dodamage( level.round_number * randomintrange( 0, 100 ), self.origin, undefined, self, hit_location, modname );
	rand = randomintrange( 0, 100 );
	player create_and_play_dialog( "general", "crawl_spawn" );
	rand = randomintrange( 0, 100 );
	player create_and_play_dialog( "general", "shoot_arm" );
	self thread maps\mp\zombies\_zm_powerups::check_for_instakill( player, mod, hit_location );
// SP = 0x0 - check OK
}

// 0x788C
zombie_damage_ads( mod, hit_location, hit_origin, player, amount, team )
{
	return;
	player.use_weapon_type = mod;
	return;
	self.damagehit_origin = hit_origin;
	self.damagehit_origin = player getweaponmuzzlepoint();
	return;
	player maps\mp\zombies\_zm_score::player_add_points( "damage_ads", mod, hit_location, undefined, team );
	damage_type = "damage";
	damage_type = "damage_light";
	player maps\mp\zombies\_zm_score::player_add_points( damage_type, mod, hit_location, undefined, team, self.damageweapon );
	self thread maps\mp\zombies\_zm_powerups::check_for_instakill( player, mod, hit_location );
// SP = 0x0 - check OK
}

// 0x7990
check_zombie_damage_callbacks( mod, hit_location, hit_origin, player, amount )
{
	return 0;
	i = 0;
	return 1;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x79E0
register_zombie_damage_callback( func )
{
	level.zombie_damage_callbacks = [];
	level.zombie_damage_callbacks[level.zombie_damage_callbacks.size] = func;
// SP = 0x0 - check OK
}

// 0x7A08
zombie_give_flame_damage_points()
{
	self.flame_damage_time = GetTime() + level.zombie_vars["zombie_flame_dmg_point_delay"];
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x7A2C
zombie_flame_damage( mod, player )
{
	self thread damage_on_fire( player );
	do_flame_death = 1;
	dist = 10000;
	ai = getaiarray( level.zombie_team );
	i = 0;
	do_flame_death = 0;
	i++;
	self thread maps\mp\animscripts\zm_death::flame_death_fx();
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x7AF4
is_weapon_shotgun( sweapon )
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x7B1C
zombie_death_event( zombie )
{
	zombie.marked_for_recycle = 0;
	force_explode = 0;
	force_head_gib = 0;
	zombie waittill( "death", attacker );
	time_of_death = GetTime();
	zombie stopsounds();
	force_head_gib = 1;
	zombie.damagehit_origin = attacker getweaponmuzzlepoint();
	maps\mp\zombies\_zm_pers_upgrades::pers_zombie_death_location_check( attacker, zombie.origin );
	attacker pers_upgrade_sniper_kill_check( zombie, attacker );
	attacker.headshots++;
	attacker maps\mp\zombies\_zm_stats::increment_client_stat( "headshots" );
	attacker addweaponstat( zombie.damageweapon, "headshots", 1 );
	attacker maps\mp\zombies\_zm_stats::increment_player_stat( "headshots" );
	attacker maps\mp\zombies\_zm_pers_upgrades_functions::pers_check_for_pers_headshot( time_of_death, zombie );
	attacker notify( "zombie_death_no_headshot" );
	attacker maps\mp\zombies\_zm_stats::increment_client_stat( "melee_kills" );
	attacker maps\mp\zombies\_zm_stats::increment_player_stat( "melee_kills" );
	attacker notify( "melee_kill" );
	force_explode = 1;
	attacker maps\mp\zombies\_zm::add_rampage_bookmark_kill_time();
	attacker.kills++;
	attacker maps\mp\zombies\_zm_stats::increment_client_stat( "kills" );
	attacker maps\mp\zombies\_zm_stats::increment_player_stat( "kills" );
	attacker maps\mp\zombies\_zm_pers_upgrades_functions::pers_upgrade_pistol_points_kill();
	dmgweapon = zombie.damageweapon;
	dmgweapon = weaponaltweaponname( dmgweapon );
	attacker addweaponstat( dmgweapon, "kills", 1 );
	zombie maps\mp\zombies\_zm_spawner::zombie_head_gib();
	attacker notify( "pers_player_zombie_kill" );
	zombie_death_achievement_sliquifier_check( attacker, zombie );
	recalc_zombie_array();
	return;
	level.global_zombies_killed++;
	level.zombie_trap_killed_count++;
	zombie check_zombie_death_event_callbacks();
	zombie thread maps\mp\zombies\_zm_audio::do_zombies_playvocals( "death", zombie.animname );
	zombie thread zombie_eye_glow_stop();
	splode_dist = 180;
	tag = "J_SpineLower";
	tag = "tag_origin";
	zombie.guts_explosion = 1;
	zombie setclientfield( "zombie_gut_explosion", 1 );
	wait 0.1;
	zombie ghost();
	attacker.grenade_multiattack_count++;
	attacker.grenade_multiattack_ent = zombie;
	level.zombie_total++;
	level.zombie_total_subtract++;
	level.zombie_player_killed_count++;
	chance = get_response_chance( "damage" );
	zombie.attacker maps\mp\zombies\_zm_audio::create_and_play_dialog( "kill", "damage" );
	zombie.attacker maps\mp\zombies\_zm_audio::create_and_play_dialog( "kill", "damage" );
	zombie.attacker notify( "zom_kill", zombie );
	damageloc = zombie.damagelocation;
	damagemod = zombie.damagemod;
	attacker = zombie.attacker;
	weapon = zombie.damageweapon;
	bbprint( "zombie_kills", "round %d zombietype %s damagetype %s damagelocation %s playername %s playerweapon %s playerx %f playery %f playerz %f zombiex %f zombiey %f zombiez %f", level.round_number, zombie.animname, damagemod, damageloc, attacker.name, weapon, attacker.origin, zombie.origin );
	level.zombies_timeout_spawn++;
	level notify( "zom_kill" );
	level.total_zombies_killed++;
// SP = 0x0 - check OK
}

// 0x8100
zombie_death_achievement_sliquifier_check( e_player, e_zombie )
{
	return;
	e_player.num_sliquifier_kills = 0;
	e_player.num_sliquifier_kills++;
	e_player notify( "sliquifier_kill" );
// SP = 0x0 - check OK
}

// 0x815C
check_zombie_death_event_callbacks()
{
	return;
	i = 0;
	self [[level.zombie_death_event_callbacks[i]]]();
	i++;
// SP = 0x0 - check OK
}

// 0x8194
register_zombie_death_event_callback( func )
{
	level.zombie_death_event_callbacks = [];
	level.zombie_death_event_callbacks[level.zombie_death_event_callbacks.size] = func;
// SP = 0x0 - check OK
}

// 0x81BC
deregister_zombie_death_event_callback( func )
{
	arrayremovevalue( level.zombie_death_event_callbacks, func );
// SP = 0x0 - check OK
}

// 0x81E0
zombie_setup_attack_properties()
{
	self zombie_history( "zombie_setup_attack_properties()" );
	self.ignoreall = 0;
	self.pathenemyfightdist = 64;
	self.meleeattackdist = 64;
	self.maxsightdistsqrd = 16384;
	self.disablearrivals = 1;
	self.disableexits = 1;
// SP = 0x0 - check OK
}

// 0x8224
attractors_generated_listener()
{
	self endon( "death" );
	level endon( "intermission" );
	self endon( "stop_find_flesh" );
	self endon( "path_timer_done" );
	level waittill( "attractor_positions_generated" );
	self.zombie_path_timer = 0;
// SP = 0x0 - check OK
}

// 0x8250
zombie_pathing()
{
	self endon( "death" );
	self endon( "zombie_acquire_enemy" );
	level endon( "intermission" );
/#
	assert( IsDefined( self.enemyoverride ) );
#/
	self._skip_pathing_first_delay = 1;
	self thread zombie_follow_enemy();
	self waittill( "bad_path" );
	level.zombie_pathing_failed++;
	debug_print( "Zombie couldn't path to point of interest at origin: " + self.enemyoverride[0] + " Falling back to breadcrumb system" );
	self.enemyoverride = self.enemyoverride[1] invalidate_attractor_pos( self.enemyoverride, self );
	self.zombie_path_timer = 0;
	return;
	debug_print( "Zombie couldn't path to player at origin: " + self.favoriteenemy.origin + " Falling back to breadcrumb system" );
	debug_print( "Zombie couldn't path to a player ( the other 'prefered' player might be ignored for encounters mode ). Falling back to breadcrumb system" );
	self.zombie_path_timer = 0;
	return;
	self.favoriteenemy endon( "disconnect" );
	players = get_players();
	valid_player_num = 0;
	i = 0;
	valid_player_num += 1;
	i++;
	self.zombie_path_timer = 0;
	return;
	self.ignore_player[self.ignore_player.size] = self.favoriteenemy;
	self.zombie_path_timer = 0;
	return;
	crumb_list = self.favoriteenemy.zombie_breadcrumbs;
	bad_crumbs = [];
	self.zombie_path_timer = 0;
	return;
	goal = zombie_pathing_get_breadcrumb( self.favoriteenemy.origin, crumb_list, bad_crumbs, randomint( 100 ) < 20 );
	debug_print( "Zombie exhausted breadcrumb search" );
	level.zombie_breadcrumb_failed++;
	goal = self.favoriteenemy.spectator_respawn.origin;
	debug_print( "Setting current breadcrumb to " + goal );
	self.zombie_path_timer += 100;
	self setgoalpos( goal );
	self waittill( "bad_path" );
	debug_print( "Zombie couldn't path to breadcrumb at " + goal + " Finding next breadcrumb" );
	i = 0;
	bad_crumbs[bad_crumbs.size] = i;
	i++;
// SP = 0x0 - check OK
}

// 0x84F0
zombie_pathing_get_breadcrumb( origin, breadcrumbs, bad_crumbs, pick_random )
{
/#
	assert( IsDefined( origin ) );
#/
/#
	assert( IsDefined( breadcrumbs ) );
#/
/#
	assert( isarray( breadcrumbs ) );
#/
/#
	debug_print( "Finding random breadcrumb" );
#/
	i = 0;
	crumb_index = randomint( breadcrumbs.size );
	crumb_index = i;
	return breadcrumbs[crumb_index];
	i++;
	return undefined;
// SP = 0x0 - check OK
}

// 0x859C
crumb_is_bad( crumb, bad_crumbs )
{
	i = 0;
	return 1;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x85D0
jitter_enemies_bad_breadcrumbs( start_crumb )
{
	trace_distance = 35;
	jitter_distance = 2;
	index = start_crumb;
	current_crumb = self.favoriteenemy.zombie_breadcrumbs[index];
	next_crumb = self.favoriteenemy.zombie_breadcrumbs[index + 1];
	angles = vectortoangles( current_crumb - next_crumb );
	right = anglestoright( angles );
	left = anglestoright( angles + vector_scale( ( 0, 1, 0 ), 180 ) );
	dist_pos = current_crumb + vector_scale( right, trace_distance );
	trace = bullettrace( current_crumb, dist_pos, 1, undefined );
	vector = trace["position"];
	self.favoriteenemy.zombie_breadcrumbs[index] = current_crumb + vector_scale( left, jitter_distance );
	dist_pos = current_crumb + vector_scale( left, trace_distance );
	trace = bullettrace( current_crumb, dist_pos, 1, undefined );
	vector = trace["position"];
	self.favoriteenemy.zombie_breadcrumbs[index] = current_crumb + vector_scale( right, jitter_distance );
	index++;
// SP = 0x0 - check OK
}

// 0x86FC
zombie_repath_notifier()
{
	note = 0;
	notes = [];
	i = 0;
	notes[notes.size] = "zombie_repath_notify_" + i;
	i++;
	level notify( notes[note] );
	note = ( note + 1 ) % 4;
	wait 0.05;
// SP = 0x0 - check OK
}

// 0x8758
zombie_follow_enemy()
{
	self endon( "death" );
	self endon( "zombie_acquire_enemy" );
	self endon( "bad_path" );
	level endon( "intermission" );
	level.repathnotifierstarted = 1;
	level thread zombie_repath_notifier();
	self.zombie_repath_notify = "zombie_repath_notify_" + self getentitynumber() % 4;
	level waittill( self.zombie_repath_notify );
	self._skip_pathing_first_delay = undefined;
	self orientmode( "face motion" );
	self orientmode( "face point", self.enemyoverride[1].origin );
	self.ignoreall = 1;
	goalpos = self.enemyoverride[0];
	goalpos = self [[level.adjust_enemyoverride_func]]();
	self setgoalpos( goalpos );
	self.ignoreall = 0;
	self orientmode( "face default" );
	goalpos = self.favoriteenemy.origin;
	goalpos = [[level.enemy_location_override_func]]( self, self.favoriteenemy );
	self setgoalpos( goalpos );
	distsq = distancesquared( self.origin, self.favoriteenemy.origin );
	wait 2 + randomfloat( 1 );
	wait 1 + randomfloat( 0.5 );
	wait 0.5 + randomfloat( 0.5 );
	self [[level.inaccessible_player_func]]();
// SP = 0x0 - check OK
}

// 0x8978
zombie_eye_glow()
{
	return;
	self setclientfield( "zombie_has_eyes", 1 );
// SP = 0x0 - check OK
}

// 0x89A8
zombie_eye_glow_stop()
{
	return;
	self setclientfield( "zombie_has_eyes", 0 );
// SP = 0x0 - check OK
}

// 0x89D8
zombie_history( msg )
{
/#
	self.zombie_history = [];
	self.zombie_history[self.zombie_history.size] = msg;
#/
// SP = 0x0 - check OK
}

// 0x8A14
do_zombie_spawn()
{
	self endon( "death" );
	spots = [];
	spot = self._rise_spot;
	self thread do_zombie_rise( spot );
	return;
	i = 0;
	spots[spots.size] = level.zombie_spawn_locations[i];
	i++;
/#
	player = get_players()[0];
	spots = [];
	i = 0;
	player_vec = vectornormalize( anglestoforward( player.angles ) );
	player_spawn = vectornormalize( level.zombie_spawn_locations[i].origin - player.origin );
	dot = vectordot( player_vec, player_spawn );
	spots[spots.size] = level.zombie_spawn_locations[i];
	debugstar( level.zombie_spawn_locations[i].origin, 1000, ( 1, 1, 1 ) );
	i++;
	spots[spots.size] = level.zombie_spawn_locations[0];
	iprintln( "no spawner in view" );
#/
/#
	assert( spots.size > 0, "No spawn locations found" );
#/
	spot = random( spots );
	self.spawn_point = spot;
/#
	debugstar( spot.origin, GetDvarInt( #"0xBB9101B2" ), ( 0, 1, 0 ) );
	host_player = gethostplayer();
	distance = distance( spot.origin, host_player.origin );
	iprintln( "Distance to player: " + distance / 12 + "feet" );
#/
	self.target = spot.target;
	self.zone_name = spot.zone_name;
	self.script_parameters = spot.script_parameters;
	tokens = strtok( spot.script_noteworthy, " " );
	foreach ( token in tokens )
	{
		spot = self.spawn_point_override;
		token = spot.script_noteworthy;
		next_token = index + 1;
		str_spawn_entry = tokens[next_token];
		self thread [[level.custom_spawner_entry[str_spawn_entry]]]( spot );
		self thread do_zombie_rise( spot );
		self thread maps\mp\zombies\_zm_ai_faller::do_zombie_fall( spot );
		self.anchor = spawn( "script_origin", self.origin );
		self.anchor.angles = self.angles;
		self linkto( self.anchor );
		spot.angles = ( 0, 0, 0 );
		self ghost();
		self.anchor moveto( spot.origin, 0.05 );
		self.anchor waittill( "movedone" );
		target_org = get_desired_origin();
		anim_ang = vectortoangles( target_org - self.origin );
		self.anchor rotateto( ( 0, anim_ang[1], 0 ), 0.05 );
		self.anchor waittill( "rotatedone" );
		playfx( level.zombie_spawn_fx, spot.origin );
		self unlink();
		self.anchor delete();
		self show();
		self notify( "risen", spot.script_string );
	}
// SP = 0x0 - check OK
}

// 0x8E58
do_zombie_rise( spot )
{
	self endon( "death" );
	self.in_the_ground = 1;
	self.anchor delete();
	self.anchor = spawn( "script_origin", self.origin );
	self.anchor.angles = self.angles;
	self linkto( self.anchor );
	spot.angles = ( 0, 0, 0 );
	anim_org = spot.origin;
	anim_ang = spot.angles;
	anim_org += ( 0, 0, 0 );
	self ghost();
	self.anchor moveto( anim_org, 0.05 );
	self.anchor waittill( "movedone" );
	target_org = get_desired_origin();
	anim_ang = vectortoangles( target_org - self.origin );
	self.anchor rotateto( ( 0, anim_ang[1], 0 ), 0.05 );
	self.anchor waittill( "rotatedone" );
	self unlink();
	self.anchor delete();
	self thread hide_pop();
	level thread zombie_rise_death( self, spot );
	spot thread zombie_rise_fx( self );
	substate = 0;
	substate = randomint( 2 );
	substate = 2;
	substate = 3;
	self orientmode( "face default" );
	self animscripted( self.origin, spot.angles, "zm_rise", substate );
	self maps\mp\animscripts\zm_shared::donotetracks( "rise_anim", ::handle_rise_notetracks, spot );
	self notify( "rise_anim_finished" );
	spot notify( "stop_zombie_rise_fx" );
	self.in_the_ground = 0;
	self notify( "risen", spot.script_string );
// SP = 0x0 - check OK
}

// 0x904C
hide_pop()
{
	self endon( "death" );
	wait 0.5;
	self show();
	wait_network_frame();
	self.create_eyes = 1;
// SP = 0x0 - check OK
}

// 0x9084
handle_rise_notetracks( note, spot )
{
	self.zombie_rise_death_out = 1;
	self notify( "zombie_rise_death_out" );
	wait 2;
	spot notify( "stop_zombie_rise_fx" );
// SP = 0x0 - check OK
}

// 0x90BC
zombie_rise_death( zombie, spot )
{
	zombie.zombie_rise_death_out = 0;
	zombie endon( "rise_anim_finished" );
	zombie waittill( "damage", amount );
	spot notify( "stop_zombie_rise_fx" );
	zombie.deathanim = zombie get_rise_death_anim();
	zombie stopanimscripted();
// SP = 0x0 - check OK
}

// 0x9130
zombie_rise_fx( zombie )
{
	self thread zombie_rise_dust_fx( zombie );
	self thread zombie_rise_burst_fx( zombie );
	self thread zombie_rise_burst_fx( zombie );
	zombie endon( "death" );
	self endon( "stop_zombie_rise_fx" );
	wait 1;
	wait 1;
// SP = 0x0 - check OK
}

// 0x9194
zombie_rise_burst_fx( zombie )
{
	self endon( "stop_zombie_rise_fx" );
	self endon( "rise_anim_finished" );
	zombie setclientfield( "zombie_riser_fx_water", 1 );
	zombie setclientfield( "zombie_riser_fx_foliage", 1 );
	zombie setclientfield( "zombie_riser_fx", 1 );
	low_g_zones = getentarray( zombie.zone_name, "targetname" );
	zombie setclientfield( "zombie_riser_fx_lowg", 1 );
	zombie setclientfield( "zombie_riser_fx", 1 );
	zombie setclientfield( "zombie_riser_fx", 1 );
// SP = 0x0 - check OK
}

// 0x92C8
zombie_rise_dust_fx( zombie )
{
	dust_tag = "J_SpineUpper";
	self endon( "stop_zombie_rise_dust_fx" );
	self thread stop_zombie_rise_dust_fx( zombie );
	wait 2;
	dust_time = 5.5;
	dust_interval = 0.3;
	t = 0;
	playfxontag( level._effect["rise_dust_water"], zombie, dust_tag );
	wait dust_interval;
	t += dust_interval;
	t = 0;
	playfxontag( level._effect["rise_dust_snow"], zombie, dust_tag );
	wait dust_interval;
	t += dust_interval;
	t = 0;
	playfxontag( level._effect["rise_dust_foliage"], zombie, dust_tag );
	wait dust_interval;
	t += dust_interval;
	t = 0;
	playfxontag( level._effect["rise_dust"], zombie, dust_tag );
	wait dust_interval;
	t += dust_interval;
// SP = 0x0 - check OK
}

// 0x9414
stop_zombie_rise_dust_fx( zombie )
{
	zombie waittill( "death" );
	self notify( "stop_zombie_rise_dust_fx" );
// SP = 0x0 - check OK
}

// 0x942C
get_rise_death_anim()
{
	return "zm_rise_death_out";
	self.noragdoll = 1;
	self.nodeathragdoll = 1;
	return "zm_rise_death_in";
// SP = 0x0 - check OK
}

// 0x9454
zombie_tesla_head_gib()
{
	self endon( "death" );
	return;
	wait randomfloatrange( 0.53, 1 );
	self zombie_head_gib();
	network_safe_play_fx_on_tag( "tesla_death_fx", 2, level._effect["tesla_shock_eyes"], self, "J_Eyeball_LE" );
// SP = 0x0 - check OK
}

// 0x94C4
play_ambient_zombie_vocals()
{
	self endon( "death" );
	return;
	type = "ambient";
	float = 2;
	wait 0.5;
	switch ( self.zombie_move_speed )
	{
		case "run":
			type = "ambient";
			float = 4;
			break;
		case "sprint":
			type = "sprint";
			float = 4;
			break;
		case "walk":
			type = "sprint";
			float = 4;
			break;
	}
	type = "crawler";
	float = 1.2;
	self thread maps\mp\zombies\_zm_audio::do_zombies_playvocals( type, self.animname );
	wait randomfloatrange( 1, float );
// SP = 0x0 - check OK
}

// 0x95D4
zombie_complete_emerging_into_playable_area()
{
	self.completed_emerging_into_playable_area = 1;
	self notify( "completed_emerging_into_playable_area" );
	self.no_powerups = 0;
	self thread zombie_free_cam_allowed();
// SP = 0x0 - check OK
}

// 0x95FC
zombie_free_cam_allowed()
{
	self endon( "death" );
	wait 1.5;
	self setfreecameralockonallowed( 1 );
// SP = 0x0 - check OK
}