// maps/mp/gametypes/_globallogic_player.gsc

#include maps\mp\gametypes\_globallogic_vehicle;
#include maps\mp\_burnplayer;
#include maps\mp\gametypes\_deathicons;
#include maps\mp\gametypes\_tweakables;
#include maps\mp\gametypes\_globallogic_audio;
#include maps\mp\gametypes\_killcam;
#include maps\mp\gametypes\_spawnlogic;
#include maps\mp\_medals;
#include maps\mp\killstreaks\_straferun;
#include maps\mp\_challenges;
#include maps\mp\gametypes\_rank;
#include maps\mp\teams\_teams;
#include maps\mp\_demo;
#include maps\mp\gametypes\_weapon_utils;
#include maps\mp\gametypes\_damagefeedback;
#include maps\mp\gametypes\_weapons;
#include maps\mp\_scoreevents;
#include maps\mp\gametypes\_battlechatter_mp;
#include maps\mp\_vehicles;
#include maps\mp\gametypes\_class;
#include maps\mp\gametypes\_hud_message;
#include maps\mp\gametypes\_hud_util;
#include maps\mp\gametypes\_spawning;
#include maps\mp\gametypes\_globallogic_utils;
#include maps\mp\gametypes\_spectating;
#include maps\mp\gametypes\_globallogic_spawn;
#include maps\mp\gametypes\_globallogic_ui;
#include maps\mp\gametypes\_hostmigration;
#include maps\mp\_flashgrenades;
#include maps\mp\gametypes\_globallogic_score;
#include maps\mp\_gamerep;
#include maps\mp\gametypes\_persistence;
#include maps\mp\gametypes\_globallogic;
#include maps\mp\killstreaks\_killstreak_weapons;
#include maps\mp\killstreaks\_killstreaks;
#include common_scripts\utility;
#include maps\mp\_utility;


// 0x398C
freezeplayerforroundend()
{
	self clearlowermessage();
	self closemenu();
	self closeingamemenu();
	self freeze_player_controls( 1 );
	currentweapon = self getcurrentweapon();
	self takeweapon( currentweapon );
// SP = 0x0 - check OK
}

// 0x3A04
callback_playerconnect()
{
	thread notifyconnecting();
	self.statusicon = "hud_status_connecting";
	self waittill( "begin" );
	self [[level.reset_clientdvars]]();
	waittillframeend;
	self.statusicon = "";
	self.guid = self getguid();
	matchrecorderincrementheaderstat( "playerCountJoined", 1 );
	profilelog_begintiming( 4, "ship" );
	level notify( "connected", self );
	self thread maps\mp\gametypes\_globallogic::listenforgameend();
	iprintln( &"MP_CONNECTED", self );
	self thread maps\mp\gametypes\_persistence::adjustrecentstats();
	self maps\mp\gametypes\_persistence::setafteractionreportstat( "valid", 0 );
	self maps\mp\gametypes\_persistence::setafteractionreportstat( "wagerMatchFailed", 1 );
	self maps\mp\gametypes\_persistence::setafteractionreportstat( "wagerMatchFailed", 0 );
	gamemode = maps\mp\gametypes\_globallogic::getcurrentgamemode();
	self maps\mp\gametypes\_globallogic::incrementmatchcompletionstat( gamemode, "played", "started" );
	self maps\mp\gametypes\_globallogic::incrementmatchcompletionstat( gamemode, "hosted", "started" );
	self.pers["matchesHostedStatsTracked"] = 1;
	self.pers["matchesPlayedStatsTracked"] = 1;
	self thread maps\mp\gametypes\_persistence::uploadstatssoon();
	self maps\mp\_gamerep::gamerepplayerconnected();
	lpselfnum = self getentitynumber();
	lpguid = self getguid();
	logprint( "J;" + lpguid + ";" + lpselfnum + ";" + self.name + "\n" );
	bbprint( "mpjoins", "name %s client %s", self.name, lpselfnum );
	self setclientuivisibilityflag( "hud_visible", 1 );
	self.pers["hasRadar"] = 1;
	self.hasspyplane = 1;
	level.activeuavs[self getentitynumber()] = 1;
	self setclientuivisibilityflag( "g_compassShowEnemies", level.forceradar );
	self setclientuivisibilityflag( "g_compassShowEnemies", 0 );
	self setclientplayersprinttime( level.playersprinttime );
	self setclientnumlives( level.numlives );
	makedvarserverinfo( "cg_drawTalk", 1 );
	self setclientdrawtalk( 3 );
	self [[level.player_stats_init]]();
	self maps\mp\gametypes\_globallogic_score::initpersstat( "score" );
	self.pers["score"] = 0;
	self.score = self.pers["score"];
	self maps\mp\gametypes\_globallogic_score::initpersstat( "pointstowin" );
	self.pers["pointstowin"] = 0;
	self.pointstowin = self.pers["pointstowin"];
	self maps\mp\gametypes\_globallogic_score::initpersstat( "momentum", 0 );
	self.momentum = self maps\mp\gametypes\_globallogic_score::getpersstat( "momentum" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "suicides" );
	self.suicides = self maps\mp\gametypes\_globallogic_score::getpersstat( "suicides" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "headshots" );
	self.headshots = self maps\mp\gametypes\_globallogic_score::getpersstat( "headshots" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "challenges" );
	self.challenges = self maps\mp\gametypes\_globallogic_score::getpersstat( "challenges" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "kills" );
	self.kills = self maps\mp\gametypes\_globallogic_score::getpersstat( "kills" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "deaths" );
	self.deaths = self maps\mp\gametypes\_globallogic_score::getpersstat( "deaths" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "assists" );
	self.assists = self maps\mp\gametypes\_globallogic_score::getpersstat( "assists" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "defends", 0 );
	self.defends = self maps\mp\gametypes\_globallogic_score::getpersstat( "defends" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "offends", 0 );
	self.offends = self maps\mp\gametypes\_globallogic_score::getpersstat( "offends" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "plants", 0 );
	self.plants = self maps\mp\gametypes\_globallogic_score::getpersstat( "plants" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "defuses", 0 );
	self.defuses = self maps\mp\gametypes\_globallogic_score::getpersstat( "defuses" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "returns", 0 );
	self.returns = self maps\mp\gametypes\_globallogic_score::getpersstat( "returns" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "captures", 0 );
	self.captures = self maps\mp\gametypes\_globallogic_score::getpersstat( "captures" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "destructions", 0 );
	self.destructions = self maps\mp\gametypes\_globallogic_score::getpersstat( "destructions" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "backstabs", 0 );
	self.backstabs = self maps\mp\gametypes\_globallogic_score::getpersstat( "backstabs" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "longshots", 0 );
	self.longshots = self maps\mp\gametypes\_globallogic_score::getpersstat( "longshots" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "survived", 0 );
	self.survived = self maps\mp\gametypes\_globallogic_score::getpersstat( "survived" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "stabs", 0 );
	self.stabs = self maps\mp\gametypes\_globallogic_score::getpersstat( "stabs" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "tomahawks", 0 );
	self.tomahawks = self maps\mp\gametypes\_globallogic_score::getpersstat( "tomahawks" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "humiliated", 0 );
	self.humiliated = self maps\mp\gametypes\_globallogic_score::getpersstat( "humiliated" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "x2score", 0 );
	self.x2score = self maps\mp\gametypes\_globallogic_score::getpersstat( "x2score" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "agrkills", 0 );
	self.x2score = self maps\mp\gametypes\_globallogic_score::getpersstat( "agrkills" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "hacks", 0 );
	self.x2score = self maps\mp\gametypes\_globallogic_score::getpersstat( "hacks" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "killsconfirmed", 0 );
	self.killsconfirmed = self maps\mp\gametypes\_globallogic_score::getpersstat( "killsconfirmed" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "killsdenied", 0 );
	self.killsdenied = self maps\mp\gametypes\_globallogic_score::getpersstat( "killsdenied" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "sessionbans", 0 );
	self.sessionbans = self maps\mp\gametypes\_globallogic_score::getpersstat( "sessionbans" );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "gametypeban", 0 );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "time_played_total", 0 );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "time_played_alive", 0 );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "teamkills", 0 );
	self maps\mp\gametypes\_globallogic_score::initpersstat( "teamkills_nostats", 0 );
	self.teamkillpunish = 0;
	self thread reduceteamkillsovertime();
	level waittill( "eternity" );
	self.killedplayerscurrent = [];
	self.pers["killed_players"] = [];
	self.pers["killed_by"] = [];
	self.pers["nemesis_tracking"] = [];
	self.pers["artillery_kills"] = 0;
	self.pers["dog_kills"] = 0;
	self.pers["nemesis_name"] = "";
	self.pers["nemesis_rank"] = 0;
	self.pers["nemesis_rankIcon"] = 0;
	self.pers["nemesis_xp"] = 0;
	self.pers["nemesis_xuid"] = "";
	self.pers["best_kill_streak"] = 0;
	self.pers["music"] = spawnstruct();
	self.pers["music"].spawn = 0;
	self.pers["music"].inque = 0;
	self.pers["music"].currentstate = "SILENT";
	self.pers["music"].previousstate = "SILENT";
	self.pers["music"].nextstate = "UNDERSCORE";
	self.pers["music"].returnstate = "UNDERSCORE";
	self.leaderdialogqueue = [];
	self.leaderdialogactive = 0;
	self.leaderdialoggroups = [];
	self.currentleaderdialoggroup = "";
	self.currentleaderdialog = "";
	self.currentleaderdialogtime = 0;
	self.pers["cur_kill_streak"] = 0;
	self.pers["cur_total_kill_streak"] = 0;
	self setplayercurrentstreak( 0 );
	self.pers["totalKillstreakCount"] = 0;
	self.pers["killstreaksEarnedThisKillstreak"] = 0;
	self.pers["killstreak_quantity"] = [];
	self.pers["held_killstreak_ammo_count"] = [];
	self.pers["held_killstreak_clip_count"] = [];
	self.pers["changed_class"] = 0;
	self.lastkilltime = 0;
	self.cur_death_streak = 0;
	self disabledeathstreak();
	self.death_streak = 0;
	self.kill_streak = 0;
	self.gametype_kill_streak = 0;
	self.spawnqueueindex = -1;
	self.deathtime = 0;
	self.death_streak = self getdstat( "HighestStats", "death_streak" );
	self.kill_streak = self getdstat( "HighestStats", "kill_streak" );
	self.gametype_kill_streak = self maps\mp\gametypes\_persistence::statgetwithgametype( "kill_streak" );
	self.lastgrenadesuicidetime = -1;
	self.teamkillsthisround = 0;
	self.pers["lives"] = level.numlives;
	self.pers["team"] = undefined;
	self.hasspawned = 0;
	self.waitingtospawn = 0;
	self.wantsafespawn = 0;
	self.deathcount = 0;
	self.wasaliveatmatchstart = 0;
	self thread maps\mp\_flashgrenades::monitorflash();
	level.players[level.players.size] = self;
	setdvar( "splitscreen_playerNum", level.players.size );
	self.pers["needteam"] = 1;
	self.pers["team"] = "spectator";
	self.team = "spectator";
	self setclientuivisibilityflag( "hud_visible", 0 );
	self [[level.spawnintermission]]();
	self closemenu();
	self closeingamemenu();
	profilelog_endtiming( 4, "gs=" + game["state"] + " zom=" + sessionmodeiszombiesgame() );
	return;
	self recordleaguepreloser();
	maps\mp\gametypes\_globallogic_score::updatelossstats( self );
	self.pers["lossAlreadyReported"] = 1;
	self maps\mp\gametypes\_globallogic_score::backupandclearwinstreaks();
	self.pers["winstreakAlreadyCleared"] = 1;
	self.pers["isBot"] = 1;
	self maps\mp\gametypes\_persistence::setafteractionreportstat( "demoFileID", "0" );
	level endon( "game_ended" );
	self thread maps\mp\gametypes\_hostmigration::hostmigrationtimerthink();
	self.pers["class"] = undefined;
	self.class = self.pers["class"];
	self.team = self.pers["team"];
	self.class = self.pers["class"];
	self.pers["needteam"] = undefined;
	self.pers["team"] = "spectator";
	self.team = "spectator";
	self.sessionstate = "dead";
	self maps\mp\gametypes\_globallogic_ui::updateobjectivetext();
	[[level.spawnspectator]]();
	[[level.autoassign]]( 0 );
	self thread maps\mp\gametypes\_globallogic_spawn::kickifdontspawn();
	self.sessionteam = "spectator";
	self.ffateam = "spectator";
	self thread spectate_player_watcher();
	self.sessionteam = self.pers["team"];
	self.statusicon = "hud_status_dead";
	self thread maps\mp\gametypes\_spectating::setspectatepermissions();
	self setclientscriptmainmenu( game["menu_class"] );
	[[level.spawnspectator]]();
	self.sessionteam = "spectator";
	self.sessionstate = "spectator";
	self.ffateam = "spectator";
	self thread spectate_player_watcher();
	self.sessionteam = self.pers["team"];
	self.sessionstate = "dead";
	self.ffateam = self.pers["team"];
	self maps\mp\gametypes\_globallogic_ui::updateobjectivetext();
	[[level.spawnspectator]]();
	self thread [[level.spawnclient]]();
	self maps\mp\gametypes\_globallogic_ui::showmainmenuforteam();
	self thread maps\mp\gametypes\_spectating::setspectatepermissions();
	self thread maps\mp\gametypes\_spawning::onspawnplayer_unified( 1 );
	profilelog_endtiming( 4, "gs=" + game["state"] + " zom=" + sessionmodeiszombiesgame() );
	return;
// SP = 0x0 - check OK
}

// 0x4888
spectate_player_watcher()
{
	self endon( "disconnect" );
	self maps\mp\gametypes\_hud_util::showperks();
	self thread maps\mp\gametypes\_globallogic_ui::hideloadoutaftertime( 0 );
	self.watchingactiveclient = 1;
	self.waitingforplayerstext = undefined;
	self maps\mp\gametypes\_hud_message::clearshoutcasterwaitingmessage();
	self freezecontrols( 0 );
	self.watchingactiveclient = 0;
	count = 0;
	i = 0;
	count++;
	i++;
	self maps\mp\gametypes\_hud_message::clearshoutcasterwaitingmessage();
	self freezecontrols( 0 );
	self.watchingactiveclient = 1;
	[[level.onspawnspectator]]();
	self freezecontrols( 1 );
	self maps\mp\gametypes\_hud_message::setshoutcasterwaitingmessage();
	self.watchingactiveclient = 0;
	wait 0.5;
// SP = 0x0 - check OK
}

// 0x49E0
callback_playermigrated()
{
/#
	println( "Player " + self.name + " finished migrating at time " + GetTime() );
#/
	self maps\mp\gametypes\_globallogic_ui::updateobjectivetext();
	level.hostmigrationreturnedplayercount++;
/#
	println( "2/3 of players have finished migrating" );
#/
	level notify( "hostmigration_enoughplayers" );
// SP = 0x0 - check OK
}

// 0x4A54
callback_playerdisconnect()
{
	profilelog_begintiming( 5, "ship" );
	gamelength = maps\mp\gametypes\_globallogic::getgamelength();
	self maps\mp\gametypes\_globallogic::bbplayermatchend( gamelength, "MP_PLAYER_DISCONNECT", 0 );
	self removeplayerondisconnect();
	players = level.players;
	level thread maps\mp\gametypes\_globallogic::forceend();
	setdvar( "splitscreen_playerNum", players.size );
	self logstring( "team: score " + self.pers["team"] + ":" + self.score );
	level.dropteam += 1;
	[[level.onplayerdisconnect]]();
	lpselfnum = self getentitynumber();
	lpguid = self getguid();
	logprint( "Q;" + lpguid + ";" + lpselfnum + ";" + self.name + "\n" );
	self maps\mp\_gamerep::gamerepplayerdisconnected();
	entry = 0;
	level.players[entry] = level.players[entry + 1];
	entry++;
	level.players[entry] = undefined;
	entry++;
	entry = 0;
	level.players[entry].pers["killed_players"][self.name] = undefined;
	level.players[entry].killedplayerscurrent[self.name] = undefined;
	level.players[entry].pers["killed_by"][self.name] = undefined;
	level.players[entry].pers["nemesis_tracking"][self.name] = undefined;
	level.players[entry] choosenextbestnemesis();
	entry++;
	self maps\mp\gametypes\_globallogic::removedisconnectedplayerfromplacement();
	level thread maps\mp\gametypes\_globallogic::updateteamstatus();
	profilelog_endtiming( 5, "gs=" + game["state"] + " zom=" + sessionmodeiszombiesgame() );
// SP = 0x0 - check OK
}

// 0x4D10
callback_playermelee( eattacker, idamage, sweapon, vorigin, vdir, boneindex, shieldhit )
{
	hit = 1;
	hit = 0;
	self finishmeleehit( eattacker, sweapon, vorigin, vdir, boneindex, shieldhit, hit );
// SP = 0x0 - check OK
}

// 0x4D6C
choosenextbestnemesis()
{
	nemesisarray = self.pers["nemesis_tracking"];
	nemesisarraykeys = getarraykeys( nemesisarray );
	nemesisamount = 0;
	nemesisname = "";
	i = 0;
	nemesisarraykey = nemesisarraykeys[i];
	nemesisname = nemesisarraykey;
	nemesisamount = nemesisarray[nemesisarraykey];
	i++;
	self.pers["nemesis_name"] = nemesisname;
	playerindex = 0;
	nemesisplayer = level.players[playerindex];
	self.pers["nemesis_rank"] = nemesisplayer.pers["rank"];
	self.pers["nemesis_rankIcon"] = nemesisplayer.pers["rankxp"];
	self.pers["nemesis_xp"] = nemesisplayer.pers["prestige"];
	self.pers["nemesis_xuid"] = nemesisplayer getxuid( 1 );
	playerindex++;
	self.pers["nemesis_xuid"] = "";
// SP = 0x0 - check OK
}

// 0x4E98
removeplayerondisconnect()
{
	entry = 0;
	level.players[entry] = level.players[entry + 1];
	entry++;
	level.players[entry] = undefined;
	entry++;
// SP = 0x0 - check OK
}

// 0x4EF8
custom_gamemodes_modified_damage( victim, eattacker, idamage, smeansofdeath, sweapon, einflictor, shitloc )
{
	return idamage;
	idamage *= eattacker.damagemodifier;
	idamage = int( idamage * level.bulletdamagescalar );
	return idamage;
// SP = 0x0 - check OK
}

// 0x4F6C
figureoutattacker( eattacker )
{
	team = self.team;
	team = self.aiteam;
	eattacker = eattacker.script_owner;
	eattacker = eattacker.owner;
	eattacker = eattacker.owner;
	return eattacker;
// SP = 0x0 - check OK
}

// 0x5020
figureoutweapon( sweapon, einflictor )
{
	sweapon = "explodable_barrel_mp";
	sweapon = "destructible_car_mp";
	return sweapon;
// SP = 0x0 - check OK
}

// 0x5088
isplayerimmunetokillstreak( eattacker, sweapon )
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x50C8
callback_playerdamage( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime, boneindex )
{
	profilelog_begintiming( 6, "ship" );
	return;
	return;
	return;
	return;
	return;
	return;
	return;
	return;
	self notify( "emp_grenaded", eattacker );
	idamage = maps\mp\gametypes\_class::cac_modified_damage( self, eattacker, idamage, smeansofdeath, sweapon, einflictor, shitloc );
	idamage = custom_gamemodes_modified_damage( self, eattacker, idamage, smeansofdeath, sweapon, einflictor, shitloc );
	idamage = int( idamage );
	self.idflags = idflags;
	self.idflagstime = GetTime();
	eattacker = figureoutattacker( eattacker );
	pixbeginevent( "PlayerDamage flags/tweaks" );
	idflags |= level.idflags_no_knockback;
	friendly = 0;
	self notify( "snd_pain_player" );
	smeansofdeath = "MOD_FALLING";
	sweapon = [[level.overrideweaponfunc]]( sweapon, einflictor.script_noteworthy );
	smeansofdeath = "MOD_HEAD_SHOT";
	modifieddamage = [[level.onplayerdamage]]( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime );
	return;
	idamage = modifieddamage;
	return;
	idamage = 150;
	return;
	self.lastattackweapon = sweapon;
	sweapon = figureoutweapon( sweapon, einflictor );
	pixendevent();
	self thread maps\mp\gametypes\_battlechatter_mp::perkspecificbattlechatter( "deepimpact", 1 );
	attackerishittingteammate = self isenemyplayer( eattacker ) == 0;
	return;
	eattacker.lastattackedshieldplayer = self;
	eattacker.lastattackedshieldtime = GetTime();
	previous_shield_damage = self.shielddamageblocked;
	self.shielddamageblocked += idamage;
	score_event = "shield_blocked_damage";
	score_event = "shield_blocked_damage_reduced";
	self addweaponstat( "riotshield_mp", "score_from_blocked_damage", level.scoreinfo[score_event]["value"] );
	thread maps\mp\_scoreevents::processscoreevent( score_event, self );
	shitloc = "none";
	idamage *= 0;
	idamage = 101;
	shitloc = "none";
	return;
	return;
	return;
	self.explosiveinfo = [];
	self.explosiveinfo["damageTime"] = GetTime();
	self.explosiveinfo["damageId"] = einflictor getentitynumber();
	self.explosiveinfo["originalOwnerKill"] = 0;
	self.explosiveinfo["bulletPenetrationKill"] = 0;
	self.explosiveinfo["chainKill"] = 0;
	self.explosiveinfo["damageExplosiveKill"] = 0;
	self.explosiveinfo["chainKill"] = 0;
	self.explosiveinfo["cookedKill"] = 0;
	self.explosiveinfo["weapon"] = sweapon;
	self.explosiveinfo["originalowner"] = einflictor.originalowner;
	isfrag = sweapon == "frag_grenade_mp";
	self.explosiveinfo["originalOwnerKill"] = einflictor.owner == self;
	self.explosiveinfo["damageExplosiveKill"] = IsDefined( einflictor.wasdamaged );
	self.explosiveinfo["chainKill"] = IsDefined( einflictor.waschained );
	self.explosiveinfo["wasJustPlanted"] = IsDefined( einflictor.wasjustplanted );
	self.explosiveinfo["bulletPenetrationKill"] = IsDefined( einflictor.wasdamagedfrombulletpenetration );
	self.explosiveinfo["cookedKill"] = 0;
	self.explosiveinfo["stuckToPlayer"] = einflictor.stucktoplayer;
	self.laststunnedby = eattacker;
	self.laststunnedtime = self.idflagstime;
	self.explosiveinfo["suicideGrenadeKill"] = 1;
	self.explosiveinfo["suicideGrenadeKill"] = 0;
	self.explosiveinfo["cookedKill"] = IsDefined( einflictor.iscooked );
	self.explosiveinfo["throwbackKill"] = IsDefined( einflictor.threwback );
	self maps\mp\gametypes\_globallogic_score::setinflictorstat( einflictor, eattacker, sweapon );
	self maps\mp\gametypes\_globallogic_score::setinflictorstat( einflictor, eattacker, sweapon );
	self.explosiveinfo["projectile_bounced"] = IsDefined( einflictor.bounced );
	eattacker.pers["participation"]++;
	prevhealthratio = self.health / self.maxhealth;
	pixmarker( "BEGIN: PlayerDamage player" );
	self damageshellshockandrumble( eattacker, einflictor, sweapon, smeansofdeath, idamage );
	return;
	idamage = 1;
	eattacker.lastdamagewasfromenemy = 0;
	eattacker.friendlydamage = 1;
	eattacker finishplayerdamagewrapper( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime, boneindex );
	eattacker.friendlydamage = undefined;
	self.lastdamagewasfromenemy = 0;
	self finishplayerdamagewrapper( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime, boneindex );
	idamage = int( idamage * 0.5 );
	idamage = 1;
	eattacker.lastdamagewasfromenemy = 0;
	eattacker.friendlydamage = 1;
	eattacker finishplayerdamagewrapper( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime, boneindex );
	eattacker.friendlydamage = undefined;
	idamage = int( idamage * 0.5 );
	idamage = 1;
	self.lastdamagewasfromenemy = 0;
	eattacker.lastdamagewasfromenemy = 0;
	self finishplayerdamagewrapper( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime, boneindex );
	eattacker.friendlydamage = 1;
	eattacker finishplayerdamagewrapper( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime, boneindex );
	eattacker.friendlydamage = undefined;
	friendly = 1;
	pixmarker( "END: PlayerDamage player" );
	idamage = 1;
	self trackattackerdamage( eattacker, idamage, smeansofdeath, sweapon );
	giveinflictorownerassist( eattacker, einflictor, idamage, smeansofdeath, sweapon );
	level.lastlegitimateattacker = eattacker;
	eattacker thread maps\mp\gametypes\_weapons::checkhit( sweapon );
	self.wascooked = GetTime();
	self.wascooked = undefined;
	self.lastdamagewasfromenemy = eattacker != self;
	eattacker.damagedplayers[self.clientid] = spawnstruct();
	eattacker.damagedplayers[self.clientid].time = GetTime();
	eattacker.damagedplayers[self.clientid].entity = self;
	self finishplayerdamagewrapper( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime, boneindex );
	perkfeedback = doperkfeedback( self, sweapon, smeansofdeath, einflictor );
	eattacker thread maps\mp\gametypes\_damagefeedback::updatedamagefeedback( smeansofdeath, einflictor, perkfeedback );
	self.hasdonecombat = 1;
	level.usestartspawns = 0;
	pixbeginevent( "PlayerDamage log" );
/#
	println( "client:" + self getentitynumber() + " health:" + self.health + " attacker:" + eattacker.clientid + " inflictor is player:" + isplayer( einflictor ) + " damage:" + idamage + " hitLoc:" + shitloc );
#/
	lpselfnum = self getentitynumber();
	lpselfname = self.name;
	lpselfteam = self.team;
	lpselfguid = self getguid();
	lpattackerteam = "";
	lpattackerorigin = ( 0, 0, 0 );
	lpattacknum = eattacker getentitynumber();
	lpattackguid = eattacker getguid();
	lpattackname = eattacker.name;
	lpattackerteam = eattacker.team;
	lpattackerorigin = eattacker.origin;
	bbprint( "mpattacks", "gametime %d attackerspawnid %d attackerweapon %s attackerx %d attackery %d attackerz %d victimspawnid %d victimx %d victimy %d victimz %d damage %d damagetype %s damagelocation %s death %d", GetTime(), getplayerspawnid( eattacker ), sweapon, lpattackerorigin, getplayerspawnid( self ), self.origin, idamage, smeansofdeath, shitloc, 0 );
	lpattacknum = -1;
	lpattackguid = "";
	lpattackname = "";
	lpattackerteam = "world";
	bbprint( "mpattacks", "gametime %d attackerweapon %s victimspawnid %d victimx %d victimy %d victimz %d damage %d damagetype %s damagelocation %s death %d", GetTime(), sweapon, getplayerspawnid( self ), self.origin, idamage, smeansofdeath, shitloc, 0 );
	logprint( "D;" + lpselfguid + ";" + lpselfnum + ";" + lpselfteam + ";" + lpselfname + ";" + lpattackguid + ";" + lpattacknum + ";" + lpattackerteam + ";" + lpattackname + ";" + sweapon + ";" + idamage + ";" + smeansofdeath + ";" + shitloc + "\n" );
	pixendevent();
	profilelog_endtiming( 6, "gs=" + game["state"] + " zom=" + sessionmodeiszombiesgame() );
// SP = 0x0 - check OK
}

// 0x5EB4
resetattackerlist()
{
	self.attackers = [];
	self.attackerdata = [];
	self.attackerdamage = [];
	self.firsttimedamaged = 0;
// SP = 0x0 - check OK
}

// 0x5ED4
dodamagefeedback( sweapon, einflictor, idamage, smeansofdeath )
{
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x5F28
istacticalhitmarker( sweapon, smeansofdeath, idamage )
{
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x5F6C
doperkfeedback( player, sweapon, smeansofdeath, einflictor )
{
	perkfeedback = undefined;
	hastacticalmask = maps\mp\gametypes\_class::hastacticalmask( player );
	hasflakjacket = player hasperk( "specialty_flakjacket" );
	isexplosivedamage = maps\mp\gametypes\_class::isexplosivedamage( sweapon, smeansofdeath );
	isflashorstundamage = maps\mp\gametypes\_weapon_utils::isflashorstundamage( sweapon, smeansofdeath );
	perkfeedback = "tacticalMask";
	perkfeedback = "flakjacket";
	return perkfeedback;
// SP = 0x0 - check OK
}

// 0x6004
isaikillstreakdamage( sweapon, einflictor )
{
	switch ( sweapon )
	{
		case "ai_tank_drone_rocket_mp":
			return IsDefined( einflictor.firedbyai );
		case "chopper_minigun_mp":
			return 1;
		case "cobra_20mm_comlink_mp":
			return 1;
		case "littlebird_guard_minigun_mp":
			return 1;
		case "missile_swarm_projectile_mp":
			return 1;
		case "planemortar_mp":
			return 1;
		case "straferun_rockets_mp":
			return 1;
	}
	return 0;
// SP = 0x0 - check OK
}

// 0x6074
finishplayerdamagewrapper( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime, boneindex )
{
	pixbeginevent( "finishPlayerDamageWrapper" );
/#
	println( "penetrated:" + self getentitynumber() + " health:" + self.health + " attacker:" + eattacker.clientid + " inflictor is player:" + isplayer( einflictor ) + " damage:" + idamage + " hitLoc:" + shitloc );
#/
	eattacker addplayerstat( "penetration_shots", 1 );
	self finishplayerdamage( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime, boneindex );
	self shellshock( "damage_mp", 0.2 );
	self damageshellshockandrumble( eattacker, einflictor, sweapon, smeansofdeath, idamage );
	pixendevent();
// SP = 0x0 - check OK
}

// 0x6180
allowedassistweapon( weapon )
{
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x61B0
playerkilled_killstreaks( attacker, sweapon )
{
	self.pers["cur_kill_streak"] = 0;
	self.pers["cur_total_kill_streak"] = 0;
	self.pers["totalKillstreakCount"] = 0;
	self.pers["killstreaksEarnedThisKillstreak"] = 0;
	self setplayercurrentstreak( 0 );
	self maps\mp\gametypes\_globallogic_score::incpersstat( "deaths", 1, 1, 1 );
	self.deaths = self maps\mp\gametypes\_globallogic_score::getpersstat( "deaths" );
	self updatestatratio( "kdratio", "kills", "deaths" );
	self.pers["best_kill_streak"] = self.pers["cur_kill_streak"];
	self.pers["kill_streak_before_death"] = self.pers["cur_kill_streak"];
	self.pers["cur_kill_streak"] = 0;
	self.pers["cur_total_kill_streak"] = 0;
	self.pers["totalKillstreakCount"] = 0;
	self.pers["killstreaksEarnedThisKillstreak"] = 0;
	self setplayercurrentstreak( 0 );
	self.cur_death_streak++;
	self setdstat( "HighestStats", "death_streak", self.cur_death_streak );
	self.death_streak = self.cur_death_streak;
	self enabledeathstreak();
	self.pers["totalKillstreakCount"] = 0;
	self.pers["killstreaksEarnedThisKillstreak"] = 0;
	level.globalkillstreaksdeathsfrom++;
// SP = 0x0 - check OK
}

// 0x6370
playerkilled_weaponstats( attacker, sweapon, smeansofdeath, wasinlaststand, lastweaponbeforedroppingintolaststand, inflictor )
{
	self addweaponstat( sweapon, "deaths", 1 );
	weaponname = lastweaponbeforedroppingintolaststand;
	weaponname = self.lastdroppableweapon;
	self addweaponstat( weaponname, "deathsDuringUse", 1 );
	attacker addweaponstat( inflictor.ownerweaponatlaunch, "kills", 1, attacker.class_num, 1 );
	attacker addweaponstat( sweapon, "kills", 1, attacker.class_num );
	attacker addweaponstat( sweapon, "headshots", 1 );
	attacker addweaponstat( sweapon, "direct_hit_kills", 1 );
// SP = 0x0 - check OK
}

// 0x64A4
playerkilled_obituary( attacker, einflictor, sweapon, smeansofdeath )
{
	level notify( "reset_obituary_count" );
	level.lastobituaryplayercount = 0;
	level.lastobituaryplayer = undefined;
	level.lastobituaryplayercount++;
	level notify( "reset_obituary_count" );
	level.lastobituaryplayer = attacker;
	level.lastobituaryplayercount = 1;
	level thread maps\mp\_scoreevents::decrementlastobituaryplayercountafterfade();
	level notify( "reset_obituary_count" );
	level.lastobituaryplayercount = 0;
	level.lastobituaryplayer = undefined;
	self thread uninterruptedobitfeedkills( attacker, sweapon );
	overrideentitycamera = maps\mp\killstreaks\_killstreaks::shouldoverrideentitycameraindemo( attacker, sweapon );
	obituary( self, self, sweapon, smeansofdeath );
	maps\mp\_demo::bookmark( "kill", GetTime(), self, self, 0, einflictor, overrideentitycamera );
	obituary( self, attacker, sweapon, smeansofdeath );
	maps\mp\_demo::bookmark( "kill", GetTime(), self, attacker, 0, einflictor, overrideentitycamera );
// SP = 0x0 - check OK
}

// 0x65FC
playerkilled_suicide( einflictor, attacker, smeansofdeath, sweapon, shitloc )
{
	awardassists = 0;
	playercounts = self maps\mp\teams\_teams::countplayers();
	playercounts[self.leaving_team]--;
	playercounts[self.joining_team]++;
	thread maps\mp\_scoreevents::processscoreevent( "suicide", self );
	self thread maps\mp\gametypes\_rank::giverankxp( "suicide" );
	self maps\mp\gametypes\_globallogic_score::incpersstat( "suicides", 1 );
	self.suicides = self maps\mp\gametypes\_globallogic_score::getpersstat( "suicides" );
	thread maps\mp\_scoreevents::processscoreevent( "suicide", self );
	self maps\mp\gametypes\_globallogic_score::incpersstat( "suicides", 1 );
	self.suicides = self maps\mp\gametypes\_globallogic_score::getpersstat( "suicides" );
	self.lastgrenadesuicidetime = GetTime();
	self notify( "teamKillKicked" );
	self suicidekick();
	thread maps\mp\gametypes\_battlechatter_mp::onplayersuicideorteamkill( self, "suicide" );
	awardassists = 1;
	self.suicide = 1;
	self iprintln( &"MP_FRIENDLY_FIRE_WILL_NOT" );
	scoresub = self [[level.getteamkillscore]]( einflictor, attacker, smeansofdeath, sweapon );
	score = maps\mp\gametypes\_globallogic_score::_getplayerscore( attacker ) - scoresub;
	score = 0;
	maps\mp\gametypes\_globallogic_score::_setplayerscore( attacker, score );
	return awardassists;
// SP = 0x0 - check OK
}

// 0x67CC
playerkilled_teamkill( einflictor, attacker, smeansofdeath, sweapon, shitloc )
{
	thread maps\mp\_scoreevents::processscoreevent( "team_kill", attacker );
	self.teamkilled = 1;
	teamkill_penalty = self [[level.getteamkillpenalty]]( einflictor, attacker, smeansofdeath, sweapon );
	attacker maps\mp\gametypes\_globallogic_score::incpersstat( "teamkills_nostats", teamkill_penalty, 0 );
	attacker maps\mp\gametypes\_globallogic_score::incpersstat( "teamkills", 1 );
	attacker.teamkillsthisround++;
	scoresub = self [[level.getteamkillscore]]( einflictor, attacker, smeansofdeath, sweapon );
	score = maps\mp\gametypes\_globallogic_score::_getplayerscore( attacker ) - scoresub;
	score = 0;
	maps\mp\gametypes\_globallogic_score::_setplayerscore( attacker, score );
	teamkilldelay = 1;
	teamkilldelay = 1;
	teamkilldelay = attacker teamkilldelay();
	attacker.teamkillpunish = 1;
	attacker thread wait_and_suicide();
	attacker notify( "teamKillKicked" );
	attacker teamkillkick();
	attacker thread reduceteamkillsovertime();
	thread maps\mp\gametypes\_battlechatter_mp::onplayersuicideorteamkill( attacker, "teamkill" );
// SP = 0x0 - check OK
}

// 0x6954
wait_and_suicide()
{
	self endon( "disconnect" );
	self freezecontrolswrapper( 1 );
	wait 0.25;
	self suicide();
// SP = 0x0 - check OK
}

// 0x6980
playerkilled_awardassists( einflictor, attacker, sweapon, lpattackteam )
{
	pixbeginevent( "PlayerKilled assists" );
	j = 0;
	player = self.attackers[j];
	damage_done = self.attackerdamage[player.clientid].damage;
	player thread maps\mp\gametypes\_globallogic_score::processassist( self, damage_done, self.attackerdamage[player.clientid].weapon );
	j++;
	self maps\mp\gametypes\_globallogic_score::processkillstreakassists( attacker, einflictor, sweapon );
	self.lastattackedshieldplayer thread maps\mp\gametypes\_globallogic_score::processshieldassist( self );
	pixendevent();
// SP = 0x0 - check OK
}

// 0x6A80
playerkilled_kill( einflictor, attacker, smeansofdeath, sweapon, shitloc )
{
	maps\mp\gametypes\_globallogic_score::inctotalkills( attacker.team );
	attacker thread maps\mp\gametypes\_globallogic_score::givekillstats( smeansofdeath, sweapon, self );
	pixbeginevent( "killstreak" );
	shouldgivekillstreak = maps\mp\killstreaks\_killstreaks::shouldgivekillstreak( sweapon );
	attacker maps\mp\killstreaks\_killstreaks::addtokillstreakcount( sweapon );
	attacker.pers["cur_total_kill_streak"]++;
	attacker setplayercurrentstreak( attacker.pers["cur_total_kill_streak"] );
	attacker.pers["cur_kill_streak"]++;
	attacker maps\mp\_challenges::killstreakten();
	maps\mp\_scoreevents::processscoreevent( "killstreak_" + attacker.pers["cur_kill_streak"], attacker, self, sweapon );
	maps\mp\_scoreevents::processscoreevent( "killstreak_more_than_30", attacker, self, sweapon );
	attacker thread maps\mp\killstreaks\_killstreaks::givekillstreakforstreak();
	self thread maps\mp\gametypes\_battlechatter_mp::onplayerkillstreak( attacker );
	pixendevent();
	attacker setdstat( "HighestStats", "kill_streak", attacker.pers["totalKillstreakCount"] );
	attacker.kill_streak = attacker.pers["cur_kill_streak"];
	attacker maps\mp\gametypes\_persistence::statsetwithgametype( "kill_streak", attacker.pers["cur_kill_streak"] );
	attacker.gametype_kill_streak = attacker.pers["cur_kill_streak"];
	killstreak = maps\mp\killstreaks\_killstreaks::getkillstreakforweapon( sweapon );
	maps\mp\_scoreevents::processscoreevent( killstreak, attacker, self, sweapon );
	attacker maps\mp\killstreaks\_straferun::addstraferunkill();
	maps\mp\_scoreevents::processscoreevent( "kill", attacker, self, sweapon );
	maps\mp\_scoreevents::processscoreevent( "headshot", attacker, self, sweapon );
	maps\mp\_scoreevents::processscoreevent( "melee_kill_with_riot_shield", attacker, self, sweapon );
	primaryweaponnum = attacker getloadoutitem( attacker.class_num, "primary" );
	secondaryweaponnum = attacker getloadoutitem( attacker.class_num, "secondary" );
	attacker addweaponstat( sweapon, "NoLethalKills", 1 );
	maps\mp\_scoreevents::processscoreevent( "melee_kill", attacker, self, sweapon );
	attacker thread maps\mp\gametypes\_globallogic_score::trackattackerkill( self.name, self.pers["rank"], self.pers["rankxp"], self.pers["prestige"], self getxuid( 1 ) );
	attackername = attacker.name;
	self thread maps\mp\gametypes\_globallogic_score::trackattackeedeath( attackername, attacker.pers["rank"], attacker.pers["rankxp"], attacker.pers["prestige"], attacker getxuid( 1 ) );
	self thread maps\mp\_medals::setlastkilledby( attacker );
	attacker thread maps\mp\gametypes\_globallogic_score::inckillstreaktracker( sweapon );
	maps\mp\gametypes\_globallogic_score::giveteamscore( "kill", attacker.aiteam, attacker, self );
	maps\mp\gametypes\_globallogic_score::giveteamscore( "kill", attacker.team, attacker, self );
	scoresub = level.deathpointloss;
	maps\mp\gametypes\_globallogic_score::_setplayerscore( self, maps\mp\gametypes\_globallogic_score::_getplayerscore( self ) - scoresub );
	level thread playkillbattlechatter( attacker, sweapon, self );
// SP = 0x0 - check OK
}

// 0x6F24
callback_playerkilled( einflictor, attacker, idamage, smeansofdeath, sweapon, vdir, shitloc, psoffsettime, deathanimduration )
{
	profilelog_begintiming( 7, "ship" );
	self endon( "spawned" );
	self notify( "killed_player" );
	return;
	return;
	self needsrevive( 0 );
	self setburn( 0 );
	self.suicide = 0;
	self.teamkilled = 0;
	self.pers["lives"]--;
	level notify( "player_eliminated" );
	self notify( "player_eliminated" );
	self thread flushgroupdialogonplayer( "item_destroyed" );
	sweapon = updateweapon( einflictor, sweapon );
	pixbeginevent( "PlayerKilled pre constants" );
	wasinlaststand = 0;
	deathtimeoffset = 0;
	lastweaponbeforedroppingintolaststand = undefined;
	attackerstance = undefined;
	self.laststandthislife = undefined;
	self.vattackerorigin = undefined;
	self.uselaststandparams = undefined;
/#
	assert( IsDefined( self.laststandparams ) );
#/
	einflictor = self.laststandparams.einflictor;
	attacker = self.laststandparams.attacker;
	attackerstance = self.laststandparams.attackerstance;
	idamage = self.laststandparams.idamage;
	smeansofdeath = self.laststandparams.smeansofdeath;
	sweapon = self.laststandparams.sweapon;
	vdir = self.laststandparams.vdir;
	shitloc = self.laststandparams.shitloc;
	self.vattackerorigin = self.laststandparams.vattackerorigin;
	deathtimeoffset = ( GetTime() - self.laststandparams.laststandstarttime ) / 1000;
	self thread maps\mp\gametypes\_battlechatter_mp::perkspecificbattlechatter( "secondchance" );
	wasinlaststand = 1;
	lastweaponbeforedroppingintolaststand = self.previousprimary;
	self.laststandparams = undefined;
	bestplayer = undefined;
	bestplayermeansofdeath = undefined;
	obituarymeansofdeath = undefined;
	bestplayerweapon = undefined;
	obituaryweapon = sweapon;
	assistedsuicide = 0;
	i = 0;
	player = self.attackers[i];
	bestplayer = player;
	bestplayermeansofdeath = self.attackerdamage[player.clientid].meansofdeath;
	bestplayerweapon = self.attackerdamage[player.clientid].weapon;
	bestplayer = player;
	bestplayermeansofdeath = self.attackerdamage[player.clientid].meansofdeath;
	bestplayerweapon = self.attackerdamage[player.clientid].weapon;
	i++;
	maps\mp\_scoreevents::processscoreevent( "assisted_suicide", bestplayer, self, sweapon );
	self recordkillmodifier( "assistedsuicide" );
	assistedsuicide = 1;
	attacker = bestplayer;
	obituarymeansofdeath = bestplayermeansofdeath;
	obituaryweapon = bestplayerweapon;
	sweapon = bestplayerweapon;
	attacker.damagedplayers[self.clientid] = undefined;
	self.deathtime = GetTime();
	attacker = updateattacker( attacker, sweapon );
	einflictor = updateinflictor( einflictor );
	smeansofdeath = self playerkilled_updatemeansofdeath( attacker, einflictor, sweapon, smeansofdeath, shitloc );
	obituarymeansofdeath = smeansofdeath;
	self detachshieldmodel( level.carriedshieldmodel, "tag_weapon_left" );
	self.hasriotshield = 0;
	self.hasriotshieldequipped = 0;
	self thread updateglobalbotkilledcounter();
	self playerkilled_weaponstats( attacker, sweapon, smeansofdeath, wasinlaststand, lastweaponbeforedroppingintolaststand, einflictor );
	self playerkilled_obituary( attacker, einflictor, obituaryweapon, obituarymeansofdeath );
	maps\mp\gametypes\_spawnlogic::deathoccured( self, attacker );
	self.sessionstate = "dead";
	self.statusicon = "hud_status_dead";
	self.pers["weapon"] = undefined;
	self.killedplayerscurrent = [];
	self.deathcount++;
/#
	println( "players(" + self.clientid + ") death count ++: " + self.deathcount );
#/
	self playerkilled_killstreaks( attacker, sweapon );
	lpselfnum = self getentitynumber();
	lpselfname = self.name;
	lpattackguid = "";
	lpattackname = "";
	lpselfteam = self.team;
	lpselfguid = self getguid();
	lpattackteam = "";
	lpattackorigin = ( 0, 0, 0 );
	lpattacknum = -1;
	awardassists = 0;
	wasteamkill = 0;
	wassuicide = 0;
	pixendevent();
	maps\mp\_scoreevents::processscoreevent( "death", self, self, sweapon );
	self.pers["resetMomentumOnSpawn"] = 1;
	lpattackguid = attacker getguid();
	lpattackname = attacker.name;
	lpattackteam = attacker.team;
	lpattackorigin = attacker.origin;
	dokillcam = 0;
	wassuicide = 1;
	awardassists = self playerkilled_suicide( einflictor, attacker, smeansofdeath, sweapon, shitloc );
	pixbeginevent( "PlayerKilled attacker" );
	lpattacknum = attacker getentitynumber();
	dokillcam = 1;
	wasteamkill = 1;
	self playerkilled_teamkill( einflictor, attacker, smeansofdeath, sweapon, shitloc );
	self playerkilled_kill( einflictor, attacker, smeansofdeath, sweapon, shitloc );
	awardassists = 1;
	pixendevent();
	dokillcam = 0;
	lpattacknum = -1;
	lpattackguid = "";
	lpattackname = "";
	lpattackteam = "world";
	thread maps\mp\_scoreevents::processscoreevent( "suicide", self );
	self maps\mp\gametypes\_globallogic_score::incpersstat( "suicides", 1 );
	self.suicides = self maps\mp\gametypes\_globallogic_score::getpersstat( "suicides" );
	self.suicide = 1;
	thread maps\mp\gametypes\_battlechatter_mp::onplayersuicideorteamkill( self, "suicide" );
	awardassists = 1;
	self notify( "teamKillKicked" );
	self suicidekick();
	dokillcam = 0;
	lpattacknum = -1;
	lpattackguid = "";
	lpattackname = "";
	lpattackteam = "world";
	wassuicide = 1;
	dokillcam = 1;
	lpattacknum = self getentitynumber();
	wassuicide = 0;
	maps\mp\gametypes\_globallogic_score::giveteamscore( "kill", attacker.team, attacker, self );
	wassuicide = 0;
	awardassists = 1;
	self maps\mp\gametypes\_weapons::dropscavengerfordeath( attacker );
	self maps\mp\gametypes\_weapons::dropweaponfordeath( attacker, sweapon, smeansofdeath );
	self maps\mp\gametypes\_weapons::dropoffhand();
	awardassists = 0;
	self playerkilled_awardassists( einflictor, attacker, sweapon, lpattackteam );
	pixbeginevent( "PlayerKilled post constants" );
	self.lastattacker = attacker;
	self.lastdeathpos = self.origin;
	self thread maps\mp\_challenges::playerkilled( einflictor, attacker, idamage, smeansofdeath, sweapon, shitloc, attackerstance );
	self notify( "playerKilledChallengesProcessed" );
	self.attackers = [];
	killstreak = maps\mp\killstreaks\_killstreaks::getkillstreakforweapon( sweapon );
	bbprint( "mpattacks", "gametime %d attackerspawnid %d attackerweapon %s attackerx %d attackery %d attackerz %d victimspawnid %d victimx %d victimy %d victimz %d damage %d damagetype %s damagelocation %s death %d killstreak %s", GetTime(), getplayerspawnid( attacker ), sweapon, lpattackorigin, getplayerspawnid( self ), self.origin, idamage, smeansofdeath, shitloc, 1, killstreak );
	bbprint( "mpattacks", "gametime %d attackerspawnid %d attackerweapon %s attackerx %d attackery %d attackerz %d victimspawnid %d victimx %d victimy %d victimz %d damage %d damagetype %s damagelocation %s death %d", GetTime(), getplayerspawnid( attacker ), sweapon, lpattackorigin, getplayerspawnid( self ), self.origin, idamage, smeansofdeath, shitloc, 1 );
	bbprint( "mpattacks", "gametime %d attackerweapon %s victimspawnid %d victimx %d victimy %d victimz %d damage %d damagetype %s damagelocation %s death %d", GetTime(), sweapon, getplayerspawnid( self ), self.origin, idamage, smeansofdeath, shitloc, 1 );
	logprint( "K;" + lpselfguid + ";" + lpselfnum + ";" + lpselfteam + ";" + lpselfname + ";" + lpattackguid + ";" + lpattacknum + ";" + lpattackteam + ";" + lpattackname + ";" + sweapon + ";" + idamage + ";" + smeansofdeath + ";" + shitloc + "\n" );
	attackerstring = "none";
	attackerstring = attacker getxuid() + "(" + lpattackname + ")";
	self logstring( "d " + smeansofdeath + "(" + sweapon + ") a:" + attackerstring + " d:" + idamage + " l:" + shitloc + " @ " + int( self.origin[0] ) + " " + int( self.origin[1] ) + " " + int( self.origin[2] ) );
	level thread maps\mp\gametypes\_globallogic::updateteamstatus();
	killcamentity = self getkillcamentity( attacker, einflictor, sweapon );
	killcamentityindex = -1;
	killcamentitystarttime = 0;
	killcamentityindex = killcamentity getentitynumber();
	killcamentitystarttime = killcamentity.starttime;
	killcamentitystarttime = killcamentity.birthtime;
	killcamentitystarttime = 0;
	dokillcam = 0;
	self maps\mp\gametypes\_weapons::detachcarryobjectmodel();
	died_in_vehicle = 0;
	died_in_vehicle = self.diedonvehicle;
	hit_by_train = 0;
	hit_by_train = 1;
	pixendevent();
	pixbeginevent( "PlayerKilled body and gibbing" );
	vattackerorigin = undefined;
	vattackerorigin = attacker.origin;
	ragdoll_now = 0;
	ragdoll_now = 1;
	body = self cloneplayer( deathanimduration );
	self createdeadbody( idamage, smeansofdeath, sweapon, shitloc, vdir, vattackerorigin, deathanimduration, einflictor, ragdoll_now, body );
	pixendevent();
	thread maps\mp\gametypes\_globallogic_spawn::spawnqueuedclient( self.team, attacker );
	self.switching_teams = undefined;
	self.joining_team = undefined;
	self.leaving_team = undefined;
	self thread [[level.onplayerkilled]]( einflictor, attacker, idamage, smeansofdeath, sweapon, vdir, shitloc, psoffsettime, deathanimduration );
	icb = 0;
	self [[level.onplayerkilledextraunthreadedcbs[icb]]]( einflictor, attacker, idamage, smeansofdeath, sweapon, vdir, shitloc, psoffsettime, deathanimduration );
	icb++;
	self.wantsafespawn = 0;
	perks = [];
	killstreaks = maps\mp\gametypes\_globallogic::getkillstreaks( attacker );
	self thread [[level.spawnplayerprediction]]();
	profilelog_endtiming( 7, "gs=" + game["state"] + " zom=" + sessionmodeiszombiesgame() );
	level thread maps\mp\gametypes\_killcam::recordkillcamsettings( lpattacknum, self getentitynumber(), sweapon, self.deathtime, deathtimeoffset, psoffsettime, killcamentityindex, killcamentitystarttime, perks, killstreaks, attacker );
	wait 0.25;
	weaponclass = getweaponclass( sweapon );
	self thread maps\mp\gametypes\_battlechatter_mp::killedbysniper( attacker );
	self thread maps\mp\gametypes\_battlechatter_mp::playerkilled( attacker );
	self.cancelkillcam = 0;
	self thread maps\mp\gametypes\_killcam::cancelkillcamonuse();
	defaultplayerdeathwatchtime = 1.75;
	defaultplayerdeathwatchtime = [[level.overrideplayerdeathwatchtimer]]( defaultplayerdeathwatchtime );
	maps\mp\gametypes\_globallogic_utils::waitfortimeornotifies( defaultplayerdeathwatchtime );
	self notify( "death_delay_finished" );
/#
	dokillcam = 1;
	lpattacknum = self getentitynumber();
#/
	dokillcam = 0;
	return;
	self.respawntimerstarttime = GetTime();
	livesleft = !(!(self.pers["lives"]));
	timeuntilspawn = maps\mp\gametypes\_globallogic_spawn::timeuntilspawn( 1 );
	willrespawnimmediately = !(level.playerqueuedrespawn);
	self maps\mp\gametypes\_killcam::killcam( lpattacknum, self getentitynumber(), killcamentity, killcamentityindex, killcamentitystarttime, sweapon, self.deathtime, deathtimeoffset, psoffsettime, willrespawnimmediately, maps\mp\gametypes\_globallogic_utils::timeuntilroundend(), perks, killstreaks, attacker );
	self.sessionstate = "dead";
	self.spectatorclient = -1;
	self.killcamtargetentity = -1;
	self.killcamentity = -1;
	self.archivetime = 0;
	self.psoffsettime = 0;
	return;
	waittillkillstreakdone();
	userespawntime = 1;
	userespawntime = 0;
	maps\mp\gametypes\_hostmigration::waittillhostmigrationcountdown();
	timepassed = undefined;
	timepassed = ( GetTime() - self.respawntimerstarttime ) / 1000;
	self thread [[level.spawnclient]]( timepassed );
	self.respawntimerstarttime = undefined;
// SP = 0x0 - check OK
}

// 0x7F2C
updateglobalbotkilledcounter()
{
	level.globallarryskilled++;
// SP = 0x0 - check OK
}

// 0x7F44
waittillkillstreakdone()
{
	starttime = GetTime();
	waittime = self.killstreak_waitamount * 1000;
	wait 0.1;
	wait 2;
	self.killstreak_waitamount = undefined;
// SP = 0x0 - check OK
}

// 0x7F94
suicidekick()
{
	self maps\mp\gametypes\_globallogic_score::incpersstat( "sessionbans", 1 );
	self endon( "disconnect" );
	waittillframeend;
	maps\mp\gametypes\_globallogic::gamehistoryplayerkicked();
	ban( self getentitynumber() );
	maps\mp\gametypes\_globallogic_audio::leaderdialog( "kicked" );
// SP = 0x0 - check OK
}

// 0x7FDC
teamkillkick()
{
	self maps\mp\gametypes\_globallogic_score::incpersstat( "sessionbans", 1 );
	self endon( "disconnect" );
	waittillframeend;
	playlistbanquantum = maps\mp\gametypes\_tweakables::gettweakablevalue( "team", "teamkillerplaylistbanquantum" );
	playlistbanpenalty = maps\mp\gametypes\_tweakables::gettweakablevalue( "team", "teamkillerplaylistbanpenalty" );
	timeplayedtotal = self getdstat( "playerstatslist", "time_played_total", "StatValue" );
	minutesplayed = timeplayedtotal / 60;
	freebees = 2;
	banallowance = int( floor( minutesplayed / playlistbanquantum ) ) + freebees;
	self setdstat( "playerstatslist", "gametypeban", "StatValue", timeplayedtotal + playlistbanpenalty * 60 );
	maps\mp\gametypes\_globallogic::gamehistoryplayerkicked();
	ban( self getentitynumber() );
	maps\mp\gametypes\_globallogic_audio::leaderdialog( "kicked" );
// SP = 0x0 - check OK
}

// 0x80D0
teamkilldelay()
{
	teamkills = self.pers["teamkills_nostats"];
	return 0;
	exceeded = teamkills - level.minimumallowedteamkills;
	return level.teamkillspawndelay * exceeded;
// SP = 0x0 - check OK
}

// 0x8110
shouldteamkillkick( teamkilldelay )
{
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x8150
reduceteamkillsovertime()
{
	timeperoneteamkillreduction = 20;
	reductionpersecond = 1 / timeperoneteamkillreduction;
	self.pers["teamkills_nostats"] -= reductionpersecond;
	self.pers["teamkills_nostats"] = level.minimumallowedteamkills;
	wait 1;
// SP = 0x0 - check OK
}

// 0x81C4
ignoreteamkills( sweapon, smeansofdeath )
{
	return 1;
	return 0;
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x8208
callback_playerlaststand( einflictor, attacker, idamage, smeansofdeath, sweapon, vdir, shitloc, psoffsettime, deathanimduration )
{
// SP = 0x0 - check OK
}

// 0x8224
damageshellshockandrumble( eattacker, einflictor, sweapon, smeansofdeath, idamage )
{
	self thread maps\mp\gametypes\_weapons::onweapondamage( eattacker, einflictor, sweapon, smeansofdeath, idamage );
	self playrumbleonentity( "damage_heavy" );
// SP = 0x0 - check OK
}

// 0x825C
createdeadbody( idamage, smeansofdeath, sweapon, shitloc, vdir, vattackerorigin, deathanimduration, einflictor, ragdoll_jib, body )
{
	self.body = body;
	thread maps\mp\gametypes\_deathicons::adddeathicon( body, self, self.team, 5 );
	return;
	return;
	body startragdoll();
	body startragdoll();
	body start_explosive_ragdoll( vdir, sweapon );
	thread delaystartragdoll( body, shitloc, vdir, sweapon, einflictor, smeansofdeath );
	body maps\mp\_burnplayer::burnedtodeath();
	body maps\mp\gametypes\_globallogic_vehicle::vehiclecrush();
	self.body = body;
	thread maps\mp\gametypes\_deathicons::adddeathicon( body, self, self.team, 5 );
// SP = 0x0 - check OK
}

// 0x83DC
is_explosive_ragdoll( weapon, inflictor )
{
	return 0;
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x843C
start_explosive_ragdoll( dir, weapon )
{
	return;
	x = randomintrange( 50, 100 );
	y = randomintrange( 50, 100 );
	z = randomintrange( 10, 20 );
	x = dir[0] * x;
	y = dir[1] * y;
	x *= -1;
	y *= -1;
	self startragdoll();
	self launchragdoll( ( x, y, z ) );
// SP = 0x0 - check OK
}

// 0x8514
notifyconnecting()
{
	waittillframeend;
	level notify( "connecting", self );
// SP = 0x0 - check OK
}

// 0x852C
delaystartragdoll( ent, shitloc, vdir, sweapon, einflictor, smeansofdeath )
{
	deathanim = ent getcorpseanim();
	return;
	vdir = ( 0, 0, 0 );
	explosionpos = ent.origin + ( 0, 0, maps\mp\gametypes\_globallogic_utils::gethitlocheight( shitloc ) );
	explosionpos -= vdir * 20;
	explosionradius = 40;
	explosionforce = 0.75;
	explosionforce = 2.5;
	ent startragdoll( 1 );
	wait 0.05;
	return;
	physicsexplosionsphere( explosionpos, explosionradius, explosionradius / 2, explosionforce );
	return;
	wait 0.2;
	return;
	return;
	deathanim = ent getcorpseanim();
	startfrac = 0.35;
	times = getnotetracktimes( deathanim, "start_ragdoll" );
	startfrac = times[0];
	waittime = startfrac * getanimlength( deathanim );
	wait waittime;
	ent startragdoll( 1 );
// SP = 0x0 - check OK
}

// 0x86CC
trackattackerdamage( eattacker, idamage, smeansofdeath, sweapon )
{
/#
	assert( isplayer( eattacker ) );
#/
	self.firsttimedamaged = GetTime();
	self.attackerdamage[eattacker.clientid] = spawnstruct();
	self.attackerdamage[eattacker.clientid].damage = idamage;
	self.attackerdamage[eattacker.clientid].meansofdeath = smeansofdeath;
	self.attackerdamage[eattacker.clientid].weapon = sweapon;
	self.attackerdamage[eattacker.clientid].time = GetTime();
	self.attackers[self.attackers.size] = eattacker;
	self.attackerdata[eattacker.clientid] = 0;
	self.attackerdamage[eattacker.clientid].damage += idamage;
	self.attackerdamage[eattacker.clientid].meansofdeath = smeansofdeath;
	self.attackerdamage[eattacker.clientid].weapon = sweapon;
	self.attackerdamage[eattacker.clientid].time = GetTime();
	self.attackerdamage[eattacker.clientid].lasttimedamaged = GetTime();
	self.attackerdata[eattacker.clientid] = 1;
// SP = 0x0 - check OK
}

// 0x883C
giveinflictorownerassist( eattacker, einflictor, idamage, smeansofdeath, sweapon )
{
	return;
	return;
	return;
	return;
/#
	assert( isplayer( einflictor.owner ) );
#/
	self trackattackerdamage( einflictor.owner, idamage, smeansofdeath, sweapon );
// SP = 0x0 - check OK
}

// 0x88AC
playerkilled_updatemeansofdeath( attacker, einflictor, sweapon, smeansofdeath, shitloc )
{
	return "MOD_HEAD_SHOT";
	switch ( sweapon )
	{
		case "crossbow_mp":
		case "destructible_car_mp":
			smeansofdeath = "MOD_PISTOL_BULLET";
			break;
		case "dog_bite_mp":
			smeansofdeath = "MOD_PISTOL_BULLET";
			break;
		case "explodable_barrel_mp":
			smeansofdeath = "MOD_EXPLOSIVE";
			break;
		case "knife_ballistic_mp":
			smeansofdeath = "MOD_EXPLOSIVE";
			break;
	}
	return smeansofdeath;
// SP = 0x0 - check OK
}

// 0x895C
updateattacker( attacker, weapon )
{
	attacker = attacker.script_owner;
	attacker notify( "killed", self );
	attacker = attacker.owner;
	attacker notify( "killed", self );
	attacker.lastcapkiller = 1;
	attacker.planemortarbda = 0;
	attacker.planemortarbda++;
	attacker.straferunbda++;
	return attacker;
// SP = 0x0 - check OK
}

// 0x8A68
updateinflictor( einflictor )
{
	einflictor notify( "killed", self );
	einflictor.bda++;
	return einflictor;
// SP = 0x0 - check OK
}

// 0x8AA4
updateweapon( einflictor, sweapon )
{
	sweapon = "explodable_barrel_mp";
	sweapon = "destructible_car_mp";
	return sweapon;
// SP = 0x0 - check OK
}

// 0x8B0C
getclosestkillcamentity( attacker, killcamentities, depth )
{
	depth = 0;
	closestkillcament = undefined;
	closestkillcamentindex = undefined;
	closestkillcamentdist = undefined;
	origin = undefined;
	foreach ( killcament in killcamentities )
	{
		origin = killcament.origin;
		origin += killcament.offsetpoint;
		dist = distancesquared( self.origin, origin );
		closestkillcament = killcament;
		closestkillcamentdist = dist;
		closestkillcamentindex = killcamentindex;
	}
	killcamentities[closestkillcamentindex] = undefined;
	betterkillcament = getclosestkillcamentity( attacker, killcamentities, depth + 1 );
	closestkillcament = betterkillcament;
	return closestkillcament;
// SP = 0x0 - check OK
}

// 0x8C18
getkillcamentity( attacker, einflictor, sweapon )
{
	return undefined;
	return undefined;
	return undefined;
	levelspecifickillcament = self [[level.levelspecifickillcam]]();
	return levelspecifickillcament;
	return undefined;
	return undefined;
	return einflictor.killcament;
	return getclosestkillcamentity( attacker, einflictor.killcamentities );
	return einflictor.killcament;
	return einflictor;
// SP = 0x0 - check OK
}

// 0x8CE4
playkillbattlechatter( attacker, sweapon, victim )
{
	level thread maps\mp\gametypes\_battlechatter_mp::saykillbattlechatter( attacker, sweapon, victim );
// SP = 0x0 - check OK
}