// maps/mp/gametypes_zm/_globallogic_player.gsc

#include maps\mp\gametypes_zm\_globallogic_audio;
#include maps\mp\gametypes_zm\_tweakables;
#include maps\mp\_challenges;
#include maps\mp\gametypes_zm\_spawnlogic;
#include maps\mp\gametypes_zm\_weapons;
#include maps\mp\_demo;
#include maps\mp\gametypes_zm\_hud_util;
#include maps\mp\gametypes_zm\_hud_message;
#include maps\mp\gametypes_zm\_spawning;
#include maps\mp\gametypes_zm\_globallogic_utils;
#include maps\mp\gametypes_zm\_spectating;
#include maps\mp\gametypes_zm\_globallogic_spawn;
#include maps\mp\gametypes_zm\_globallogic_ui;
#include maps\mp\gametypes_zm\_hostmigration;
#include maps\mp\gametypes_zm\_globallogic_score;
#include maps\mp\zombies\_zm_stats;
#include maps\mp\gametypes_zm\_globallogic;
#include common_scripts\utility;
#include maps\mp\_utility;


// 0x2C68
freezeplayerforroundend()
{
	self clearlowermessage();
	self closemenu();
	self closeingamemenu();
	self freeze_player_controls( 1 );
	currentweapon = self getcurrentweapon();
// SP = 0x0 - check OK
}

// 0x2CB4
callback_playerconnect()
{
	thread notifyconnecting();
	self.statusicon = "hud_status_connecting";
	self waittill( "begin" );
	self [[level.reset_clientdvars]]();
	waittillframeend;
	self.statusicon = "";
	self.guid = self getguid();
	profilelog_begintiming( 4, "ship" );
	level notify( "connected", self );
	self thread maps\mp\gametypes_zm\_globallogic::listenforgameend();
	iprintln( &"MP_CONNECTED", self );
	self thread maps\mp\zombies\_zm_stats::adjustrecentstats();
	gamemode = maps\mp\gametypes_zm\_globallogic::getcurrentgamemode();
	self maps\mp\gametypes_zm\_globallogic::incrementmatchcompletionstat( gamemode, "played", "started" );
	self maps\mp\gametypes_zm\_globallogic::incrementmatchcompletionstat( gamemode, "hosted", "started" );
	self.pers["matchesHostedStatsTracked"] = 1;
	self.pers["matchesPlayedStatsTracked"] = 1;
	self thread maps\mp\zombies\_zm_stats::uploadstatssoon();
	lpselfnum = self getentitynumber();
	lpguid = self getguid();
	logprint( "J;" + lpguid + ";" + lpselfnum + ";" + self.name + "\n" );
	bbprint( "mpjoins", "name %s client %s", self.name, lpselfnum );
	self setclientuivisibilityflag( "hud_visible", 1 );
	self.pers["hasRadar"] = 1;
	self.hasspyplane = 1;
	level.activeuavs[self getentitynumber()] = 1;
	self setclientuivisibilityflag( "g_compassShowEnemies", level.forceradar );
	self setclientuivisibilityflag( "g_compassShowEnemies", 0 );
	self setclientplayersprinttime( level.playersprinttime );
	self setclientnumlives( level.numlives );
	makedvarserverinfo( "cg_drawTalk", 1 );
	self setclientdrawtalk( 3 );
	self [[level.player_stats_init]]();
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "score" );
	self.pers["score"] = 0;
	self.score = self.pers["score"];
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "momentum", 0 );
	self.momentum = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "momentum" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "suicides" );
	self.suicides = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "suicides" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "headshots" );
	self.headshots = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "headshots" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "challenges" );
	self.challenges = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "challenges" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "kills" );
	self.kills = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "kills" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "deaths" );
	self.deaths = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "deaths" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "assists" );
	self.assists = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "assists" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "defends", 0 );
	self.defends = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "defends" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "offends", 0 );
	self.offends = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "offends" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "plants", 0 );
	self.plants = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "plants" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "defuses", 0 );
	self.defuses = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "defuses" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "returns", 0 );
	self.returns = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "returns" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "captures", 0 );
	self.captures = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "captures" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "destructions", 0 );
	self.destructions = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "destructions" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "backstabs", 0 );
	self.backstabs = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "backstabs" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "longshots", 0 );
	self.longshots = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "longshots" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "survived", 0 );
	self.survived = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "survived" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "stabs", 0 );
	self.stabs = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "stabs" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "tomahawks", 0 );
	self.tomahawks = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "tomahawks" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "humiliated", 0 );
	self.humiliated = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "humiliated" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "x2score", 0 );
	self.x2score = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "x2score" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "agrkills", 0 );
	self.x2score = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "agrkills" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "hacks", 0 );
	self.x2score = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "hacks" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "sessionbans", 0 );
	self.sessionbans = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "sessionbans" );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "gametypeban", 0 );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "time_played_total", 0 );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "time_played_alive", 0 );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "teamkills", 0 );
	self maps\mp\gametypes_zm\_globallogic_score::initpersstat( "teamkills_nostats", 0 );
	self.teamkillpunish = 0;
	self thread reduceteamkillsovertime();
	level waittill( "eternity" );
	self.killedplayerscurrent = [];
	self.pers["killed_players"] = [];
	self.pers["killed_by"] = [];
	self.pers["nemesis_tracking"] = [];
	self.pers["artillery_kills"] = 0;
	self.pers["dog_kills"] = 0;
	self.pers["nemesis_name"] = "";
	self.pers["nemesis_rank"] = 0;
	self.pers["nemesis_rankIcon"] = 0;
	self.pers["nemesis_xp"] = 0;
	self.pers["nemesis_xuid"] = "";
	self.pers["best_kill_streak"] = 0;
	self.pers["music"] = spawnstruct();
	self.pers["music"].spawn = 0;
	self.pers["music"].inque = 0;
	self.pers["music"].currentstate = "SILENT";
	self.pers["music"].previousstate = "SILENT";
	self.pers["music"].nextstate = "UNDERSCORE";
	self.pers["music"].returnstate = "UNDERSCORE";
	self.leaderdialogqueue = [];
	self.leaderdialogactive = 0;
	self.leaderdialoggroups = [];
	self.currentleaderdialoggroup = "";
	self.currentleaderdialog = "";
	self.currentleaderdialogtime = 0;
	self.pers["cur_kill_streak"] = 0;
	self.pers["cur_total_kill_streak"] = 0;
	self setplayercurrentstreak( 0 );
	self.pers["totalKillstreakCount"] = 0;
	self.pers["killstreaksEarnedThisKillstreak"] = 0;
	self.pers["killstreak_quantity"] = [];
	self.pers["held_killstreak_ammo_count"] = [];
	self.lastkilltime = 0;
	self.cur_death_streak = 0;
	self disabledeathstreak();
	self.death_streak = 0;
	self.kill_streak = 0;
	self.gametype_kill_streak = 0;
	self.spawnqueueindex = -1;
	self.deathtime = 0;
	self.lastgrenadesuicidetime = -1;
	self.teamkillsthisround = 0;
	self.pers["lives"] = level.numlives;
	self.pers["team"] = undefined;
	self.hasspawned = 0;
	self.waitingtospawn = 0;
	self.wantsafespawn = 0;
	self.deathcount = 0;
	self.wasaliveatmatchstart = 0;
	level.players[level.players.size] = self;
	setdvar( "splitscreen_playerNum", level.players.size );
	self.pers["needteam"] = 1;
	self.pers["team"] = "spectator";
	self.team = "spectator";
	self setclientuivisibilityflag( "hud_visible", 0 );
	self [[level.spawnintermission]]();
	self closemenu();
	self closeingamemenu();
	profilelog_endtiming( 4, "gs=" + game["state"] + " zom=" + sessionmodeiszombiesgame() );
	return;
	self maps\mp\zombies\_zm_stats::increment_client_stat( "losses" );
	self updatestatratio( "wlratio", "wins", "losses" );
	self maps\mp\zombies\_zm_stats::add_location_gametype_stat( level.scr_zm_map_start_location, level.scr_zm_ui_gametype, "losses", 1 );
	self luinotifyevent( &"hud_update_survival_team", 1, 2 );
	level endon( "game_ended" );
	self thread maps\mp\gametypes_zm\_hostmigration::hostmigrationtimerthink();
	self.pers["class"] = undefined;
	self.class = self.pers["class"];
	self.team = self.pers["team"];
	self.class = self.pers["class"];
	self.pers["needteam"] = undefined;
	self.pers["team"] = "spectator";
	self.team = "spectator";
	self.sessionstate = "dead";
	self maps\mp\gametypes_zm\_globallogic_ui::updateobjectivetext();
	[[level.spawnspectator]]();
	[[level.autoassign]]( 0 );
	self thread maps\mp\gametypes_zm\_globallogic_spawn::kickifdontspawn();
	[[level.autoassign]]( 0 );
	self.sessionteam = "spectator";
	self.ffateam = "spectator";
	self thread spectate_player_watcher();
	self.sessionteam = self.pers["team"];
	self.statusicon = "hud_status_dead";
	self thread maps\mp\gametypes_zm\_spectating::setspectatepermissions();
	self setclientscriptmainmenu( game["menu_class"] );
	[[level.spawnspectator]]();
	self.sessionteam = "spectator";
	self.sessionstate = "spectator";
	self.ffateam = "spectator";
	self thread spectate_player_watcher();
	self.sessionteam = self.pers["team"];
	self.sessionstate = "dead";
	self.ffateam = self.pers["team"];
	self maps\mp\gametypes_zm\_globallogic_ui::updateobjectivetext();
	[[level.spawnspectator]]();
	self thread [[level.spawnclient]]();
	self maps\mp\gametypes_zm\_globallogic_ui::showmainmenuforteam();
	self thread maps\mp\gametypes_zm\_spectating::setspectatepermissions();
	self thread maps\mp\gametypes_zm\_spawning::onspawnplayer_unified( 1 );
	profilelog_endtiming( 4, "gs=" + game["state"] + " zom=" + sessionmodeiszombiesgame() );
	return;
// SP = 0x0 - check OK
}

// 0x3998
spectate_player_watcher()
{
	self endon( "disconnect" );
	self.watchingactiveclient = 1;
	self.waitingforplayerstext = undefined;
	self maps\mp\gametypes_zm\_hud_message::clearshoutcasterwaitingmessage();
/#
	println( " Unfreeze controls 1" );
#/
	self freezecontrols( 0 );
	self.watchingactiveclient = 0;
	self maps\mp\gametypes_zm\_hud_util::showperks();
	self thread maps\mp\gametypes_zm\_globallogic_ui::hideloadoutaftertime( 0 );
	count = 0;
	i = 0;
	count++;
	i++;
	self maps\mp\gametypes_zm\_hud_message::clearshoutcasterwaitingmessage();
	self freezecontrols( 0 );
/#
	println( " Unfreeze controls 2" );
#/
	self.watchingactiveclient = 1;
	[[level.onspawnspectator]]();
	self freezecontrols( 1 );
	self maps\mp\gametypes_zm\_hud_message::setshoutcasterwaitingmessage();
	self.watchingactiveclient = 0;
	wait 0.5;
// SP = 0x0 - check OK
}

// 0x3B10
callback_playermigrated()
{
/#
	println( "Player " + self.name + " finished migrating at time " + GetTime() );
#/
	self maps\mp\gametypes_zm\_globallogic_ui::updateobjectivetext();
	self thread inform_clientvm_of_migration();
	level.hostmigrationreturnedplayercount++;
/#
	println( "2/3 of players have finished migrating" );
#/
	level notify( "hostmigration_enoughplayers" );
// SP = 0x0 - check OK
}

// 0x3B90
inform_clientvm_of_migration()
{
	self endon( "disconnect" );
	wait 1;
	self clientnotify( "hmo" );
/#
	println( "SERVER : Sent HMO to client " + self getentitynumber() );
#/
// SP = 0x0 - check OK
}

// 0x3BCC
callback_playerdisconnect()
{
	profilelog_begintiming( 5, "ship" );
	gamelength = maps\mp\gametypes_zm\_globallogic::getgamelength();
	self maps\mp\gametypes_zm\_globallogic::bbplayermatchend( gamelength, "MP_PLAYER_DISCONNECT", 0 );
	self removeplayerondisconnect();
	players = level.players;
	level thread maps\mp\gametypes_zm\_globallogic::forceend();
	setdvar( "splitscreen_playerNum", players.size );
	self logstring( "team: score " + self.pers["team"] + ":" + self.score );
	level.dropteam += 1;
	[[level.onplayerdisconnect]]();
	lpselfnum = self getentitynumber();
	lpguid = self getguid();
	logprint( "Q;" + lpguid + ";" + lpselfnum + ";" + self.name + "\n" );
	entry = 0;
	level.players[entry] = level.players[entry + 1];
	entry++;
	level.players[entry] = undefined;
	entry++;
	entry = 0;
	level.players[entry].pers["killed_players"][self.name] = undefined;
	level.players[entry].killedplayerscurrent[self.name] = undefined;
	level.players[entry].pers["killed_by"][self.name] = undefined;
	level.players[entry].pers["nemesis_tracking"][self.name] = undefined;
	level.players[entry] choosenextbestnemesis();
	entry++;
	self maps\mp\gametypes_zm\_globallogic::removedisconnectedplayerfromplacement();
	level thread maps\mp\gametypes_zm\_globallogic::updateteamstatus();
	profilelog_endtiming( 5, "gs=" + game["state"] + " zom=" + sessionmodeiszombiesgame() );
// SP = 0x0 - check OK
}

// 0x3E7C
callback_playermelee( eattacker, idamage, sweapon, vorigin, vdir, boneindex, shieldhit )
{
	hit = 1;
	hit = 0;
	self finishmeleehit( eattacker, sweapon, vorigin, vdir, boneindex, shieldhit, hit );
// SP = 0x0 - check OK
}

// 0x3ED8
choosenextbestnemesis()
{
	nemesisarray = self.pers["nemesis_tracking"];
	nemesisarraykeys = getarraykeys( nemesisarray );
	nemesisamount = 0;
	nemesisname = "";
	i = 0;
	nemesisarraykey = nemesisarraykeys[i];
	nemesisname = nemesisarraykey;
	nemesisamount = nemesisarray[nemesisarraykey];
	i++;
	self.pers["nemesis_name"] = nemesisname;
	playerindex = 0;
	nemesisplayer = level.players[playerindex];
	self.pers["nemesis_rank"] = nemesisplayer.pers["rank"];
	self.pers["nemesis_rankIcon"] = nemesisplayer.pers["rankxp"];
	self.pers["nemesis_xp"] = nemesisplayer.pers["prestige"];
	self.pers["nemesis_xuid"] = nemesisplayer getxuid( 1 );
	playerindex++;
	self.pers["nemesis_xuid"] = "";
// SP = 0x0 - check OK
}

// 0x4004
removeplayerondisconnect()
{
	entry = 0;
	level.players[entry] = level.players[entry + 1];
	entry++;
	level.players[entry] = undefined;
	entry++;
// SP = 0x0 - check OK
}

// 0x4064
custom_gamemodes_modified_damage( victim, eattacker, idamage, smeansofdeath, sweapon, einflictor, shitloc )
{
	return idamage;
	idamage *= eattacker.damagemodifier;
	idamage = int( idamage * level.bulletdamagescalar );
	return idamage;
// SP = 0x0 - check OK
}

// 0x40D8
figureoutattacker( eattacker )
{
	team = self.team;
	team = self.aiteam;
	eattacker = eattacker.script_owner;
	eattacker = eattacker.owner;
	eattacker = eattacker.owner;
	return eattacker;
// SP = 0x0 - check OK
}

// 0x418C
figureoutweapon( sweapon, einflictor )
{
	sweapon = "explodable_barrel_mp";
	sweapon = "destructible_car_mp";
	return sweapon;
// SP = 0x0 - check OK
}

// 0x41F4
isplayerimmunetokillstreak( eattacker, sweapon )
{
	return 0;
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x4234
callback_playerdamage( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime, boneindex )
{
	profilelog_begintiming( 6, "ship" );
	return;
	return;
	return;
	return;
	return;
	return;
	return;
	self notify( "emp_grenaded", eattacker );
	idamage = custom_gamemodes_modified_damage( self, eattacker, idamage, smeansofdeath, sweapon, einflictor, shitloc );
	idamage = int( idamage );
	self.idflags = idflags;
	self.idflagstime = GetTime();
	eattacker = figureoutattacker( eattacker );
	pixbeginevent( "PlayerDamage flags/tweaks" );
	idflags |= level.idflags_no_knockback;
	friendly = 0;
	self notify( "snd_pain_player" );
	smeansofdeath = "MOD_FALLING";
	smeansofdeath = "MOD_HEAD_SHOT";
	modifieddamage = [[level.onplayerdamage]]( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime );
	return;
	idamage = modifieddamage;
	return;
	idamage = 150;
	self.lastattackweapon = sweapon;
	sweapon = figureoutweapon( sweapon, einflictor );
	pixendevent();
	attackerishittingteammate = self isenemyplayer( eattacker ) == 0;
	return;
	previous_shield_damage = self.shielddamageblocked;
	self.shielddamageblocked += idamage;
	eattacker.lastattackedshieldplayer = self;
	eattacker.lastattackedshieldtime = GetTime();
	score_event = "shield_blocked_damage";
	score_event = "shield_blocked_damage_reduced";
	shitloc = "none";
	idamage *= 0;
	idamage = 101;
	shitloc = "none";
	return;
	level.usestartspawns = 0;
	pixbeginevent( "PlayerDamage log" );
/#
	println( "client:" + self getentitynumber() + " health:" + self.health + " attacker:" + eattacker.clientid + " inflictor is player:" + isplayer( einflictor ) + " damage:" + idamage + " hitLoc:" + shitloc );
#/
	lpselfnum = self getentitynumber();
	lpselfname = self.name;
	lpselfteam = self.team;
	lpselfguid = self getguid();
	lpattackerteam = "";
	lpattackerorigin = ( 0, 0, 0 );
	lpattacknum = eattacker getentitynumber();
	lpattackguid = eattacker getguid();
	lpattackname = eattacker.name;
	lpattackerteam = eattacker.team;
	lpattackerorigin = eattacker.origin;
	bbprint( "mpattacks", "gametime %d attackerspawnid %d attackerweapon %s attackerx %d attackery %d attackerz %d victimspawnid %d victimx %d victimy %d victimz %d damage %d damagetype %s damagelocation %s death %d", GetTime(), getplayerspawnid( eattacker ), sweapon, lpattackerorigin, getplayerspawnid( self ), self.origin, idamage, smeansofdeath, shitloc, 0 );
	lpattacknum = -1;
	lpattackguid = "";
	lpattackname = "";
	lpattackerteam = "world";
	bbprint( "mpattacks", "gametime %d attackerweapon %s victimspawnid %d victimx %d victimy %d victimz %d damage %d damagetype %s damagelocation %s death %d", GetTime(), sweapon, getplayerspawnid( self ), self.origin, idamage, smeansofdeath, shitloc, 0 );
	logprint( "D;" + lpselfguid + ";" + lpselfnum + ";" + lpselfteam + ";" + lpselfname + ";" + lpattackguid + ";" + lpattacknum + ";" + lpattackerteam + ";" + lpattackname + ";" + sweapon + ";" + idamage + ";" + smeansofdeath + ";" + shitloc + "\n" );
	pixendevent();
	profilelog_endtiming( 6, "gs=" + game["state"] + " zom=" + sessionmodeiszombiesgame() );
// SP = 0x0 - check OK
}

// 0x47F4
resetattackerlist()
{
	self.attackers = [];
	self.attackerdata = [];
	self.attackerdamage = [];
	self.firsttimedamaged = 0;
// SP = 0x0 - check OK
}

// 0x4814
dodamagefeedback( sweapon, einflictor, idamage, smeansofdeath )
{
	return 0;
	return 0;
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x4868
istacticalhitmarker( sweapon, smeansofdeath, idamage )
{
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x48AC
doperkfeedback( player, sweapon, smeansofdeath, einflictor )
{
	perkfeedback = undefined;
	return perkfeedback;
// SP = 0x0 - check OK
}

// 0x48C4
isaikillstreakdamage( sweapon, einflictor )
{
	switch ( sweapon )
	{
		case "ai_tank_drone_rocket_mp":
			return IsDefined( einflictor.firedbyai );
		case "chopper_minigun_mp":
			return 1;
		case "cobra_20mm_comlink_mp":
			return 1;
		case "littlebird_guard_minigun_mp":
			return 1;
		case "missile_swarm_projectile_mp":
			return 1;
		case "planemortar_mp":
			return 1;
		case "straferun_rockets_mp":
			return 1;
	}
	return 0;
// SP = 0x0 - check OK
}

// 0x4934
finishplayerdamagewrapper( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime, boneindex )
{
	pixbeginevent( "finishPlayerDamageWrapper" );
/#
	println( "penetrated:" + self getentitynumber() + " health:" + self.health + " attacker:" + eattacker.clientid + " inflictor is player:" + isplayer( einflictor ) + " damage:" + idamage + " hitLoc:" + shitloc );
#/
	eattacker addplayerstat( "penetration_shots", 1 );
	self finishplayerdamage( einflictor, eattacker, idamage, idflags, smeansofdeath, sweapon, vpoint, vdir, shitloc, psoffsettime, boneindex );
	self shellshock( "damage_mp", 0.2 );
	self damageshellshockandrumble( eattacker, einflictor, sweapon, smeansofdeath, idamage );
	pixendevent();
// SP = 0x0 - check OK
}

// 0x4A40
allowedassistweapon( weapon )
{
	return 1;
// SP = 0x0 - check OK
}

// 0x4A4C
callback_playerkilled( einflictor, attacker, idamage, smeansofdeath, sweapon, vdir, shitloc, psoffsettime, deathanimduration )
{
	profilelog_begintiming( 7, "ship" );
	self endon( "spawned" );
	self notify( "killed_player" );
	return;
	return;
	self needsrevive( 0 );
	self setburn( 0 );
	self.suicide = 0;
	self.pers["lives"]--;
	level notify( "player_eliminated" );
	self notify( "player_eliminated" );
	self thread flushgroupdialogonplayer( "item_destroyed" );
	sweapon = updateweapon( einflictor, sweapon );
	pixbeginevent( "PlayerKilled pre constants" );
	wasinlaststand = 0;
	deathtimeoffset = 0;
	lastweaponbeforedroppingintolaststand = undefined;
	attackerstance = undefined;
	self.laststandthislife = undefined;
	self.vattackerorigin = undefined;
	self.uselaststandparams = undefined;
/#
	assert( IsDefined( self.laststandparams ) );
#/
	einflictor = self.laststandparams.einflictor;
	attacker = self.laststandparams.attacker;
	attackerstance = self.laststandparams.attackerstance;
	idamage = self.laststandparams.idamage;
	smeansofdeath = self.laststandparams.smeansofdeath;
	sweapon = self.laststandparams.sweapon;
	vdir = self.laststandparams.vdir;
	shitloc = self.laststandparams.shitloc;
	self.vattackerorigin = self.laststandparams.vattackerorigin;
	deathtimeoffset = ( GetTime() - self.laststandparams.laststandstarttime ) / 1000;
	wasinlaststand = 1;
	lastweaponbeforedroppingintolaststand = self.previousprimary;
	self.laststandparams = undefined;
	bestplayer = undefined;
	bestplayermeansofdeath = undefined;
	obituarymeansofdeath = undefined;
	bestplayerweapon = undefined;
	obituaryweapon = undefined;
	i = 0;
	player = self.attackers[i];
	bestplayer = player;
	bestplayermeansofdeath = self.attackerdamage[player.clientid].meansofdeath;
	bestplayerweapon = self.attackerdamage[player.clientid].weapon;
	bestplayer = player;
	bestplayermeansofdeath = self.attackerdamage[player.clientid].meansofdeath;
	bestplayerweapon = self.attackerdamage[player.clientid].weapon;
	i++;
	self recordkillmodifier( "assistedsuicide" );
	attacker = bestplayer;
	obituarymeansofdeath = bestplayermeansofdeath;
	obituaryweapon = bestplayerweapon;
	attacker.damagedplayers[self.clientid] = undefined;
	attacker playlocalsound( "prj_bullet_impact_headshot_helmet_nodie_2d" );
	smeansofdeath = "MOD_HEAD_SHOT";
	self.deathtime = GetTime();
	attacker = updateattacker( attacker, sweapon );
	einflictor = updateinflictor( einflictor );
	smeansofdeath = updatemeansofdeath( sweapon, smeansofdeath );
	self detachshieldmodel( level.carriedshieldmodel, "tag_weapon_left" );
	self.hasriotshield = 0;
	self.hasriotshieldequipped = 0;
	self thread updateglobalbotkilledcounter();
	self addweaponstat( sweapon, "deaths", 1 );
	weaponname = lastweaponbeforedroppingintolaststand;
	weaponname = self.lastdroppableweapon;
	weaponname = self.currentweapon;
	self addweaponstat( weaponname, "deathsDuringUse", 1 );
	attacker addweaponstat( sweapon, "kills", 1 );
	attacker addweaponstat( sweapon, "headshots", 1 );
	obituarymeansofdeath = smeansofdeath;
	obituaryweapon = sweapon;
	level notify( "reset_obituary_count" );
	level.lastobituaryplayercount = 0;
	level.lastobituaryplayer = undefined;
	level.lastobituaryplayercount++;
	level notify( "reset_obituary_count" );
	level.lastobituaryplayer = attacker;
	level.lastobituaryplayercount = 1;
	level notify( "reset_obituary_count" );
	level.lastobituaryplayercount = 0;
	level.lastobituaryplayer = undefined;
	overrideentitycamera = 0;
	obituary( self, self, obituaryweapon, obituarymeansofdeath );
	maps\mp\_demo::bookmark( "kill", GetTime(), self, self, 0, einflictor, overrideentitycamera );
	obituary( self, attacker, obituaryweapon, obituarymeansofdeath );
	maps\mp\_demo::bookmark( "kill", GetTime(), self, attacker, 0, einflictor, overrideentitycamera );
	self maps\mp\gametypes_zm\_weapons::dropscavengerfordeath( attacker );
	self maps\mp\gametypes_zm\_weapons::dropweaponfordeath( attacker );
	self maps\mp\gametypes_zm\_weapons::dropoffhand();
	maps\mp\gametypes_zm\_spawnlogic::deathoccured( self, attacker );
	self.sessionstate = "dead";
	self.statusicon = "hud_status_dead";
	self.pers["weapon"] = undefined;
	self.killedplayerscurrent = [];
	self.deathcount++;
/#
	println( "players(" + self.clientid + ") death count ++: " + self.deathcount );
#/
	self.pers["cur_kill_streak"] = 0;
	self.pers["cur_total_kill_streak"] = 0;
	self.pers["totalKillstreakCount"] = 0;
	self.pers["killstreaksEarnedThisKillstreak"] = 0;
	self setplayercurrentstreak( 0 );
	self maps\mp\gametypes_zm\_globallogic_score::incpersstat( "deaths", 1, 1, 1 );
	self.deaths = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "deaths" );
	self updatestatratio( "kdratio", "kills", "deaths" );
	self.pers["best_kill_streak"] = self.pers["cur_kill_streak"];
	self.pers["kill_streak_before_death"] = self.pers["cur_kill_streak"];
	self.pers["cur_kill_streak"] = 0;
	self.pers["cur_total_kill_streak"] = 0;
	self.pers["totalKillstreakCount"] = 0;
	self.pers["killstreaksEarnedThisKillstreak"] = 0;
	self setplayercurrentstreak( 0 );
	self.cur_death_streak++;
	self setdstat( "HighestStats", "death_streak", self.cur_death_streak );
	self.death_streak = self.cur_death_streak;
	self enabledeathstreak();
	self.pers["totalKillstreakCount"] = 0;
	self.pers["killstreaksEarnedThisKillstreak"] = 0;
	lpselfnum = self getentitynumber();
	lpselfname = self.name;
	lpattackguid = "";
	lpattackname = "";
	lpselfteam = self.team;
	lpselfguid = self getguid();
	lpattackteam = "";
	lpattackorigin = ( 0, 0, 0 );
	lpattacknum = -1;
	awardassists = 0;
	pixendevent();
	self resetplayermomentumondeath();
	lpattackguid = attacker getguid();
	lpattackname = attacker.name;
	lpattackteam = attacker.team;
	lpattackorigin = attacker.origin;
	dokillcam = 0;
	self maps\mp\gametypes_zm\_globallogic_score::incpersstat( "suicides", 1 );
	self.suicides = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "suicides" );
	self.lastgrenadesuicidetime = GetTime();
	awardassists = 1;
	self.suicide = 1;
	self iprintln( &"MP_FRIENDLY_FIRE_WILL_NOT" );
	scoresub = self [[level.getteamkillscore]]( einflictor, attacker, smeansofdeath, sweapon );
	maps\mp\gametypes_zm\_globallogic_score::_setplayerscore( attacker, maps\mp\gametypes_zm\_globallogic_score::_getplayerscore( attacker ) - scoresub );
	pixbeginevent( "PlayerKilled attacker" );
	lpattacknum = attacker getentitynumber();
	dokillcam = 1;
	teamkill_penalty = self [[level.getteamkillpenalty]]( einflictor, attacker, smeansofdeath, sweapon );
	attacker maps\mp\gametypes_zm\_globallogic_score::incpersstat( "teamkills_nostats", teamkill_penalty, 0 );
	attacker maps\mp\gametypes_zm\_globallogic_score::incpersstat( "teamkills", 1 );
	attacker.teamkillsthisround++;
	scoresub = self [[level.getteamkillscore]]( einflictor, attacker, smeansofdeath, sweapon );
	maps\mp\gametypes_zm\_globallogic_score::_setplayerscore( attacker, maps\mp\gametypes_zm\_globallogic_score::_getplayerscore( attacker ) - scoresub );
	teamkilldelay = 1;
	teamkilldelay = 1;
	teamkilldelay = attacker teamkilldelay();
	attacker.teamkillpunish = 1;
	attacker suicide();
	attacker teamkillkick();
	attacker thread reduceteamkillsovertime();
	maps\mp\gametypes_zm\_globallogic_score::inctotalkills( attacker.team );
	attacker thread maps\mp\gametypes_zm\_globallogic_score::givekillstats( smeansofdeath, sweapon, self );
	pixbeginevent( "killstreak" );
	shouldgivekillstreak = 0;
	attacker.pers["cur_total_kill_streak"]++;
	attacker setplayercurrentstreak( attacker.pers["cur_total_kill_streak"] );
	attacker.pers["cur_kill_streak"]++;
	pixendevent();
	attacker setdstat( "HighestStats", "kill_streak", attacker.pers["totalKillstreakCount"] );
	attacker.kill_streak = attacker.pers["cur_kill_streak"];
	killstreak = undefined;
	attacker thread maps\mp\gametypes_zm\_globallogic_score::trackattackerkill( self.name, self.pers["rank"], self.pers["rankxp"], self.pers["prestige"], self getxuid( 1 ) );
	attackername = attacker.name;
	self thread maps\mp\gametypes_zm\_globallogic_score::trackattackeedeath( attackername, attacker.pers["rank"], attacker.pers["rankxp"], attacker.pers["prestige"], attacker getxuid( 1 ) );
	attacker thread maps\mp\gametypes_zm\_globallogic_score::inckillstreaktracker( sweapon );
	maps\mp\gametypes_zm\_globallogic_score::giveteamscore( "kill", attacker.aiteam, attacker, self );
	maps\mp\gametypes_zm\_globallogic_score::giveteamscore( "kill", attacker.team, attacker, self );
	scoresub = level.deathpointloss;
	maps\mp\gametypes_zm\_globallogic_score::_setplayerscore( self, maps\mp\gametypes_zm\_globallogic_score::_getplayerscore( self ) - scoresub );
	level thread playkillbattlechatter( attacker, sweapon, self );
	awardassists = 1;
	pixendevent();
	dokillcam = 0;
	lpattacknum = -1;
	lpattackguid = "";
	lpattackname = "";
	lpattackteam = "world";
	self maps\mp\gametypes_zm\_globallogic_score::incpersstat( "suicides", 1 );
	self.suicides = self maps\mp\gametypes_zm\_globallogic_score::getpersstat( "suicides" );
	awardassists = 1;
	dokillcam = 0;
	lpattacknum = -1;
	lpattackguid = "";
	lpattackname = "";
	lpattackteam = "world";
	dokillcam = 1;
	lpattacknum = self getentitynumber();
	maps\mp\gametypes_zm\_globallogic_score::giveteamscore( "kill", attacker.team, attacker, self );
	awardassists = 1;
	awardassists = 0;
	pixbeginevent( "PlayerKilled assists" );
	j = 0;
	player = self.attackers[j];
	damage_done = self.attackerdamage[player.clientid].damage;
	player thread maps\mp\gametypes_zm\_globallogic_score::processassist( self, damage_done, self.attackerdamage[player.clientid].weapon );
	j++;
	self.lastattackedshieldplayer thread maps\mp\gametypes_zm\_globallogic_score::processshieldassist( self );
	pixendevent();
	pixbeginevent( "PlayerKilled post constants" );
	self.lastattacker = attacker;
	self.lastdeathpos = self.origin;
	self thread maps\mp\_challenges::playerkilled( einflictor, attacker, idamage, smeansofdeath, sweapon, shitloc, attackerstance );
	self notify( "playerKilledChallengesProcessed" );
	self.attackers = [];
	bbprint( "mpattacks", "gametime %d attackerspawnid %d attackerweapon %s attackerx %d attackery %d attackerz %d victimspawnid %d victimx %d victimy %d victimz %d damage %d damagetype %s damagelocation %s death %d", GetTime(), getplayerspawnid( attacker ), sweapon, lpattackorigin, getplayerspawnid( self ), self.origin, idamage, smeansofdeath, shitloc, 1 );
	bbprint( "mpattacks", "gametime %d attackerweapon %s victimspawnid %d victimx %d victimy %d victimz %d damage %d damagetype %s damagelocation %s death %d", GetTime(), sweapon, getplayerspawnid( self ), self.origin, idamage, smeansofdeath, shitloc, 1 );
	logprint( "K;" + lpselfguid + ";" + lpselfnum + ";" + lpselfteam + ";" + lpselfname + ";" + lpattackguid + ";" + lpattacknum + ";" + lpattackteam + ";" + lpattackname + ";" + sweapon + ";" + idamage + ";" + smeansofdeath + ";" + shitloc + "\n" );
	attackerstring = "none";
	attackerstring = attacker getxuid() + "(" + lpattackname + ")";
	self logstring( "d " + smeansofdeath + "(" + sweapon + ") a:" + attackerstring + " d:" + idamage + " l:" + shitloc + " @ " + int( self.origin[0] ) + " " + int( self.origin[1] ) + " " + int( self.origin[2] ) );
	level thread maps\mp\gametypes_zm\_globallogic::updateteamstatus();
	killcamentity = self getkillcamentity( attacker, einflictor, sweapon );
	killcamentityindex = -1;
	killcamentitystarttime = 0;
	killcamentityindex = killcamentity getentitynumber();
	killcamentitystarttime = killcamentity.starttime;
	killcamentitystarttime = killcamentity.birthtime;
	killcamentitystarttime = 0;
	dokillcam = 0;
	self maps\mp\gametypes_zm\_weapons::detachcarryobjectmodel();
	died_in_vehicle = 0;
	died_in_vehicle = self.diedonvehicle;
	pixendevent();
	pixbeginevent( "PlayerKilled body and gibbing" );
	vattackerorigin = undefined;
	vattackerorigin = attacker.origin;
	ragdoll_now = 0;
	ragdoll_now = 1;
	body = self cloneplayer( deathanimduration );
	self createdeadbody( idamage, smeansofdeath, sweapon, shitloc, vdir, vattackerorigin, deathanimduration, einflictor, ragdoll_now, body );
	pixendevent();
	thread maps\mp\gametypes_zm\_globallogic_spawn::spawnqueuedclient( self.team, attacker );
	self.switching_teams = undefined;
	self.joining_team = undefined;
	self.leaving_team = undefined;
	self thread [[level.onplayerkilled]]( einflictor, attacker, idamage, smeansofdeath, sweapon, vdir, shitloc, psoffsettime, deathanimduration );
	icb = 0;
	self [[level.onplayerkilledextraunthreadedcbs[icb]]]( einflictor, attacker, idamage, smeansofdeath, sweapon, vdir, shitloc, psoffsettime, deathanimduration );
	icb++;
	self.wantsafespawn = 0;
	perks = [];
	killstreaks = maps\mp\gametypes_zm\_globallogic::getkillstreaks( attacker );
	self thread [[level.spawnplayerprediction]]();
	profilelog_endtiming( 7, "gs=" + game["state"] + " zom=" + sessionmodeiszombiesgame() );
	wait 0.25;
	weaponclass = getweaponclass( sweapon );
	self.cancelkillcam = 0;
	defaultplayerdeathwatchtime = 1.75;
	defaultplayerdeathwatchtime = [[level.overrideplayerdeathwatchtimer]]( defaultplayerdeathwatchtime );
	maps\mp\gametypes_zm\_globallogic_utils::waitfortimeornotifies( defaultplayerdeathwatchtime );
	self notify( "death_delay_finished" );
/#
	dokillcam = 1;
	lpattacknum = self getentitynumber();
#/
	return;
	self.respawntimerstarttime = GetTime();
	livesleft = !(!(self.pers["lives"]));
	timeuntilspawn = maps\mp\gametypes_zm\_globallogic_spawn::timeuntilspawn( 1 );
	willrespawnimmediately = !(level.playerqueuedrespawn);
	self.sessionstate = "dead";
	self.spectatorclient = -1;
	self.killcamtargetentity = -1;
	self.killcamentity = -1;
	self.archivetime = 0;
	self.psoffsettime = 0;
	return;
	waittillkillstreakdone();
	timepassed = undefined;
	timepassed = ( GetTime() - self.respawntimerstarttime ) / 1000;
	self thread [[level.spawnclient]]( timepassed );
	self.respawntimerstarttime = undefined;
// SP = 0x0 - check OK
}

// 0x5FC0
updateglobalbotkilledcounter()
{
	level.globallarryskilled++;
// SP = 0x0 - check OK
}

// 0x5FD8
waittillkillstreakdone()
{
	starttime = GetTime();
	waittime = self.killstreak_waitamount * 1000;
	wait 0.1;
	wait 2;
	self.killstreak_waitamount = undefined;
// SP = 0x0 - check OK
}

// 0x6028
teamkillkick()
{
	self maps\mp\gametypes_zm\_globallogic_score::incpersstat( "sessionbans", 1 );
	self endon( "disconnect" );
	waittillframeend;
	playlistbanquantum = maps\mp\gametypes_zm\_tweakables::gettweakablevalue( "team", "teamkillerplaylistbanquantum" );
	playlistbanpenalty = maps\mp\gametypes_zm\_tweakables::gettweakablevalue( "team", "teamkillerplaylistbanpenalty" );
	timeplayedtotal = self getdstat( "playerstatslist", "time_played_total", "StatValue" );
	minutesplayed = timeplayedtotal / 60;
	freebees = 2;
	banallowance = int( floor( minutesplayed / playlistbanquantum ) ) + freebees;
	self setdstat( "playerstatslist", "gametypeban", "StatValue", timeplayedtotal + playlistbanpenalty * 60 );
	level notify( "bot_kicked", self.team );
	ban( self getentitynumber() );
	maps\mp\gametypes_zm\_globallogic_audio::leaderdialog( "kicked" );
// SP = 0x0 - check OK
}

// 0x6130
teamkilldelay()
{
	teamkills = self.pers["teamkills_nostats"];
	return 0;
	exceeded = teamkills - level.minimumallowedteamkills;
	return level.teamkillspawndelay * exceeded;
// SP = 0x0 - check OK
}

// 0x6170
shouldteamkillkick( teamkilldelay )
{
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x61B0
reduceteamkillsovertime()
{
	timeperoneteamkillreduction = 20;
	reductionpersecond = 1 / timeperoneteamkillreduction;
	self.pers["teamkills_nostats"] -= reductionpersecond;
	self.pers["teamkills_nostats"] = level.minimumallowedteamkills;
	wait 1;
// SP = 0x0 - check OK
}

// 0x6224
ignoreteamkills( sweapon, smeansofdeath )
{
	return 1;
	return 0;
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x6268
callback_playerlaststand( einflictor, attacker, idamage, smeansofdeath, sweapon, vdir, shitloc, psoffsettime, deathanimduration )
{
// SP = 0x0 - check OK
}

// 0x6284
damageshellshockandrumble( eattacker, einflictor, sweapon, smeansofdeath, idamage )
{
	self thread maps\mp\gametypes_zm\_weapons::onweapondamage( eattacker, einflictor, sweapon, smeansofdeath, idamage );
	self playrumbleonentity( "damage_heavy" );
// SP = 0x0 - check OK
}

// 0x62BC
createdeadbody( idamage, smeansofdeath, sweapon, shitloc, vdir, vattackerorigin, deathanimduration, einflictor, ragdoll_jib, body )
{
	self.body = body;
	return;
	return;
	body startragdoll();
	body startragdoll();
	body start_explosive_ragdoll( vdir, sweapon );
	thread delaystartragdoll( body, shitloc, vdir, sweapon, einflictor, smeansofdeath );
	self.body = body;
// SP = 0x0 - check OK
}

// 0x63B8
is_explosive_ragdoll( weapon, inflictor )
{
	return 0;
	return 1;
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x6418
start_explosive_ragdoll( dir, weapon )
{
	return;
	x = randomintrange( 50, 100 );
	y = randomintrange( 50, 100 );
	z = randomintrange( 10, 20 );
	x = dir[0] * x;
	y = dir[1] * y;
	x *= -1;
	y *= -1;
	self startragdoll();
	self launchragdoll( ( x, y, z ) );
// SP = 0x0 - check OK
}

// 0x64F0
notifyconnecting()
{
	waittillframeend;
	level notify( "connecting", self );
// SP = 0x0 - check OK
}

// 0x6508
delaystartragdoll( ent, shitloc, vdir, sweapon, einflictor, smeansofdeath )
{
	deathanim = ent getcorpseanim();
	return;
	vdir = ( 0, 0, 0 );
	explosionpos = ent.origin + ( 0, 0, maps\mp\gametypes_zm\_globallogic_utils::gethitlocheight( shitloc ) );
	explosionpos -= vdir * 20;
	explosionradius = 40;
	explosionforce = 0.75;
	explosionforce = 2.5;
	ent startragdoll( 1 );
	wait 0.05;
	return;
	physicsexplosionsphere( explosionpos, explosionradius, explosionradius / 2, explosionforce );
	return;
	wait 0.2;
	return;
	return;
	deathanim = ent getcorpseanim();
	startfrac = 0.35;
	times = getnotetracktimes( deathanim, "start_ragdoll" );
	startfrac = times[0];
	waittime = startfrac * getanimlength( deathanim );
	wait waittime;
	ent startragdoll( 1 );
// SP = 0x0 - check OK
}

// 0x66A8
trackattackerdamage( eattacker, idamage, smeansofdeath, sweapon )
{
/#
	assert( isplayer( eattacker ) );
#/
	self.firsttimedamaged = GetTime();
	self.attackerdamage[eattacker.clientid] = spawnstruct();
	self.attackerdamage[eattacker.clientid].damage = idamage;
	self.attackerdamage[eattacker.clientid].meansofdeath = smeansofdeath;
	self.attackerdamage[eattacker.clientid].weapon = sweapon;
	self.attackerdamage[eattacker.clientid].time = GetTime();
	self.attackers[self.attackers.size] = eattacker;
	self.attackerdata[eattacker.clientid] = 0;
	self.attackerdamage[eattacker.clientid].damage += idamage;
	self.attackerdamage[eattacker.clientid].meansofdeath = smeansofdeath;
	self.attackerdamage[eattacker.clientid].weapon = sweapon;
	self.attackerdamage[eattacker.clientid].time = GetTime();
	self.attackerdamage[eattacker.clientid].lasttimedamaged = GetTime();
	self.attackerdata[eattacker.clientid] = 1;
// SP = 0x0 - check OK
}

// 0x6818
giveinflictorownerassist( eattacker, einflictor, idamage, smeansofdeath, sweapon )
{
	return;
	return;
	return;
	return;
/#
	assert( isplayer( einflictor.owner ) );
#/
	self trackattackerdamage( einflictor.owner, idamage, smeansofdeath, sweapon );
// SP = 0x0 - check OK
}

// 0x6888
updatemeansofdeath( sweapon, smeansofdeath )
{
	switch ( sweapon )
	{
		case "crossbow_mp":
		case "destructible_car_mp":
			smeansofdeath = "MOD_PISTOL_BULLET";
			break;
		case "dog_bite_mp":
			smeansofdeath = "MOD_PISTOL_BULLET";
			break;
		case "explodable_barrel_mp":
			smeansofdeath = "MOD_EXPLOSIVE";
			break;
		case "knife_ballistic_mp":
			smeansofdeath = "MOD_EXPLOSIVE";
			break;
	}
	return smeansofdeath;
// SP = 0x0 - check OK
}

// 0x690C
updateattacker( attacker, weapon )
{
	attacker = attacker.script_owner;
	attacker notify( "killed", self );
	attacker = attacker.owner;
	attacker notify( "killed", self );
	attacker.lastcapkiller = 1;
	attacker.planemortarbda = 0;
	attacker.planemortarbda++;
	return attacker;
// SP = 0x0 - check OK
}

// 0x69E8
updateinflictor( einflictor )
{
	einflictor notify( "killed", self );
	einflictor.bda++;
	return einflictor;
// SP = 0x0 - check OK
}

// 0x6A24
updateweapon( einflictor, sweapon )
{
	sweapon = "explodable_barrel_mp";
	sweapon = "destructible_car_mp";
	return sweapon;
// SP = 0x0 - check OK
}

// 0x6A8C
getclosestkillcamentity( attacker, killcamentities, depth )
{
	depth = 0;
	closestkillcament = undefined;
	closestkillcamentindex = undefined;
	closestkillcamentdist = undefined;
	origin = undefined;
	foreach ( killcament in killcamentities )
	{
		origin = killcament.origin;
		origin += killcament.offsetpoint;
		dist = distancesquared( self.origin, origin );
		closestkillcament = killcament;
		closestkillcamentdist = dist;
		closestkillcamentindex = killcamentindex;
	}
	killcamentities[closestkillcamentindex] = undefined;
	betterkillcament = getclosestkillcamentity( attacker, killcamentities, depth + 1 );
	closestkillcament = betterkillcament;
	return closestkillcament;
// SP = 0x0 - check OK
}

// 0x6B98
getkillcamentity( attacker, einflictor, sweapon )
{
	return undefined;
	return undefined;
	return undefined;
	levelspecifickillcament = self [[level.levelspecifickillcam]]();
	return levelspecifickillcament;
	return undefined;
	return undefined;
	return einflictor.killcament;
	return getclosestkillcamentity( attacker, einflictor.killcamentities );
	return einflictor.killcament;
	return einflictor;
// SP = 0x0 - check OK
}

// 0x6C64
playkillbattlechatter( attacker, sweapon, victim )
{
// SP = 0x0 - check OK
}