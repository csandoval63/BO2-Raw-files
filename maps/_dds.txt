// maps/_dds.gsc

#include animscripts\combat_utility;
#include animscripts\face;
#include maps\_utility;
#include animscripts\utility;
#include common_scripts\utility;


// 0x1D90
dds_init()
{
	level.dds = spawnstruct();
	level.dds.heartbeat = 0.25;
	level.dds.max_active_events = 6;
	level.dds.variant_limit = 17;
	level.dds.category_backoff_limit = 2;
	level.dds.scripted_line_delay = 2;
	level.dds.response_distance_min = 500;
	level.dds.history = [];
	level.dds.history_count = 15;
	level.dds.history_index = 0;
	level.dds.player_character_name = "mas";
	level.dds.event_override_name = undefined;
	level.dds.event_override_probability = 0.5;
	level.dds.response_wait = 0.25;
	level.dds.response_wait_axis = 0.25;
	init_dds_countryids();
	init_dds_flags();
	init_dds_categories();
	init_dds_categories_axis();
	init_dds_active_events();
/#
	level.debug_dds_on = GetDvar( #"0x38E629E6" );
	level thread dds_debug();
#/
// SP = 0x0 - check OK
}

// 0x1EA4
init_dds_countryids( voice, dds_label )
{
	level.dds.characterid_count = 0;
	level.dds.character_names = [];
	level.dds.character_names["allies"] = array( "american", "russian", "russian_english", "yemeni", "lapd", "secretservice", "unita", "mujahideen", "pdf" );
	level.dds.character_names["axis"] = array( "digbat", "american", "russian", "unita", "cuban", "mujahideen", "pdf", "pmc", "isi", "terrorist", "chinese" );
	level.dds.character_names["default"] = arraycombine( level.dds.character_names["allies"], level.dds.character_names["axis"], 1, 0 );
	level.dds.countryids = [];
	add_dds_countryid( "american", "us", 2 );
	add_dds_countryid( "russian", "ru", 2 );
	add_dds_countryid( "unita", "mp", 2 );
	add_dds_countryid( "cuban", "pm", 3 );
	add_dds_countryid( "mujahideen", "mu", 2 );
	add_dds_countryid( "pdf", "pm", 3 );
	add_dds_countryid( "pmc", "pm", 3 );
	add_dds_countryid( "isi", "is", 2 );
	add_dds_countryid( "digbat", "pm", 3 );
	add_dds_countryid( "yemeni", "tr", 2 );
	add_dds_countryid( "terrorist", "tr", 2 );
	add_dds_countryid( "lapd", "la", 2 );
	add_dds_countryid( "secretservice", "us", 2 );
	add_dds_countryid( "chinese", "ch", 2 );
// SP = 0x0 - check OK
}

// 0x2098
add_dds_countryid( voice, dds_label, max_voices )
{
	level.dds.countryids[voice] = spawnstruct();
	level.dds.countryids[voice].label = dds_label;
	level.dds.countryids[voice].count = 0;
	level.dds.countryids[voice].max_voices = max_voices;
// SP = 0x0 - check OK
}

// 0x20F4
init_dds_flags()
{
	flag_init( "dds_running_allies" );
	level thread dds_send_team_notify_on_disable( "allies" );
	flag_init( "dds_running_axis" );
	level thread dds_send_team_notify_on_disable( "axis" );
// SP = 0x0 - check OK
}

// 0x2134
init_dds_categories()
{
	level.dds.categories = [];
	add_dds_category( "react_grenade", "react_grenade", 1.25, "grenade_rspns", 1, ::dds_sort_ent_dist, ::get_nearest, 3000, 0.8, 1.5, 0 );
	add_dds_category( "react_emp", "react_emp", 1.25, "", 1, ::dds_sort_ent_dist, ::get_nearest, 3000, 0.8, 1.5, 0 );
	add_dds_category( "react_sniper", "react_sniper", 1.25, "", 1, ::dds_sort_ent_dist, ::get_nearest, 3000, 0.4, 26.5, 0 );
	add_dds_category( "rspns_neg", "rspns_neg", 1.5, "", 1, ::dds_sort_ent_dist, ::get_self_ent, 2500, 0.05, 4.5, 0 );
	add_dds_category( "thrt_acquired", "thrt_acquired", 0.5, "", 1, ::dds_sort_ent_dist, ::get_self_ent, 5000, 0.3, 16.5, 0 );
	add_dds_category( "kill_confirm", "act_kill_confirm", 2, "rspns_killfirm", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2500, 0.3, 6.5, 0 );
	add_dds_category( "headshot", "act_kill_confirm", 0.75, "rspns_killfirm", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2500, 0.3, 7, 0 );
	add_dds_category( "rspns_killfirm", "rspns_killfirm", 0.75, "", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2500, 0.3, 7, 0 );
	add_dds_category( "rspns_movement", "rspns_movement", 0.5, "", 1, ::dds_sort_ent_dist, ::get_self_ent, 4000, 0.2, 13.5, 0 );
	add_dds_category( "react_move", "react_move", 0.5, "rspns_movement", 1, ::dds_sort_ent_dist, ::get_self_ent, 5000, 0.3, 16.5, 0 );
	add_dds_category( "fragout", "act_fragout", 0.75, "rspns_act", 1, ::dds_sort_ent_dist, ::get_self_ent, 4000, 0.8, 1.5, 0 );
	add_dds_category( "empout", "act_empout", 0.5, "rspns_act", 1, ::dds_sort_ent_dist, ::get_self_ent, 4000, 0.7, 1.5, 0 );
	add_dds_category( "smokeout", "act_smokeout", 0.5, "rspns_act", 1, ::dds_sort_ent_dist, ::get_self_ent, 4000, 0.7, 1.5, 0 );
	add_dds_category( "react_cover", "react_cover", 1.5, "", 1, ::dds_sort_ent_dist, ::get_self_ent, 2500, 0.1, 4.5, 0 );
	add_dds_category( "thrt_dist10", "thrt_dist10", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_self_ent, 3000, 0.2, 15, 0 );
	add_dds_category( "thrt_dist20", "thrt_dist20", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_self_ent, 3000, 0.2, 15, 0 );
	add_dds_category( "thrt_dist30", "thrt_dist30", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_self_ent, 3000, 0.2, 15, 0 );
	add_dds_category( "thrt_dist40", "thrt_dist40", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_self_ent, 3000, 0.2, 15, 0 );
	add_dds_category( "thrt_open", "thrt_open", 0.5, "rspns_suppress", 1, ::dds_sort_ent_dist, ::get_self_ent, 2000, 0.1, 18, 0 );
	add_dds_category( "thrt_movement", "thrt_movement", 0.5, "thrt_rspns", 1, ::dds_sort_ent_dist, ::get_self_ent, 2000, 0.1, 18, 0 );
	add_dds_category( "thrt_breaking", "thrt_breaking", 0.5, "rspns_lm", 1, ::dds_sort_ent_dist, ::get_nearest, 2000, 0.1, 7.5, 0 );
	add_dds_category( "rspns_act", "rspns_act", 0.5, "", 1, ::dds_sort_ent_dist, ::get_nearest, 2000, 0.2, 4, 0 );
	add_dds_category( "thrt_clock1", "thrt_clock1", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category( "thrt_clock10", "thrt_clock10", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category( "thrt_clock11", "thrt_clock11", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category( "thrt_clock12", "thrt_clock12", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category( "thrt_clock2", "thrt_clock2", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category( "thrt_clock3", "thrt_clock3", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category( "thrt_clock4", "thrt_clock4", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category( "thrt_clock5", "thrt_clock5", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category( "thrt_clock6", "thrt_clock6", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category( "thrt_clock7", "thrt_clock7", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category( "thrt_clock8", "thrt_clock8", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category( "thrt_clock9", "thrt_clock9", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category( "rspns_suppress", "react_suppress", 0.5, "", 1, ::dds_sort_ent_dist, ::get_nearest, 2000, 0.8, 14, 0 );
	add_dds_category( "thrt", "thrt_acquired", 0.5, "rspns_act", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.2, 5, 1 );
	add_dds_category( "rspns_lm", "rspns_thrt", 0.5, "", 1, ::dds_sort_ent_dist, ::get_nearest, 2000, 0.7, 3.5, 1 );
	add_dds_category( "casualty", "react_casualty", 0.55, "", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2800, 0.2, 16, 0 );
	add_dds_category( "reload", "act_reload", 2, "action_rspns", 1, ::dds_sort_ent_dist, ::get_self_ent, 5000, 0.3, 3.5, 0 );
	add_dds_category( "kill_melee", "kill_melee", 0.75, "", 1, ::dds_sort_ent_dist, ::get_attacker, 400, 1, 3.5, 0 );
// SP = 0x0 - check OK
}

// 0x2ADC
init_dds_categories_axis()
{
	level.dds.categories_axis = [];
	add_dds_category_axis( "react_grenade", "react_grenade", 1.25, "grenade_rspns", 1, ::dds_sort_ent_dist, ::get_nearest, 3000, 0.8, 1.5, 0 );
	add_dds_category_axis( "react_emp", "react_emp", 1.25, "", 1, ::dds_sort_ent_dist, ::get_nearest, 3000, 0.8, 1.5, 0 );
	add_dds_category_axis( "react_sniper", "react_sniper", 1.25, "", 1, ::dds_sort_ent_dist, ::get_nearest, 3000, 0.4, 26.5, 0 );
	add_dds_category_axis( "rspns_neg", "rspns_neg", 1.5, "", 1, ::dds_sort_ent_dist, ::get_self_ent, 2500, 0.05, 4.5, 0 );
	add_dds_category_axis( "thrt_acquired", "thrt_acquired", 0.5, "", 1, ::dds_sort_ent_dist, ::get_self_ent, 5000, 0.3, 16.5, 0 );
	add_dds_category_axis( "kill_confirm", "act_kill_confirm", 2, "rspns_killfirm", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2500, 0.3, 6.5, 0 );
	add_dds_category_axis( "headshot", "act_kill_confirm", 0.75, "rspns_killfirm", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2500, 0.3, 7, 0 );
	add_dds_category_axis( "rspns_killfirm", "rspns_killfirm", 0.75, "", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2500, 0.3, 7, 0 );
	add_dds_category_axis( "rspns_movement", "rspns_movement", 0.5, "", 1, ::dds_sort_ent_dist, ::get_self_ent, 4000, 0.2, 13.5, 0 );
	add_dds_category_axis( "react_move", "react_move", 0.5, "rspns_movement", 1, ::dds_sort_ent_dist, ::get_self_ent, 5000, 0.3, 16.5, 0 );
	add_dds_category_axis( "fragout", "act_fragout", 0.75, "rspns_act", 1, ::dds_sort_ent_dist, ::get_self_ent, 4000, 0.8, 1.5, 0 );
	add_dds_category_axis( "empout", "act_empout", 0.5, "rspns_act", 1, ::dds_sort_ent_dist, ::get_self_ent, 4000, 0.7, 1.5, 0 );
	add_dds_category_axis( "smokeout", "act_smokeout", 0.5, "rspns_act", 1, ::dds_sort_ent_dist, ::get_self_ent, 4000, 0.7, 1.5, 0 );
	add_dds_category_axis( "react_cover", "react_cover", 1.5, "", 1, ::dds_sort_ent_dist, ::get_self_ent, 2500, 0.1, 4.5, 0 );
	add_dds_category_axis( "thrt_dist10", "thrt_dist10", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_self_ent, 3000, 0.2, 15, 0 );
	add_dds_category_axis( "thrt_dist20", "thrt_dist20", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_self_ent, 3000, 0.2, 15, 0 );
	add_dds_category_axis( "thrt_dist30", "thrt_dist30", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_self_ent, 3000, 0.2, 15, 0 );
	add_dds_category_axis( "thrt_dist40", "thrt_dist40", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_self_ent, 3000, 0.2, 15, 0 );
	add_dds_category_axis( "thrt_open", "thrt_open", 0.5, "rspns_suppress", 1, ::dds_sort_ent_dist, ::get_self_ent, 2000, 0.1, 18, 0 );
	add_dds_category_axis( "thrt_movement", "thrt_movement", 0.5, "thrt_rspns", 1, ::dds_sort_ent_dist, ::get_self_ent, 2000, 0.1, 18, 0 );
	add_dds_category_axis( "thrt_breaking", "thrt_breaking", 0.5, "rspns_lm", 1, ::dds_sort_ent_dist, ::get_nearest, 2000, 0.1, 7.5, 0 );
	add_dds_category_axis( "rspns_act", "rspns_act", 0.5, "", 1, ::dds_sort_ent_dist, ::get_nearest, 2000, 0.2, 4, 0 );
	add_dds_category_axis( "thrt_clock1", "thrt_clock1", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category_axis( "thrt_clock10", "thrt_clock10", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category_axis( "thrt_clock11", "thrt_clock11", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category_axis( "thrt_clock12", "thrt_clock12", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category_axis( "thrt_clock2", "thrt_clock2", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category_axis( "thrt_clock3", "thrt_clock3", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category_axis( "thrt_clock4", "thrt_clock4", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category_axis( "thrt_clock5", "thrt_clock5", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category_axis( "thrt_clock6", "thrt_clock6", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category_axis( "thrt_clock7", "thrt_clock7", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category_axis( "thrt_clock8", "thrt_clock8", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category_axis( "thrt_clock9", "thrt_clock9", 0.5, "react_cover", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.1, 5, 1 );
	add_dds_category_axis( "rspns_suppress", "react_suppress", 0.5, "", 1, ::dds_sort_ent_dist, ::get_nearest, 2000, 0.8, 14, 0 );
	add_dds_category_axis( "thrt", "thrt_acquired", 0.5, "rspns_act", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2000, 0.2, 5, 1 );
	add_dds_category_axis( "rspns_lm", "rspns_thrt", 0.5, "", 1, ::dds_sort_ent_dist, ::get_nearest, 2000, 0.7, 3.5, 1 );
	add_dds_category_axis( "casualty", "react_casualty", 0.55, "", 1, ::dds_sort_ent_dist, ::get_nearest_not_plr, 2800, 0.2, 16, 0 );
	add_dds_category_axis( "reload", "act_reload", 2, "action_rspns", 1, ::dds_sort_ent_dist, ::get_self_ent, 5000, 0.3, 3.5, 0 );
	add_dds_category_axis( "kill_melee", "kill_melee", 0.75, "", 1, ::dds_sort_ent_dist, ::get_attacker, 400, 1, 3.5, 0 );
// SP = 0x0 - check OK
}

// 0x3484
add_dds_category( name, alias_name, duration, rspns_cat_name, clear_category_on_action_success, priority_sort, get_talker_func, distance, probability, timeout_reset, should_squelch )
{
	new_category = spawnstruct();
	new_category.name = name;
	new_category.alias_name = alias_name;
	new_category.duration = duration;
	new_category.priority_sort = priority_sort;
	new_category.probability = probability;
	new_category.get_talker_func = get_talker_func;
	new_category.speaker_distance = distance;
	new_category.last_time = GetTime();
	new_category.backoff_count = 0;
	new_category.timeout = randomint( 10 );
	new_category.last_timeout = new_category.timeout;
	new_category.timeout_reset = timeout_reset;
	new_category.rspns_cat_name = rspns_cat_name;
	new_category.clear_on_action_success = clear_category_on_action_success;
	new_category.should_squelch = should_squelch;
	level.dds.categories[level.dds.categories.size] = new_category;
// SP = 0x0 - check OK
}

// 0x3568
add_dds_category_axis( name, alias_name, duration, rspns_cat_name, clear_category_on_action_success, priority_sort, get_talker_func, distance, probability, timeout_reset, notused )
{
	new_category_axis = spawnstruct();
	new_category_axis.name = name;
	new_category_axis.alias_name = alias_name;
	new_category_axis.duration = duration;
	new_category_axis.priority_sort = priority_sort;
	new_category_axis.probability = probability;
	new_category_axis.get_talker_func = get_talker_func;
	new_category_axis.speaker_distance = distance;
	new_category_axis.last_time = GetTime();
	new_category_axis.backoff_count = 0;
	new_category_axis.timeout = randomint( 10 );
	new_category_axis.last_timeout = new_category_axis.timeout;
	new_category_axis.timeout_reset = timeout_reset;
	new_category_axis.rspns_cat_name = rspns_cat_name;
	new_category_axis.clear_on_action_success = clear_category_on_action_success;
	level.dds.categories_axis[level.dds.categories_axis.size] = new_category_axis;
// SP = 0x0 - check OK
}

// 0x3640
init_dds_active_events()
{
	level.dds.active_events = [];
	level.dds.active_events_axis = [];
	i = 0;
	level.dds.active_events[level.dds.categories[i].name] = [];
	i++;
	i = 0;
	level.dds.active_events_axis[level.dds.categories_axis[i].name] = [];
	i++;
// SP = 0x0 - check OK
}

// 0x36CC
dds_clear_old_expired_events()
{
	i = 0;
	category = level.dds.categories[i];
	j = 0;
	level.dds.active_events[category.name][j].duration -= level.dds.heartbeat;
	arrayremovevalue( level.dds.active_events[category.name], level.dds.active_events[category.name][j] );
	j++;
	i++;
// SP = 0x0 - check OK
}

// 0x37BC
dds_clear_old_expired_events_axis()
{
	i = 0;
	category = level.dds.categories_axis[i];
	j = 0;
	level.dds.active_events_axis[category.name][j].duration -= level.dds.heartbeat;
	arrayremovevalue( level.dds.active_events_axis[category.name], level.dds.active_events_axis[category.name][j] );
	j++;
	i++;
// SP = 0x0 - check OK
}

// 0x38AC
dds_clear_all_queued_events()
{
	i = 0;
	j = 0;
	level.dds.active_events[level.dds.categories[i].name] = [];
	j++;
	i++;
// SP = 0x0 - check OK
}

// 0x3918
dds_clear_all_queued_events_axis()
{
	i = 0;
	j = 0;
	level.dds.active_events_axis[level.dds.categories_axis[i].name] = [];
	j++;
	i++;
// SP = 0x0 - check OK
}

// 0x3984
dds_main_process()
{
	return;
	flag_set( "dds_running_allies" );
	dds_find_threats( "allies", "axis" );
	should_delay_dds = 0;
	dds_clear_old_expired_events();
	should_delay_dds = 1;
	wait level.dds.heartbeat;
	wait level.dds.scripted_line_delay;
	dds_clear_all_queued_events();
	should_delay_dds = 0;
	wait level.dds.heartbeat;
	wait 0.1;
// SP = 0x0 - check OK
}

// 0x3A3C
dds_main_process_axis()
{
	return;
	flag_set( "dds_running_axis" );
	dds_find_threats( "axis", "allies" );
	should_delay_dds = 0;
	dds_clear_old_expired_events_axis();
	should_delay_dds = 1;
	wait level.dds.heartbeat;
	wait level.dds.scripted_line_delay;
	dds_clear_all_queued_events_axis();
	should_delay_dds = 0;
	wait level.dds.heartbeat;
	wait 0.1;
// SP = 0x0 - check OK
}

// 0x3AF4
dds_find_threats( us, them )
{
	level thread dds_find_infantry_threat( us, them );
// SP = 0x0 - check OK
}

// 0x3B10
dds_enable( team )
{
	level thread dds_main_process();
	level thread dds_main_process_axis();
	level thread dds_main_process();
	level thread dds_main_process_axis();
// SP = 0x0 - check OK
}

// 0x3B68
dds_disable( team )
{
	dds_clear_all_queued_events();
	flag_clear( "dds_running_allies" );
	dds_clear_all_queued_events_axis();
	flag_clear( "dds_running_axis" );
	switch ( team )
	{
		case "allies":
			dds_clear_all_queued_events_axis();
			flag_clear( "dds_running_axis" );
			break;
		case "axis":
			dds_clear_all_queued_events();
			flag_clear( "dds_running_allies" );
			break;
		default:
/#
			println( "unknown team: " + team + " to disable dds." );
#/
			break;
	}
// SP = 0x0 - check OK
}

// 0x3C1C
dds_send_team_notify_on_disable( team )
{
	flag_waitopen( "dds_running_" + team );
	level notify( "dds_running_" + team );
	flag_wait( "dds_running_" + team );
// SP = 0x0 - check OK
}

// 0x3C5C
is_dds_enabled()
{
	return 0;
	return 1;
// SP = 0x0 - check OK
}

// 0x3C90
exponent( base, power )
{
/#
	assert( power >= 0 );
#/
	return 1;
	return base * exponent( base, power - 1 );
// SP = 0x0 - check OK
}

// 0x3CCC
dds_process_active_events()
{
	i = 0;
	category = level.dds.categories[i];
/#
	debug_update_timeouts( category.name, category.timeout, category.last_timeout, 1 );
#/
	category.timeout -= level.dds.heartbeat;
	level.dds.active_events[category.name] = [[category.priority_sort]]( level.dds.active_events[category.name] );
	j = 0;
/#
	debug_active_event_stat( category.name, "probability_skipped", 1 );
#/
	level.dds.active_events[category.name][j].clear_event_on_prob = 1;
	category.timeout = category.timeout_reset;
	category.backoff_count++;
	category.backoff_count = level.dds.category_backoff_limit;
	category.backoff_count--;
	category.backoff_count = 0;
	category.timeout = category.timeout_reset * exponent( 2, category.backoff_count ) + randomint( 2 );
	category.last_timeout = category.timeout;
	category.last_time = GetTime();
/#
	debug_reset_timeouts( category.name, category.timeout, category.last_timeout, category.last_time, 1 );
#/
/#
	debug_sphere_draw_type( "process", category.name, level.dds.active_events[category.name][j], undefined );
#/
	level.dds.active_events[category.name] = [];
	return 1;
	wait level.dds.heartbeat;
	j++;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x3FBC
dds_process_active_events_axis()
{
	i = 0;
	category = level.dds.categories_axis[i];
/#
	debug_update_timeouts( category.name, category.timeout, category.last_timeout, 0 );
#/
	category.timeout -= level.dds.heartbeat;
	level.dds.active_events_axis[category.name] = [[category.priority_sort]]( level.dds.active_events_axis[category.name] );
	j = 0;
/#
	debug_active_event_stat( category.name, "probability_skipped", 0 );
#/
	level.dds.active_events_axis[category.name][j].clear_event_on_prob = 1;
	category.timeout = category.timeout_reset;
	category.backoff_count++;
	category.backoff_count = level.dds.category_backoff_limit;
	category.backoff_count--;
	category.backoff_count = 0;
	category.timeout = category.timeout_reset * exponent( 2, category.backoff_count ) + randomint( 2 );
	category.last_timeout = category.timeout;
	category.last_time = GetTime();
/#
	debug_reset_timeouts( category.name, category.timeout, category.last_timeout, category.last_time, 0 );
#/
/#
	debug_sphere_draw_type( "process", category.name, level.dds.active_events_axis[category.name][j], undefined );
#/
	level.dds.active_events_axis[category.name] = [];
	return 1;
	wait level.dds.heartbeat;
	j++;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x42A0
dds_event_activate( event, get_talker_func, distance, rspns_cat_name, should_squelch )
{
/#
	iprintlnbold( "event not defined\n" );
#/
	return 0;
	category_name = event.category_name;
	category_name = event.category_response_name;
	talker = event [[get_talker_func]]( IsDefined( event.category_response_name ), distance );
/#
	debug_active_event_stat( category_name, "no_one_to_talk_count", event.isalliesline );
#/
	event.processed = 1;
	return 0;
	phrase = dds_get_alias_from_event( talker, event.category_alias_name, event.ent );
	return 0;
	wait level.dds.response_wait;
	wait level.dds.response_wait_axis;
/#
	print_dds = getdvarintdefault( "dds_usingDebug", 0 );
	talker thread debug_print_dialogue( phrase );
	debug_active_event_stat( category_name, "processed_count", event.isalliesline );
	debug_sphere_draw_type( "speaker", category_name, event, talker );
#/
	should_squelch = 0;
	talker animscripts\face::playfacethread( undefined, "dds_squelch_strt", 0.5, "dds_squelch_strt" );
	talker animscripts\face::playfacethread( undefined, phrase, 0.5, phrase );
	talker animscripts\face::playfacethread( undefined, "dds_squelch_end", 0.5, "dds_squelch_end" );
	event.talker = talker;
	event.talker_origin = talker.origin;
	event.phrase = phrase;
	event.processed = 1;
	add_phrase_to_history( phrase );
	dds_notify_response( event, talker, phrase, rspns_cat_name );
	return 1;
// SP = 0x0 - check OK
}

// 0x4510
add_phrase_to_history( phrase )
{
	level.dds.history[level.dds.history_index] = phrase;
	level.dds.history_index = ( level.dds.history_index + 1 ) % level.dds.history_count;
// SP = 0x0 - check OK
}

// 0x454C
get_nearest_common( response, player_can_say_line, distance )
{
	player = get_players()[0];
	ai_array = getaiarray( "allies" );
	ai_array[ai_array.size] = player;
	ai_array = getaiarray( "axis" );
	return undefined;
	ai_array = remove_all_actors_that_are_squelched( ai_array );
	ai_array = remove_all_actors_with_same_characterid( ai_array, self.talker.dds_characterid );
	closest_ent = get_closest_living( self.talker.origin, ai_array );
	closest_ent = get_closest_living( self.ent_origin, ai_array );
	return undefined;
	dis_sq_from_player = distancesquared( player.origin, closest_ent.origin );
	return undefined;
	return undefined;
	return closest_ent;
// SP = 0x0 - check OK
}

// 0x4658
remove_all_actors_that_are_squelched( ai_array )
{
	non_squelched = [];
	foreach ( ai in ai_array )
	{
		non_squelched[non_squelched.size] = ai;
	}
	return non_squelched;
// SP = 0x0 - check OK
}

// 0x46A8
remove_all_actors_with_same_characterid( ai_array, talker_characterid )
{
	i = 0;
	arrayremovevalue( ai_array, ai_array[i] );
	arrayremovevalue( ai_array, ai_array[i] );
	i++;
	return ai_array;
// SP = 0x0 - check OK
}

// 0x4714
get_nearest( response, distance )
{
	return get_nearest_common( response, 1, distance );
// SP = 0x0 - check OK
}

// 0x4730
get_nearest_not_plr( response, distance )
{
	return get_nearest_common( response, 0, distance );
// SP = 0x0 - check OK
}

// 0x474C
get_attacker( response, distance )
{
	return undefined;
/#
	println( "^5 killed by a vehicle" );
#/
	return undefined;
	return self.ent_attacker;
	return undefined;
// SP = 0x0 - check OK
}

// 0x47CC
get_self_ent( response, distance )
{
	return self.ent;
	return undefined;
// SP = 0x0 - check OK
}

// 0x47F8
dds_get_alias_from_event( talker, category_alias_name, event_ent )
{
/#
	println( "talker is dead" );
#/
	return undefined;
/#
	println( "character name could not be found for this speaker." );
#/
	return undefined;
	alias = "dds_" + talker.dds_characterid + "_" + category_alias_name + "_";
	qualifier = event_ent get_landmark_qualifier( alias );
	alias += qualifier + "_";
	variant_num = 0;
	variant_count_array = dds_variant_count_for_alias( alias );
	i = 0;
	variant_num = random( variant_count_array );
	temp_alias = alias;
	temp_alias += "0";
	temp_alias += variant_num;
	return temp_alias;
	i++;
/#
	missing_dds = getdvarintdefault( "dds_usingDebug", 0 );
	println( "^5 did not find an alias: '" + alias + "'" );
#/
	return undefined;
/#
	missing_dds = getdvarintdefault( "dds_usingDebug", 0 );
	println( "^6all variants for alias: '" + alias + "' are in the phrase history." );
#/
	return undefined;
// SP = 0x0 - check OK
}

// 0x497C
is_phrase_in_history( phrase )
{
	i = 0;
	return 1;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x49B8
dds_variant_count_for_alias( alias )
{
	variant_count_array = [];
	i = 0;
	prefix = "";
	prefix = "0";
	variant_count_array[variant_count_array.size] = i;
	i++;
	return variant_count_array;
// SP = 0x0 - check OK
}

// 0x4A1C
get_landmark_qualifier( alias )
{
	lm_script_area = undefined;
	lm_script_area_origin = undefined;
	nodearray = getanynodearray( self.origin, 100 );
	i = 0;
	lm_script_area = nodearray[i].script_area;
	lm_script_area_origin = nodearray[i].origin;
	i++;
	lm_script_area = self.node.script_area;
	lm_script_area_origin = self.node.origin;
	return undefined;
	return lm_script_area;
	return undefined;
// SP = 0x0 - check OK
}

// 0x4B08
get_event_override( alias )
{
	return level.dds.event_override_name;
	return undefined;
// SP = 0x0 - check OK
}

// 0x4B5C
dds_find_infantry_threat( us, them )
{
	player = get_players()[0];
	our_team = getaiarray( us );
	other_team = getaiarray( them );
	success = 0;
	i = 0;
	j = 0;
	other_team[j] dds_threat_notify( them != "allies" );
	success = 1;
	j++;
	i++;
	wait 2;
// SP = 0x0 - check OK
}

// 0x4C94
dds_getclock_position( pos )
{
	return;
	playerangles = level.player getplayerangles();
	playerforwardvec = anglestoforward( playerangles );
	playerunitforwardvec = vectornormalize( playerforwardvec );
	playerpos = level.player getorigin();
	playertobanzaivec = pos - playerpos;
	playertobanzaiunitvec = vectornormalize( playertobanzaivec );
	forwarddotbanzai = vectordot( playerunitforwardvec, playertobanzaiunitvec );
	anglefromcenter = acos( forwarddotbanzai );
	crossplayerenemy = vectorcross( playerunitforwardvec, playertobanzaiunitvec );
	dir = vectordot( crossplayerenemy, anglestoup( playerangles ) );
	anglefromcenter *= -1;
	a = anglefromcenter + 180;
	hour = 6;
	i = 15;
	hour -= 1;
	hour = 12;
	i += 30;
	return hour;
// SP = 0x0 - check OK
}

// 0x4DA0
dds_threat_notify( isalliesline )
{
	return;
	aipos = self.origin;
	playerpos = level.player.origin;
	distance = distancesquared( playerpos, aipos );
	self dds_notify( "thrt_dist10", isalliesline );
	self dds_notify( "thrt_dist20", isalliesline );
	self dds_notify( "thrt_dist30", isalliesline );
	self dds_notify( "thrt_open", isalliesline );
	oclock = dds_getclock_position( aipos );
	self dds_notify( "thrt_clock" + oclock, isalliesline );
// SP = 0x0 - check OK
}

// 0x4E78
player_init()
{
/#
	println( "dds::player_init not called on a player; did not set up dds player flags and threads." );
#/
	return;
	self.iskillstreaktimerrunning = 0;
	self.killstreakcounter = 0;
	self ent_flag_init( "dds_killstreak" );
	self ent_flag_init( "dds_low_health" );
	self thread dds_killstreak_timer();
	self thread dds_watch_player_health();
	self thread dds_multikill_tracker();
	self.dds_characterid = level.dds.player_character_name;
// SP = 0x0 - check OK
}

// 0x4EFC
dds_multikill_tracker()
{
	self endon( "death" );
	self endon( "disconnect" );
	level flag_wait( "dds_running_" + self.team );
	self waittill( "multikill" );
	self dds_notify( "multikill", self.team == "allies" );
// SP = 0x0 - check OK
}

// 0x4F48
dds_watch_player_health()
{
	self endon( "death" );
	self endon( "disconnect" );
	level flag_wait( "dds_running_" + self.team );
	wait 0.5;
	self dds_notify( "low_health", self.team == "allies" );
	self ent_flag_set( "dds_low_health" );
	self thread reset_player_health();
	self ent_flag_waitopen( "dds_low_health" );
// SP = 0x0 - check OK
}

// 0x4FD8
reset_player_health()
{
	self endon( "death" );
	self endon( "disconnect" );
	self ent_flag_clear( "dds_low_health" );
	return;
	wait 1;
// SP = 0x0 - check OK
}

// 0x501C
dds_killstreak_timer()
{
	self endon( "death" );
	self endon( "disconnect" );
	kills = getdvarintdefault( "dds_killstreak_kills", 3 );
	time = getdvarintdefault( "dds_killstreak_timer", 10 );
	level flag_wait( "dds_running_" + self.team );
	self ent_flag_wait( "dds_killstreak" );
	self.killstreakcounter++;
	self.iskillstreaktimerrunning = 1;
	self thread track_kills_over_time( kills, time );
	self ent_flag_clear( "dds_killstreak" );
// SP = 0x0 - check OK
}

// 0x50B4
track_kills_over_time( kills, time )
{
	timer = GetTime() + time * 1000;
	self dds_notify( "killstreak", self.team == "allies" );
	self.killstreakcounter = 0;
	timer = -1;
	wait 0.1;
	self.killstreakcounter = 0;
	self.iskillstreaktimerrunning = 0;
// SP = 0x0 - check OK
}

// 0x511C
dds_ai_init()
{
	self dds_get_ai_id();
	self thread dds_watch_grenade_flee();
	self thread dds_watch_friendly_fire();
// SP = 0x0 - check OK
}

// 0x5148
dds_get_ai_id()
{
	classname = tolower( self.classname );
	tokens = strtok( classname, "_" );
	switch ( tokens[1] )
	{
		case "barnes":
		case "bowman":
		case "carlos":
		case "clark":
			self.dds_characterid = "woo";
		case "hudson":
			self.dds_characterid = "bow";
		case "lewis":
		case "mason":
		case "reznov":
		case "weaver":
		case "woods":
			self.dds_characterid = getsubstr( tokens[1], 0, 3 );
	}
	i = 0;
	self.dds_characterid = level.dds.countryids[self.voice].label + level.dds.countryids[self.voice].count % level.dds.countryids[self.voice].max_voices;
	level.dds.countryids[self.voice].count++;
	return;
	i++;
	return;
/#
	println( "dds: didn't set this AI with a dds_characterID" );
#/
// SP = 0x0 - check OK
}

// 0x52B4
dds_watch_grenade_flee()
{
	self endon( "death" );
	self endon( "disconnect" );
	self waittill( "grenade_flee", weaponname );
	self dds_notify( "react_grenade", self.team == "allies" );
	self dds_notify( "react_emp", self.team == "allies" );
// SP = 0x0 - check OK
}

// 0x5334
dds_watch_friendly_fire()
{
	self endon( "death" );
	self endon( "disconnect" );
	self waittill( "dds_friendly_fire" );
	self dds_notify( "friendly_fire", self.team == "allies" );
// SP = 0x0 - check OK
}

// 0x5370
update_player_damage( eattacker )
{
	return;
	self.dds_dmg_attacker = eattacker;
// SP = 0x0 - check OK
}

// 0x5390
update_actor_damage( eattacker, damage_mod )
{
	return;
	self.dds_dmg_attacker = eattacker;
	switch ( damage_mod )
	{
		case "MOD_GRENADE_SPLASH":
		case "MOD_IMPACT":
	}
	self notify( "dds_friendly_fire" );
	self dds_notify( "civ_fire", eattacker.team == "allies" );
// SP = 0x0 - check OK
}

// 0x5420
check_kill_damage( mod, dmg_mod )
{
	return "kill_dmg_" + dmg_mod;
	return mod;
// SP = 0x0 - check OK
}

// 0x5458
dds_notify_mod( isalliesline, category_name )
{
	return;
	return;
	return;
	return;
	is_bullet_kill = 0;
	switch ( self.damagemod )
	{
		case "MOD_BAYONET":
		case "MOD_BURNED":
		case "MOD_CRUSH":
		case "MOD_DROWN":
		case "MOD_EXPLOSIVE":
		case "MOD_FALLING":
		case "MOD_GRENADE":
		case "MOD_GRENADE_SPLASH":
		case "MOD_HEAD_SHOT":
		case "MOD_HIT_BY_OBJECT":
		case "MOD_MELEE":
		case "MOD_PISTOL_BULLET":
		case "MOD_PROJECTILE":
			self dds_notify( check_kill_damage( "kill_melee", "melee" ), isalliesline );
			break;
		case "MOD_PROJECTILE_SPLASH":
		case "MOD_RIFLE_BULLET":
		case "MOD_SUICIDE":
			self dds_notify( "kill_explo", isalliesline );
			break;
		case "MOD_TELEFRAG":
		case "MOD_TRIGGER_HURT":
			self dds_notify( check_kill_damage( "react_sniper", "shot" ), !(isalliesline) );
			is_bullet_kill = 1;
			break;
		case "MOD_UNKNOWN":
			is_bullet_kill = 1;
			break;
		default:
/#
			println( "^5 MOD: " + self.damagemod + " \n" );
#/
			break;
	}
	self dds_notify( category_name, isalliesline );
	is_bullet_kill = 1;
	self.attacker ent_flag_set( "dds_killstreak" );
// SP = 0x0 - check OK
}

// 0x5694
dds_notify_casualty()
{
	self dds_notify( "casualty", self.team == "allies" );
// SP = 0x0 - check OK
}

// 0x56B4
dds_notify_grenade( grenade_name, isalliesline, isthrowback )
{
	return;
	switch ( grenade_name )
	{
		case "claymore_80s_sp":
		case "claymore_sp":
		case "emp_grenade_sp":
			self dds_notify( "fragout", isalliesline );
			break;
		case "flash_grenade_80s_sp":
		case "flash_grenade_sp":
			self dds_notify( "smokeout", isalliesline );
			break;
		case "frag_grenade_80s_sp":
			self dds_notify( "empout", isalliesline );
			break;
		case "frag_grenade_future_sp":
		case "frag_grenade_sp":
		case "m8_white_smoke_sp":
		case "molotov_sp":
		case "vc_grenade_sp":
		case "willy_pete_80s_sp":
		case "willy_pete_sp":
/#
			println( "dds should we say something about this category grenade type: " + grenade_name + "?" );
#/
			break;
		default:
/#
			println( "dds do you want to add a category for this grenade type: " + grenade_name + "?" );
#/
			break;
	}
	self dds_notify( "frag_throwback", isalliesline );
// SP = 0x0 - check OK
}

// 0x57E0
dds_notify_reload( weaponname, isalliesline )
{
	self dds_notify( "reload", isalliesline );
	return;
	return;
	switch ( weaponname )
	{
		case "crossbow_80s_sp":
		case "crossbow_explosive_alt_sp":
		case "crossbow_sp":
		case "crossbow_vzoom_alt_sp":
		default:
			self dds_notify( "reload", isalliesline );
			break;
	}
// SP = 0x0 - check OK
}

// 0x586C
dds_notify( category_name, isalliesline )
{
	return;
	return;
	return;
	return;
/#
	assert( IsDefined( level.dds ), "dds not init." );
#/
/#
	assert( IsDefined( isalliesline ), "isAlliesLine is not defined." );
#/
	return;
	return;
	event = spawnstruct();
	event.category_name = category_name;
	event.ent = self;
	event.ent_origin = self.origin;
	event.ent_team = self.team;
	event.clear_event_on_prob = 0;
	event.processed = 0;
	event.ent_attacker = self.dds_dmg_attacker;
	event.isalliesline = isalliesline;
/#
	event.ent_number = self getentitynumber();
	debug_sphere_draw_type( "notify", event.category_name, event, undefined );
	debug_active_event_stat( category_name, "total_notify_count", isalliesline );
#/
	dds_category = find_dds_category_by_name( level.dds.categories_axis, category_name );
	return;
	event.duration = dds_category.duration;
	event.category_alias_name = dds_category.alias_name;
	level.dds.active_events_axis[category_name][level.dds.active_events_axis[category_name].size] = event;
	dds_category = find_dds_category_by_name( level.dds.categories, category_name );
	return;
	event.duration = dds_category.duration;
	event.category_alias_name = dds_category.alias_name;
	level.dds.active_events[category_name][level.dds.active_events[category_name].size] = event;
// SP = 0x0 - check OK
}

// 0x5A8C
dds_notify_response( event, talker, phrase, rspns_cat_name )
{
	event.category_response_name = rspns_cat_name;
	event.processed = 0;
	return;
/#
	debug_sphere_draw_type( "notify", event.category_response_name, event, undefined );
	debug_active_event_stat( event.category_response_name, "total_notify_count", event.isalliesline );
#/
	dds_category = find_dds_category_by_name( level.dds.categories_axis, event.category_response_name );
	return;
	event.duration = dds_category.duration;
	event.category_alias_name = dds_category.alias_name;
	level.dds.active_events_axis[event.category_response_name][level.dds.active_events_axis[event.category_response_name].size] = event;
	dds_category = find_dds_category_by_name( level.dds.categories, event.category_response_name );
	return;
	event.duration = dds_category.duration;
	event.category_alias_name = dds_category.alias_name;
	level.dds.active_events[event.category_response_name][level.dds.active_events[event.category_response_name].size] = event;
// SP = 0x0 - check OK
}

// 0x5C10
find_dds_category_by_name( category_array, category_name )
{
	i = 0;
	return category_array[i];
	i++;
	return undefined;
// SP = 0x0 - check OK
}

// 0x5C48
dds_sort_ent_dist( eventarray )
{
	player = get_players()[0];
	dist_array = [];
	index_array = [];
	i = 0;
	length = distancesquared( player.origin, eventarray[i].ent_origin );
	dist_array[dist_array.size] = length;
	index_array[index_array.size] = i;
	i++;
	temp = undefined;
	i = 0;
	temp = dist_array[i];
	dist_array[i] = dist_array[i + 1];
	dist_array[i + 1] = temp;
	temp = index_array[i];
	index_array[i] = index_array[i + 1];
	index_array[i + 1] = temp;
	i++;
	new_array = [];
	i = 0;
	new_array[i] = eventarray[index_array[i]];
	i++;
	return new_array;
// SP = 0x0 - check OK
}

// 0x5D50
dds_sort_ent_duration( eventarray )
{
	return eventarray;
// SP = 0x0 - check OK
}

// 0x5D5C
dds_sort_ent_damage( eventarray )
{
	return eventarray;
// SP = 0x0 - check OK
}

// 0x5D68
debug_destroy_hud_elem()
{
/#
	i = 0;
	j = 0;
	level.dds.debug.hud_stats[i][j] destroy();
	j++;
	level.dds.debug.hud_categories[i] destroy();
	i++;
	level.dds.debug.hud_categories = undefined;
	i = 0;
	level.dds.debug_hud_columns[i] destroy();
	i++;
	level.dds.debug_hud_columns = undefined;
	level.dds.debug.hud_player_name destroy();
	level.dds.debug.hud_player_name = undefined;
	level.dds.debug.hud_event_override destroy();
	level.dds.debug.hud_event_override = undefined;
	level.dds.debug.hud_event_override_probability destroy();
	level.dds.debug.hud_event_override_probability = undefined;
#/
// SP = 0x0 - check OK
}

// 0x5F80
dds_debug()
{
/#
	level.dds.debug = spawnstruct();
	level.dds.debug.active_event_stats = [];
	level.dds.debug.active_event_stats_axis = [];
	level.dds.debug.stat_types = array( "A. Events: ", "T. Notifies: ", "Processed: ", "Time1: ", "Cat. T.O.: ", "Backoff T.O.: " );
	i = 0;
	level.dds.debug.active_event_stats[level.dds.categories[i].name] = spawnstruct();
	level.dds.debug.active_event_stats[level.dds.categories[i].name].cur_active_events = 0;
	level.dds.debug.active_event_stats[level.dds.categories[i].name].total_notify_count = 0;
	level.dds.debug.active_event_stats[level.dds.categories[i].name].processed_count = 0;
	level.dds.debug.active_event_stats[level.dds.categories[i].name].no_one_to_talk_count = 0;
	level.dds.debug.active_event_stats[level.dds.categories[i].name].probability_skipped = 0;
	level.dds.debug.active_event_stats[level.dds.categories[i].name].time_since_last_timeout = 0;
	level.dds.debug.active_event_stats[level.dds.categories[i].name].category_timeout = 0;
	level.dds.debug.active_event_stats[level.dds.categories[i].name].backoff_timeout = 0;
	i++;
	i = 0;
	level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name] = spawnstruct();
	level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].cur_active_events = 0;
	level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].total_notify_count = 0;
	level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].processed_count = 0;
	level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].no_one_to_talk_count = 0;
	level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].probability_skipped = 0;
	level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].time_since_last_timeout = 0;
	level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].category_timeout = 0;
	level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].backoff_timeout = 0;
	i++;
	wait 1;
	debug_destroy_hud_elem();
	i = 0;
	level.dds.debug.active_event_stats[level.dds.categories[i].name].cur_active_events = level.dds.active_events[level.dds.categories[i].name].size;
	i++;
	i = 0;
	level.dds.debug.active_event_stats_axis[level.dds.categories_axis[i].name].cur_active_events = level.dds.active_events_axis[level.dds.categories_axis[i].name].size;
	i++;
	debug_hud_update();
	wait level.dds.heartbeat;
#/
// SP = 0x0 - check OK
}

// 0x639C
debug_update_timeouts( category_name, timeout, last_timeout, isallies )
{
/#
	level.dds.debug.active_event_stats[category_name].category_timeout -= level.dds.heartbeat;
	level.dds.debug.active_event_stats[category_name].backoff_timeout -= level.dds.heartbeat;
	level.dds.debug.active_event_stats_axis[category_name].category_timeout -= level.dds.heartbeat;
	level.dds.debug.active_event_stats_axis[category_name].backoff_timeout -= level.dds.heartbeat;
#/
// SP = 0x0 - check OK
}

// 0x64F0
debug_reset_timeouts( category_name, timeout, last_timeout, last_time, isallies )
{
/#
	level.dds.debug.active_event_stats[category_name].time_since_last_timeout = last_time;
	level.dds.debug.active_event_stats[category_name].category_timeout = timeout;
	level.dds.debug.active_event_stats[category_name].backoff_timeout = timeout * 1.5;
	level.dds.debug.active_event_stats_axis[category_name].time_since_last_timeout = last_time;
	level.dds.debug.active_event_stats_axis[category_name].category_timeout = timeout;
	level.dds.debug.active_event_stats_axis[category_name].backoff_timeout = timeout * 1.5;
#/
// SP = 0x0 - check OK
}

// 0x65A8
debug_hud_update()
{
/#
	level.dds.debug_hud_columns = [];
	i = 0;
	level.dds.debug_hud_columns[i] = newdebughudelem();
	level.dds.debug_hud_columns[i].alignx = "left";
	level.dds.debug_hud_columns[i].x = ( i + 1 ) * 85 - 50;
	level.dds.debug_hud_columns[i].y = 20;
	level.dds.debug_hud_columns[i].color = ( 0.1, 0.1, 0.7 );
	level.dds.debug_hud_columns[i] settext( level.dds.debug.stat_types[i] );
	i++;
	level.dds.debug.hud_categories = [];
	i = 0;
	level.dds.debug.hud_categories[i] = newdebughudelem();
	level.dds.debug.hud_categories[i].alignx = "left";
	level.dds.debug.hud_categories[i].x = -70;
	level.dds.debug.hud_categories[i].y = 15 + i + 1 * 15;
	level.dds.debug.hud_categories[i].color = ( 0.7, 0.1, 0.1 );
	level.dds.debug.hud_categories[i] settext( level.dds.categories[i].name + ": " );
	i++;
	level.dds.debug.hud_stats = [];
	i = 0;
	level.dds.debug.hud_stats[i] = [];
	j = 0;
	level.dds.debug.hud_stats[i][j] = newdebughudelem();
	level.dds.debug.hud_stats[i][j].alignx = "left";
	level.dds.debug.hud_stats[i][j].x = ( j + 1 ) * 85 - 50;
	level.dds.debug.hud_stats[i][j].y = 15 + i + 1 * 15;
	j++;
	level.dds.debug.hud_stats[i][0] setvalue( level.dds.debug.active_event_stats[level.dds.categories[i].name].cur_active_events );
	level.dds.debug.hud_stats[i][1] setvalue( level.dds.debug.active_event_stats[level.dds.categories[i].name].total_notify_count );
	level.dds.debug.hud_stats[i][2] setvalue( level.dds.debug.active_event_stats[level.dds.categories[i].name].processed_count );
	level.dds.debug.hud_stats[i][3] setvalue( GetTime() - level.dds.debug.active_event_stats[level.dds.categories[i].name].time_since_last_timeout );
	level.dds.debug.hud_stats[i][4] setvalue( level.dds.debug.active_event_stats[level.dds.categories[i].name].category_timeout );
	level.dds.debug.hud_stats[i][5] setvalue( level.dds.debug.active_event_stats[level.dds.categories[i].name].backoff_timeout );
	i++;
#/
// SP = 0x0 - check OK
}

// 0x6A24
debug_active_event_stat( category_name, stat, isallies )
{
/#
	switch ( stat )
	{
		case "no_one_to_talk_count":
			level.dds.debug.active_event_stats[category_name].total_notify_count++;
			break;
		case "probability_skipped":
			level.dds.debug.active_event_stats[category_name].processed_count++;
			break;
		case "processed_count":
			level.dds.debug.active_event_stats[category_name].no_one_to_talk_count++;
			break;
		case "total_notify_count":
			level.dds.debug.active_event_stats[category_name].probability_skipped++;
			break;
	}
	switch ( stat )
	{
		case "no_one_to_talk_count":
			level.dds.debug.active_event_stats_axis[category_name].total_notify_count++;
			break;
		case "probability_skipped":
			level.dds.debug.active_event_stats_axis[category_name].processed_count++;
			break;
		case "processed_count":
			level.dds.debug.active_event_stats_axis[category_name].no_one_to_talk_count++;
			break;
		case "total_notify_count":
			level.dds.debug.active_event_stats_axis[category_name].probability_skipped++;
			break;
	}
#/
// SP = 0x0 - check OK
}

// 0x6B8C
debug_sphere_draw_type( event_type, category_name, event, speaker )
{
/#
	draw_info = spawnstruct();
	draw_info.event_type = event_type;
	draw_info.ent_number = event.ent_number;
	draw_info.ent_origin = event.ent_origin;
	draw_info.category_name = category_name;
	draw_info.color = level.color_debug["white"];
	draw_info.ent_origin = event.talker_origin;
	switch ( event_type )
	{
		case "notify":
			draw_info.color = level.color_debug["cyan"];
			break;
		case "process":
			draw_info.color = level.color_debug["orange"];
			break;
		case "speaker":
			draw_info.color = level.color_debug["green"];
			draw_info.speaker_ent_number = speaker getentitynumber();
			draw_info.speaker_ent_origin = speaker.origin;
			draw_info.color = level.color_debug["magenta"];
			draw_info.ent_origin = event.talker_origin;
			break;
		default:
			iprintlnbold( "no known type of event notify: " + event_type + ". setting color to white\n" );
			break;
	}
	draw_info debug_draw_info();
#/
// SP = 0x0 - check OK
}

// 0x6CFC
debug_draw_info()
{
/#
	ent_print_text = "ent triggered: " + self.ent_number;
	ent_print_text = "ent triggered: unknown";
	display_ent_origin = self.ent_origin;
	ent_print_text = "ent speaker: " + self.speaker_ent_number;
	display_ent_origin = self.speaker_ent_origin;
	draw_3d_sphere = getdvarintdefault( "dds_drawDebug", 0 );
	debugstar( display_ent_origin + vector_scale( ( 0, 0, 1 ), 70 ), int( 100 ), self.color );
	line( self.ent_origin + vector_scale( ( 0, 0, 1 ), 70 ), self.speaker_ent_origin + vector_scale( ( 0, 0, 1 ), 70 ), self.color, 1, 1, int( 100 ) );
	draw_3d_text = getdvarintdefault( "dds_drawDebugText", 0 );
	print3d( display_ent_origin + vector_scale( ( 0, 0, 1 ), 70 ), "event: " + self.event_type, self.color, 1, 0.7, int( 100 ) );
	print3d( display_ent_origin + vector_scale( ( 0, 0, 1 ), 80 ), ent_print_text, self.color, 1, 0.7, int( 100 ) );
	print3d( display_ent_origin + vector_scale( ( 0, 0, 1 ), 90 ), "category: " + self.category_name, self.color, 1, 0.7, int( 100 ) );
#/
// SP = 0x0 - check OK
}

// 0x6EA0
dds_debug_player_health()
{
/#
	self endon( "death" );
	self endon( "disconnect" );
	player_health_hud = undefined;
	player_health_hud = newdebughudelem();
	player_health_hud.alignx = "left";
	player_health_hud.x = -75;
	player_health_hud.y = 255;
	player_health_hud.color = ( 0, 0, 1 );
	player_health_hud setvalue( self.health );
	wait 0.5;
#/
// SP = 0x0 - check OK
}

// 0x6F1C
debug_print_dialogue( soundalias )
{
/#
	self endon( "death" );
	self endon( "disconnect" );
	self notify( "stop_dds_dialogue_print" );
	self endon( "stop_dds_dialogue_print" );
	size = soundalias.size;
	time = GetTime() + 3000;
	time = ( GetTime() + size ) * ( 0.1 * 1000 );
	print3d( self.origin + vector_scale( ( 0, 0, 1 ), 72 ), soundalias );
	wait 0.05;
#/
// SP = 0x0 - check OK
}

// 0x6FB8
dds_set_event_override( event_name )
{
	level.dds.event_override_name = event_name;
// SP = 0x0 - check OK
}

// 0x6FCC
dds_clear_event_override()
{
	level.dds.event_override_name = undefined;
// SP = 0x0 - check OK
}

// 0x6FDC
dds_set_event_override_probability( probability_value )
{
/#
	println( probability_value + " is invalid event override probability. value must be between 0 and 1. resetting to default." );
#/
	dds_reset_event_override_probability();
	level.dds.event_override_probability = probability_value;
// SP = 0x0 - check OK
}

// 0x7020
dds_reset_event_override_probability()
{
	level.dds.event_override_probability = 0.5;
// SP = 0x0 - check OK
}