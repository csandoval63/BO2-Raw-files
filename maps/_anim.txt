// maps/_anim.gsc

#include maps\_turret;
#include animscripts\animmode;
#include animscripts\face;
#include animscripts\utility;
#include animscripts\shared;
#include common_scripts\utility;
#include maps\_utility;

#using_animtree ( "generic_human" );


// 0x2074
anim_reach( ents, scene, animname_override )
{
	ents = build_ent_array( ents );
	do_anim_reach( ents, scene, undefined, animname_override, 0 );
// SP = 0x0 - check OK
}

// 0x20A4
anim_reach_aligned( ents, scene, tag, animname_override )
{
	ents = build_ent_array( ents );
	do_anim_reach( ents, scene, tag, animname_override, 1 );
// SP = 0x0 - check OK
}

// 0x20D4
anim_generic_reach( ents, scene )
{
	anim_reach( ents, scene, "generic" );
// SP = 0x0 - check OK
}

// 0x20F0
anim_generic_reach_aligned( ents, scene, tag )
{
	anim_reach_aligned( ents, scene, tag, "generic" );
// SP = 0x0 - check OK
}

// 0x2110
anim_reach_idle( guys, scene, idle )
{
	guys = build_ent_array( guys );
	ent = spawnstruct();
	ent.count = guys.size;
	i = 0;
	thread reach_idle( guys[i], scene, idle, ent );
	i++;
	ent waittill( "reach_idle_goal" );
// SP = 0x0 - check OK
}

// 0x2184
anim_teleport( ents, scene, tag, animname_override )
{
	ents = build_ent_array( ents );
	pos = get_anim_position( tag );
	org = pos["origin"];
	angles = pos["angles"];
	i = 0;
	ent = ents[i];
	startorg = getstartorigin( org, angles, ent get_anim( scene, animname_override ) );
	ent teleport( startorg );
	ent.origin = startorg;
	i++;
// SP = 0x0 - check OK
}

// 0x2230
anim_single( ents, scene, animname_override )
{
	ents = build_ent_array( ents );
	do_anim_single( ents, scene, undefined, animname_override, 0 );
// SP = 0x0 - check OK
}

// 0x2260
anim_single_aligned( ents, scene, tag, animname_override, n_lerp_time )
{
	ents = build_ent_array( ents );
	do_anim_single( ents, scene, tag, animname_override, 1, n_lerp_time );
// SP = 0x0 - check OK
}

// 0x2298
anim_first_frame( ents, scene, tag, animname_override )
{
	pos_array = get_anim_position( tag );
	org = pos_array["origin"];
	angles = pos_array["angles"];
	ents = build_ent_array( ents );
	self array_ent_thread( ents, ::anim_first_frame_on_guy, scene, org, angles, animname_override );
// SP = 0x0 - check OK
}

// 0x22FC
anim_generic( ents, scene )
{
	anim_single( ents, scene, "generic" );
// SP = 0x0 - check OK
}

// 0x2318
anim_generic_aligned( ents, scene, tag, n_lerp_time )
{
	anim_single_aligned( ents, scene, tag, "generic", n_lerp_time );
// SP = 0x0 - check OK
}

// 0x233C
anim_loop( ents, scene, ender, animname_override )
{
	ents = build_ent_array( ents );
/#
#/
	guypackets = [];
	i = 0;
	packet = [];
	packet["guy"] = ents[i];
	packet["entity"] = packet["guy"];
	guypackets[guypackets.size] = packet;
	i++;
	anim_loop_packet( guypackets, scene, ender, animname_override );
// SP = 0x0 - check OK
}

// 0x23C8
anim_generic_loop( ents, scene, ender )
{
	anim_loop( ents, scene, ender, "generic" );
// SP = 0x0 - check OK
}

// 0x23E8
anim_loop_aligned( ents, scene, tag, ender, animname_override, n_lerp_time )
{
	ents = build_ent_array( ents );
/#
#/
	guypackets = [];
	i = 0;
	packet = [];
	packet["guy"] = ents[i];
	packet["entity"] = self;
	packet["tag"] = tag;
	guypackets[guypackets.size] = packet;
	i++;
/#
	assert( IsDefined( self.angles ), "Alignment node does not have angles specified." );
#/
	anim_loop_packet( guypackets, scene, ender, animname_override, n_lerp_time );
// SP = 0x0 - check OK
}

// 0x2494
anim_generic_loop_aligned( ents, scene, tag, ender, n_lerp_time )
{
	anim_loop_aligned( ents, scene, tag, ender, "generic", n_lerp_time );
// SP = 0x0 - check OK
}

// 0x24BC
anim_custom_animmode( ents, custom_animmode, scene, tag, animname_override )
{
	ents = build_ent_array( ents );
	array = get_anim_position( tag );
	org = array["origin"];
	angles = array["angles"];
	i = 0;
	thread anim_custom_animmode_on_guy( ents[i], custom_animmode, scene, org, angles, animname_override );
	i++;
/#
	assert( IsDefined( ents[0] ), "anim_custom_animmode called without a guy in the array" );
#/
	ents[0] wait_until_anim_finishes( scene );
	self notify( scene );
// SP = 0x0 - check OK
}

// 0x255C
anim_generic_custom_animmode( ents, custom_animmode, scene, tag )
{
	anim_custom_animmode( ents, custom_animmode, scene, tag, "generic" );
// SP = 0x0 - check OK
}

// 0x2580
anim_set_time( guys, scene, time )
{
	array_thread( guys, ::anim_self_set_time, scene, time );
// SP = 0x0 - check OK
}

// 0x25A4
addnotetrack_dialogue( animname, notetrack, scene, soundalias, pg_soundalias )
{
	num = 0;
	num = level.scr_notetrack[animname].size;
	level.scr_notetrack[animname][num]["notetrack"] = notetrack;
	level.scr_notetrack[animname][num]["dialog"] = soundalias;
	level.scr_notetrack[animname][num]["pg_dialog"] = pg_soundalias;
	level.scr_notetrack[animname][num]["scene"] = scene;
// SP = 0x0 - check OK
}

// 0x261C
removenotetrack_dialogue( animname, notetrack, scene, soundalias )
{
/#
	assert( IsDefined( level.scr_notetrack[animname] ), "Animname not found in scr_notetrack." );
#/
	tmp_array = [];
	i = 0;
	dialog = level.scr_notetrack[animname][i]["dialog"];
	dialog = level.scr_notetrack[animname][i]["dialogue"];
	num = tmp_array.size;
	tmp_array[num] = level.scr_notetrack[animname][i];
	i++;
/#
	assert( tmp_array.size < level.scr_notetrack[animname].size, "Notetrack not found." );
#/
	level.scr_notetrack[animname] = tmp_array;
// SP = 0x0 - check OK
}

// 0x2734
addnotetrack_sound( animname, notetrack, scene, soundalias )
{
	notetrack = "start";
	scene = "any";
	array = [];
	array["notetrack"] = notetrack;
	array["sound"] = soundalias;
	array["scene"] = scene;
	level.scr_notetrack = [];
	level.scr_notetrack[animname] = [];
	level.scr_notetrack[animname] = [];
	level.scr_notetrack[animname][level.scr_notetrack[animname].size] = array;
// SP = 0x0 - check OK
}

// 0x27C8
addonstart_animsound( animname, scene, soundalias )
{
	level.scr_animsound[animname] = [];
	level.scr_animsound[animname][scene] = soundalias;
// SP = 0x0 - check OK
}

// 0x27F8
addnotetrack_animsound( animname, scene, notetrack, soundalias )
{
	level.scr_notetrack[animname] = [];
	array = [];
	array["notetrack"] = notetrack;
	array["sound"] = soundalias;
	array["created_by_animSound"] = 1;
	array["scene"] = scene;
	level.scr_notetrack[animname][level.scr_notetrack[animname].size] = array;
// SP = 0x0 - check OK
}

// 0x2860
addnotetrack_attach( animname, notetrack, model, tag, scene )
{
	notetrack = "start";
	scene = "any";
	num = 0;
	num = level.scr_notetrack[animname].size;
	level.scr_notetrack[animname][num]["notetrack"] = notetrack;
	level.scr_notetrack[animname][num]["attach model"] = model;
	level.scr_notetrack[animname][num]["selftag"] = tag;
	level.scr_notetrack[animname][num]["scene"] = scene;
// SP = 0x0 - check OK
}

// 0x28F4
addnotetrack_detach( animname, notetrack, model, tag, scene )
{
	notetrack = "start";
	scene = "any";
	num = 0;
	num = level.scr_notetrack[animname].size;
	level.scr_notetrack[animname][num]["notetrack"] = notetrack;
	level.scr_notetrack[animname][num]["detach model"] = model;
	level.scr_notetrack[animname][num]["selftag"] = tag;
	level.scr_notetrack[animname][num]["scene"] = scene;
// SP = 0x0 - check OK
}

// 0x2988
addnotetrack_fov( animname, notetrack, scene )
{
	notetrack = "start";
	scene = "any";
	num = 0;
	num = level.scr_notetrack[animname].size;
	level.scr_notetrack[animname][num]["notetrack"] = notetrack;
	level.scr_notetrack[animname][num]["change fov"] = notetrack;
	level.scr_notetrack[animname][num]["scene"] = scene;
// SP = 0x0 - check OK
}

// 0x2A04
addnotetrack_fov_new( animname, notetrack, n_fov, n_time, scene )
{
	notetrack = "start";
	scene = "any";
	num = 0;
	num = level.scr_notetrack[animname].size;
	n_fov = GetDvarFloat( #"0x55DDAF3D" );
	level.scr_notetrack[animname][num]["notetrack"] = notetrack;
	level.scr_notetrack[animname][num]["fov"] = n_fov;
	level.scr_notetrack[animname][num]["time"] = n_time;
	level.scr_notetrack[animname][num]["scene"] = scene;
// SP = 0x0 - check OK
}

// 0x2AAC
addnotetrack_level_notify( animname, notetrack, str_notify, scene )
{
	notetrack = "start";
	scene = "any";
	num = 0;
	num = level.scr_notetrack[animname].size;
	level.scr_notetrack[animname][num]["notetrack"] = notetrack;
	level.scr_notetrack[animname][num]["level notify"] = str_notify;
	level.scr_notetrack[animname][num]["scene"] = scene;
// SP = 0x0 - check OK
}

// 0x2B2C
addnotetrack_customfunction( animname, str_notetrack, function, scene, passnoteback )
{
	str_notetrack = "start";
	scene = "any";
	passnoteback = 0;
	level.scr_notetrack[animname] = [];
	num = 0;
	foreach ( notetrack in level.scr_notetrack[animname] )
	{
	}
	num = level.scr_notetrack[animname].size;
	level.scr_notetrack[animname][num]["notetrack"] = str_notetrack;
	level.scr_notetrack[animname][num]["function"] = function;
	level.scr_notetrack[animname][num]["scene"] = scene;
	level.scr_notetrack[animname][num]["noteback"] = passnoteback;
// SP = 0x0 - check OK
}

// 0x2C40
notetrack_customfunction_exists( animname, notetrack, function, scene )
{
	keys = getarraykeys( level.scr_notetrack[animname] );
	i = 0;
	return 1;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x2D3C
addnotetrack_flag( animname, notetrack, flag, scene )
{
	notetrack = "start";
	scene = "any";
	level.scr_notetrack[animname] = [];
	add_note = [];
	add_note["notetrack"] = notetrack;
	add_note["flag"] = flag;
	add_note["scene"] = scene;
	level.scr_notetrack[animname][level.scr_notetrack[animname].size] = add_note;
	flag_init( flag );
// SP = 0x0 - check OK
}

// 0x2DD8
addnotetrack_fxontag( animname, scene, notetrack, effect, tag, on_threader )
{
	scene = "any";
	notetrack = "start";
	level.scr_notetrack[animname] = [];
	add_note = [];
	add_note["notetrack"] = notetrack;
	add_note["scene"] = scene;
	add_note["effect"] = effect;
	add_note["tag"] = tag;
	add_note["selftag"] = tag;
	level.scr_notetrack[animname][level.scr_notetrack[animname].size] = add_note;
// SP = 0x0 - check OK
}

// 0x2E84
addnotetrack_exploder( animname, notetrack, exploder, scene )
{
	notetrack = "start";
	level.scr_notetrack[animname] = [];
	add_note = [];
	add_note["notetrack"] = notetrack;
	add_note["exploder"] = exploder;
	scene = "any";
	add_note["scene"] = scene;
	level.scr_notetrack[animname][level.scr_notetrack[animname].size] = add_note;
// SP = 0x0 - check OK
}

// 0x2F04
addnotetrack_stop_exploder( animname, notetrack, exploder, scene )
{
	notetrack = "start";
	level.scr_notetrack[animname] = [];
	add_note = [];
	add_note["notetrack"] = notetrack;
	add_note["stop_exploder"] = exploder;
	scene = "any";
	add_note["scene"] = scene;
	level.scr_notetrack[animname][level.scr_notetrack[animname].size] = add_note;
// SP = 0x0 - check OK
}

// 0x2F84
set_animname( ents, animname )
{
	i = 0;
	ents[i].animname = animname;
	i++;
// SP = 0x0 - check OK
}

// 0x2FB4
anim_set_blend_in_time( time )
{
	self._anim_blend_in_time = time;
// SP = 0x0 - check OK
}

// 0x2FC4
anim_set_blend_out_time( time )
{
	self._anim_blend_out_time = time;
// SP = 0x0 - check OK
}

// 0x2FD4
get_anim( scene, animname )
{
	animname = self.animname;
	return random( level.scr_anim[animname][scene] );
	return level.scr_anim[animname][scene];
// SP = 0x0 - check OK
}

// 0x3034
init()
{
	level.scr_special_notetrack = [];
	level.scr_notetrack = [];
	level.scr_face = [];
	level.scr_look = [];
	level.scr_animsound = [];
	level.scr_sound = [];
	level.scr_radio = [];
	level.scr_text = [];
	level.scr_anim[0][0] = 0;
	level.scr_radio = [];
// SP = 0x0 - check OK
}

// 0x30E0
build_ent_array( ents )
{
	ent_array = [];
	ent_array = ents;
	ent_array[0] = ents;
	return ent_array;
// SP = 0x0 - check OK
}

// 0x3110
wait_until_anim_finishes( scene )
{
	self endon( "finished_custom_animmode" + scene );
	self waittill( "death" );
// SP = 0x0 - check OK
}

// 0x3128
debug_check( ents, scene, animname_override )
{
/#
/#
	assertmsg( "maps/_anim: undefined scene for animation." );
#/
	return 0;
	i = 0;
	return 0;
	i++;
	return 1;
#/
// SP = 0x0 - check OK
}

// 0x3180
is_a_sound_only_scene( scene, animname )
{
	animname = self.animname;
/#
	assertmsg( "Animating character of type " + self.classname + " has no animname." );
#/
	return 0;
	has_anim = 0;
	has_sound = 1;
	has_anim = 1;
	has_sound = 1;
	return 0;
	return has_sound;
// SP = 0x0 - check OK
}

// 0x3214
assert_existance_of_anim( scene, animname )
{
/#
	animname = self.animname;
/#
	assertmsg( "Animating character of type " + self.classname + " has no animname." );
#/
	return 0;
	has_anim = 0;
	has_anim = 1;
	return 1;
	has_sound = 0;
	has_sound = 1;
	return 1;
	return 1;
	array = getarraykeys( level.scr_anim[animname] );
	println( "Legal scene scenes for " + animname + ":" );
	i = 0;
	println( array[i] );
	i++;
	array = getarraykeys( level.scr_sound[animname] );
	println( "Legal scr_sound scenes for " + animname + ":" );
	i = 0;
	println( array[i] );
	i++;
/#
	assertmsg( "Guy with animname \"" + animname + "\" is trying to do scene \"" + scene + "\" there is no level.scr_anim or level.scr_sound for that animname" );
#/
	return 0;
	keys = getarraykeys( level.scr_anim );
	keys = arraycombine( keys, getarraykeys( level.scr_sound ), 1, 0 );
	i = 0;
	println( keys[i] );
	i++;
/#
	assertmsg( "Animname " + animname + " is not setup to do animations. See above for list of legal animnames." );
#/
	return 0;
#/
// SP = 0x0 - check OK
}

// 0x3408
anim_first_frame_on_guy( guy, scene, org, angles, animname_override )
{
	anim_ent = guy get_anim_ent();
	animname = animname_override;
	animname = anim_ent.animname;
/#
	anim_ent assert_existance_of_anim( scene, animname );
	self thread anim_info_render_thread( guy, scene, org, angles, animname, scene, 0, 1 );
#/
	animation = anim_ent get_anim( scene, animname );
	anim_ent animscripted( "anim_first_frame", org, angles, animation, "normal", anim_ent.root_anim, 0, 0 );
// SP = 0x0 - check OK
}

// 0x34A4
anim_custom_animmode_on_guy( guy, custom_animmode, scene, org, angles, animname_override )
{
	animname = undefined;
	animname = animname_override;
	animname = guy.animname;
/#
	guy assert_existance_of_anim( scene, animname );
#/
/#
	assert( isai( guy ), "Tried to do custom_animmode on a non ai" );
#/
	guy set_start_pos( scene, org, angles, animname_override );
	guy._animmode = custom_animmode;
	guy._custom_anim = scene;
	guy._tag_entity = self;
	guy._scene = scene;
	guy._animname = animname;
	guy animcustom( animscripts\animmode::main );
// SP = 0x0 - check OK
}

// 0x3558
anim_loop_packet( guypackets, scene, ender, animname_override, n_lerp_time )
{
	ender = "stop_loop";
	baseguy = undefined;
	i = 0;
	guy = guypackets[i]["guy"];
	guy = guy get_anim_ent();
	baseguy = guy;
/#
	self thread looping_anim_ender( baseguy, ender );
#/
	guy._animactive = 0;
	guy _stop_anim_threads();
	guy.anim_loop_ender = ender;
	guy endon( ender );
	guy endon( "death" );
	guy._animactive++;
	i++;
	self endon( ender );
/#
	baseguy.loops = 0;
	thread printloops( baseguy, scene );
#/
	anim_string = "looping anim";
	base_animname = undefined;
	base_animname = animname_override;
	base_animname = baseguy.animname;
/#
	assert( isarray( level.scr_anim[base_animname][scene] ), "Looping anims must have an array entry in level.scr_anim! i.e. [animname][scene][0]" );
#/
	idleanim = 0;
	lastidleanim = 0;
	idleanim = anim_weight( base_animname, scene );
	idleanim = anim_weight( base_animname, scene );
	lastidleanim = idleanim;
	scriptedanimationindex = -1;
	scriptedanimationtime = 999999;
	scriptedsoundindex = -1;
	i = 0;
	guy = guypackets[i]["guy"];
	blend_in = guy._anim_blend_in_time;
	blend_out = guy._anim_blend_out_time;
/#
	iprintlnbold( "I am dead YEAH!!!!!" );
#/
	return;
	guy = guy get_anim_ent();
	pos = get_anim_position( guypackets[i]["tag"] );
	org = pos["origin"];
	angles = pos["angles"];
	entity = guypackets[i]["entity"];
	org = guy.origin;
	angles = guy.angles;
	dofacialanim = 0;
	dodialogue = 0;
	doanimation = 0;
	dotext = 0;
	facialanim = undefined;
	dialogue = undefined;
	animname = undefined;
	animname = animname_override;
	animname = guy.animname;
	dofacialanim = 1;
	facialanim = level.scr_face[animname][scene][idleanim];
	dodialogue = 1;
	dialogue = level.scr_sound[animname][scene][idleanim];
	dodialogue = 1;
	dialogue = level.scr_sound[animname][scene + "_pg"][idleanim];
	guy playsound( level.scr_animsound[animname][idleanim + scene] );
/#
	guy thread animsound_start_tracker_loop( scene, idleanim, animname );
#/
	doanimation = 1;
/#
	dotext = 1;
#/
/#
	self thread rec_anim_origin_render( org, angles );
	self thread anim_info_render_thread( guy, scene, org, angles, animname, ender, 0 );
#/
	guy.origin = org;
	guy.angles = angles;
	guy setflaggedanimknobrestart( anim_string, level.scr_anim[animname][scene][idleanim], 1, blend_in, 1 );
	guy last_anim_time_check();
	guy animscripted( anim_string, org, angles, level.scr_anim[animname][scene][idleanim], "normal", undefined, undefined, blend_in, n_lerp_time );
	guy notify( "_anim_playing" );
	animtime = getanimlength( level.scr_anim[animname][scene][idleanim] );
	scriptedanimationtime = animtime;
	scriptedanimationindex = i;
	thread notetrack_wait( guy, anim_string, scene, animname );
	thread animscriptdonotetracksthread( guy, anim_string );
	guy sayspecificdialogue( facialanim, dialogue, 1 );
	guy sayspecificdialogue( facialanim, dialogue, 1, anim_string );
	scriptedsoundindex = i;
/#
	iprintlnbold( level.scr_text[animname][scene] );
#/
	i++;
	guypackets[scriptedanimationindex]["guy"] get_anim_ent() waittillmatch( anim_string );
	return "end";
	guypackets[scriptedsoundindex]["guy"] get_anim_ent() waittill( anim_string );
// SP = 0x0 - check OK
}

// 0x3B10
anim_single_failsafeonguy( owner, scene )
{
/#
	owner endon( scene );
	owner endon( "death" );
	self endon( "death" );
	name = self.classname;
	num = self getentnum();
	wait 60;
	println( "Guy had classname " + name + " and entnum " + num );
	waittillframeend;
/#
	assert( 0, "Animation \"" + scene + "\" did not finish after 60 seconds. See note above" );
#/
#/
// SP = 0x0 - check OK
}

// 0x3B90
anim_single_failsafe( guy, scene )
{
	i = 0;
	guy[i] thread anim_single_failsafeonguy( self, scene );
	i++;
// SP = 0x0 - check OK
}

// 0x3BC8
do_anim_single( guys, scene, tag, animname_override, aligned, n_lerp_time )
{
/#
	thread anim_single_failsafe( guys, scene );
#/
	pos = get_anim_position( tag );
	org = pos["origin"];
	angles = pos["angles"];
	tracker = spawnstruct();
	tracker.scriptedanimationtime = 999999;
	tracker.scriptedanimationindex = -1;
	tracker.scriptedsoundindex = -1;
	tracker.scriptedfaceindex = -1;
/#
	self thread rec_anim_origin_render( org, angles );
#/
	i = 0;
/#
	assertmsg( "_anim::do_anim_single - trying to play animation on undefined ent." );
#/
	return;
	thread anim_single_thread( guys, i, scene, org, angles, animname_override, aligned, n_lerp_time, tracker );
	i++;
	ent = spawnstruct();
	ent thread anim_deathnotify( guys[tracker.scriptedanimationindex], scene );
	ent thread anim_animationendnotify( guys[tracker.scriptedanimationindex], scene );
	ent waittill( scene );
	ent = spawnstruct();
	ent thread anim_deathnotify( guys[tracker.scriptedfaceindex], scene );
	ent thread anim_facialendnotify( guys[tracker.scriptedfaceindex], scene );
	ent waittill( scene );
	ent = spawnstruct();
	ent thread anim_deathnotify( guys[tracker.scriptedsoundindex], scene );
	ent thread anim_dialogueendnotify( guys[tracker.scriptedsoundindex], scene );
	ent waittill( scene );
	i = 0;
	guys[i]._animactive--;
	guys[i]._lastanimtime = GetTime();
/#
	assert( guys[i]._animactive >= 0 );
#/
	i++;
	self notify( scene );
// SP = 0x0 - check OK
}

// 0x3E00
_stop_anim_threads()
{
	self notify( self.anim_loop_ender );
	self notify( "stop_single" );
	self notify( "stop_sequencing_notetracks" );
// SP = 0x0 - check OK
}

// 0x3E24
anim_single_thread( guys, index, scene, org, angles, animname_override, aligned, n_lerp_time, tracker )
{
	guy = guys[index];
	guy endon( "death" );
	guy _stop_anim_threads();
	blend_in = guy._anim_blend_in_time;
	blend_out = guy._anim_blend_out_time;
	n_rate = 1;
	n_rate = guy._anim_rate;
	guy._animactive = 0;
	guy._animactive++;
	dofacialanim = 0;
	dodialogue = 0;
	dotext = 0;
	dolook = 0;
	dialogue = undefined;
	facialanim = undefined;
	anim_string = "single anim";
	guy = guy get_anim_ent();
	animname = undefined;
	animname = animname_override;
	animname = guy.animname;
/#
	guy assert_existance_of_anim( scene, animname );
#/
	dofacialanim = 1;
	facialanim = level.scr_face[animname][scene];
	dodialogue = 1;
	dialogue = level.scr_sound[animname][scene];
	dodialogue = 1;
	dialogue = level.scr_sound[animname][scene + "_pg"];
	dolook = 1;
	guy playsoundontag( level.scr_animsound[animname][scene], "J_Head" );
	guy playsound( level.scr_animsound[animname][scene] );
/#
	guy thread animsound_start_tracker( scene, animname );
	dotext = 1;
#/
	animation = guy get_anim( scene, animname_override );
/#
	self thread anim_info_render_thread( guy, scene, org, angles, animname, scene, 1 );
#/
	guy.a.coveridleonly = 0;
	animtime = getanimlength( animation );
	tracker.scriptedanimationtime = animtime;
	tracker.scriptedanimationindex = index;
	veh_org = getstartorigin( org, angles, animation );
	veh_ang = getstartangles( org, angles, animation );
	guy.origin = veh_org;
	guy.angles = veh_ang;
	guy setflaggedanimknobrestart( anim_string, animation, 1, 0.2, 1 );
/#
	assert( IsDefined( angles ), "Alignment node does not have angles specified." );
#/
	guy animscripted( anim_string, org, angles, animation, "normal", undefined, n_rate, blend_in, n_lerp_time );
	guy wait_for_foot_sync();
	guy animscripted( anim_string, guy.origin, guy.angles, animation, "normal", undefined, n_rate, blend_in );
	guy last_anim_time_check();
	cut_time = 0;
	cut_time = blend_out;
	guy thread earlyout_animscripted( animation, cut_time );
	guy notify( "_anim_playing" );
	thread notetrack_wait( guy, anim_string, scene, animname );
	thread animscriptdonotetracksthread( guy, anim_string );
/#
	assert( IsDefined( animation ), "Look animation \"" + scene + "\" for animname \"" + animname + "\" does not have a base animation" );
#/
	thread anim_look( guy, scene, level.scr_look[animname][scene] );
	guy thread delayeddialogue( scene, dofacialanim, dialogue, level.scr_face[animname][scene] );
/#
	assert( !(0), "Can't play a facial anim and fullbody anim at the same time. The facial anim should be in the full body anim. Occurred on animation \"" + scene + "\"" );
#/
	thread anim_facialanim( guy, scene, level.scr_face[animname][scene] );
	tracker.scriptedfaceindex = index;
	guy sayspecificdialogue( facialanim, dialogue, 1 );
	guy thread anim_facialfiller( "single dialogue" );
	guy sayspecificdialogue( facialanim, dialogue, 1, "single dialogue" );
	tracker.scriptedsoundindex = index;
/#
	assert( dotext, "Tried to do anim scene " + scene + " on guy with animname " + animname + ", but he didn't have that anim scene." );
#/
/#
	iprintlnbold( level.scr_text[animname][scene] );
	wait 1.5;
#/
// SP = 0x0 - check OK
}

// 0x440C
wait_for_foot_sync()
{
	self endon( "death" );
	self endon( "foot_sync_timeout" );
	self thread wait_for_foot_sync_timeout();
	self waittillmatch( "runanim" );
	return "footstep_left_large";
	self notify( "foot_sync" );
/#
	println( "foot sync" );
	record3dtext( "foot sync", self.origin, ( 1, 0, 0 ), "ScriptedAnim", self );
#/
// SP = 0x0 - check OK
}

// 0x4460
wait_for_foot_sync_timeout()
{
	self endon( "foot_sync" );
	self endon( "death" );
	wait 0.05;
	self notify( "foot_sync_timeout" );
/#
	println( "foot sync failed" );
	record3dtext( "foot sync failed", self.origin, ( 1, 0, 0 ), "ScriptedAnim", self );
#/
// SP = 0x0 - check OK
}

// 0x44BC
anim_deathnotify( guy, scene )
{
	self endon( scene );
	guy waittill( "death" );
	self notify( scene );
// SP = 0x0 - check OK
}

// 0x44D8
anim_facialendnotify( guy, scene )
{
	self endon( scene );
	guy waittillmatch( "face_done_" + scene );
	return "end";
	self notify( scene );
// SP = 0x0 - check OK
}

// 0x44FC
anim_dialogueendnotify( guy, scene )
{
	self endon( scene );
	guy waittill( "single dialogue" );
	self notify( scene );
// SP = 0x0 - check OK
}

// 0x4518
anim_animationendnotify( guy, scene )
{
	self endon( scene );
	guy waittillmatch( "single anim" );
	return "end";
	self notify( scene );
// SP = 0x0 - check OK
}

// 0x453C
animscriptdonotetracksthread( guy, animstring )
{
	guy endon( "stop_sequencing_notetracks" );
	guy endon( "death" );
	guy donotetracks( animstring );
// SP = 0x0 - check OK
}

// 0x4564
add_animsound( newsound )
{
	i = 0;
	self.animsounds[i] = newsound;
	return;
	i++;
	keys = getarraykeys( self.animsounds );
	index = keys[0];
	timer = self.animsounds[index].end_time;
	i = 1;
	key = keys[i];
	timer = self.animsounds[key].end_time;
	index = key;
	i++;
	self.animsounds[index] = newsound;
// SP = 0x0 - check OK
}

// 0x461C
animsound_exists( scene, notetrack )
{
	keys = getarraykeys( self.animsounds );
	i = 0;
	key = keys[i];
	self.animsounds[key].end_time = GetTime() + 60000;
	return 1;
	i++;
	return 0;
// SP = 0x0 - check OK
}

// 0x46A0
animsound_tracker( scene, notetrack, animname )
{
	add_to_animsound();
	return;
	return;
	newtrack = spawnstruct();
	newtrack.scene = scene;
	newtrack.notetrack = notetrack;
	newtrack.animname = animname;
	newtrack.end_time = GetTime() + 60000;
	add_animsound( newtrack );
// SP = 0x0 - check OK
}

// 0x471C
animsound_start_tracker( scene, animname )
{
	add_to_animsound();
	newsound = spawnstruct();
	newsound.scene = scene;
	newsound.notetrack = "#" + scene;
	newsound.animname = animname;
	newsound.end_time = GetTime() + 60000;
	return;
	add_animsound( newsound );
// SP = 0x0 - check OK
}

// 0x4790
animsound_start_tracker_loop( scene, loop, animname )
{
	add_to_animsound();
	scene = loop + scene;
	newsound = spawnstruct();
	newsound.scene = scene;
	newsound.notetrack = "#" + scene;
	newsound.animname = animname;
	newsound.end_time = GetTime() + 60000;
	return;
	add_animsound( newsound );
// SP = 0x0 - check OK
}

// 0x4810
notetrack_wait( guy, msg, scene, animname_override )
{
	guy endon( "death" );
	guy notify( "stop_sequencing_notetracks" );
	guy endon( "stop_sequencing_notetracks" );
	tag_owner = self;
	animname = undefined;
	animname = animname_override;
	animname = guy.animname;
	dialogue_array = [];
	has_scripted_notetracks = IsDefined( level.scr_notetrack[animname] );
	i = 0;
	scr_notetrack = level.scr_notetrack[animname][i];
	dialogue_array[scr_notetrack["dialog"]] = 1;
	i++;
	notetrack = "start";
	dialoguenotetrack = 0;
/#
	guy thread animsound_tracker( scene, notetrack, animname );
#/
	guy do_vehicle_notetracks( notetrack );
	i = 0;
	scr_notetrack = level.scr_notetrack[animname][i];
	self thread [[scr_notetrack["function"]]]( guy, notetrack );
	self thread [[scr_notetrack["function"]]]( guy );
	flag_set( level.scr_notetrack[animname][i]["flag"] );
	exploder( level.scr_notetrack[animname][i]["exploder"] );
	stop_exploder( level.scr_notetrack[animname][i]["stop_exploder"] );
	guy gun_pickup_left();
	guy gun_pickup_right();
	guy gun_leave_behind( scr_notetrack );
	guy detach( guy.swapweapon, scr_notetrack["swap from"] );
	guy attach( guy.swapweapon, scr_notetrack["self tag"] );
	guy attach( scr_notetrack["attach model"], scr_notetrack["selftag"] );
	tag_owner attach( scr_notetrack["attach model"], scr_notetrack["tag"] );
	guy attach( scr_notetrack["attach model"] );
	waittillframeend;
	guy detach( scr_notetrack["detach model"], scr_notetrack["selftag"] );
	tag_owner detach( scr_notetrack["detach model"], scr_notetrack["tag"] );
	guy detach( scr_notetrack["attach model"] );
	level notify( scr_notetrack["level notify"] );
	tokens = strtok( scr_notetrack["change fov"], "_" );
/#
	assert( tolower( tokens[0] ) == "fov" );
#/
	new_fov = int( int( tokens[1] ) * 1.27 );
	lerp_time = int( tokens[2] );
	get_players()[0] thread lerp_fov_overtime( lerp_time, new_fov, 1 );
	get_players()[0] setclientdvar( "cg_fov", new_fov );
/#
	assert( tolower( tokens[1] ) == "reset" );
#/
	lerp_time = int( tokens[2] );
	get_players()[0] thread lerp_fov_overtime( lerp_time, GetDvarFloat( #"0x55DDAF3D" ), 1 );
	get_players()[0] resetfov();
	get_players()[0] thread lerp_fov_overtime( scr_notetrack["time"], scr_notetrack["fov"], 1 );
	guy thread play_sound_on_tag( scr_notetrack["sound"], undefined, 1 );
	anim_facial( guy, i, "dialog", animname );
	dialogue_array[scr_notetrack["dialog"]] = undefined;
	dialoguenotetrack = 1;
	anim_addmodel( guy, scr_notetrack );
	anim_removemodel( guy, scr_notetrack );
	playfxontag( level._effect[scr_notetrack["effect"]], guy, scr_notetrack["selftag"] );
	playfxontag( level._effect[scr_notetrack["effect"]], tag_owner, scr_notetrack["tag"] );
	tag = random( level.scr_special_notetrack[animname] );
	playfxontag( level._effect[tag["effect"]], tag_owner, tag["tag"] );
	playfxontag( level._effect[tag["effect"]], self, tag["tag"] );
	i++;
	prefix = getsubstr( notetrack, 0, 3 );
	alias = getsubstr( notetrack, 3 );
	guy thread play_sound_on_tag( alias, undefined, 1 );
	return;
	guy waittill( msg, notetrack );
// SP = 0x0 - check OK
}

// 0x4EF8
do_vehicle_notetracks( notetrack )
{
	n_weapon_index = 0;
	n_weapon_index = int( notetrack[9] );
	self thread maps\_turret::fire_turret_for_time( -1, n_weapon_index );
	n_weapon_index = int( notetrack[8] );
	maps\_turret::stop_turret( n_weapon_index, 0 );
	n_weapon_index = int( notetrack[4] );
	maps\_turret::fire_turret( n_weapon_index );
// SP = 0x0 - check OK
}

// 0x4FF8
anim_addmodel( guy, array )
{
	guy.scriptmodel = [];
	index = guy.scriptmodel.size;
	guy.scriptmodel[index] = spawn( "script_model", ( 0, 0, 0 ) );
	guy.scriptmodel[index] setmodel( array["create model"] );
	guy.scriptmodel[index].origin = guy gettagorigin( array["selftag"] );
	guy.scriptmodel[index].angles = guy gettagangles( array["selftag"] );
// SP = 0x0 - check OK
}

// 0x5098
anim_removemodel( guy, array )
{
/#
/#
	assertmsg( "Tried to remove a model with delete model before it was create model'd on guy: " + guy.animname );
#/
#/
	i = 0;
	forward = anglestoforward( guy.scriptmodel[i].angles );
	forward = vector_scale( forward, 120 );
	forward += guy.scriptmodel[i].origin;
	playfx( level._effect[array["explosion"]], guy.scriptmodel[i].origin );
	radiusdamage( guy.scriptmodel[i].origin, 350, 700, 50 );
	guy.scriptmodel[i] delete();
	i++;
// SP = 0x0 - check OK
}

// 0x5180
anim_facial( guy, i, dialoguestring, animname )
{
	facialanim = undefined;
	facialanim = level.scr_notetrack[animname][i]["facial"];
	dialogue = undefined;
	dialogue = level.scr_notetrack[animname][i][dialoguestring];
	dialogue = level.scr_notetrack[animname][i]["pg_" + dialoguestring];
	guy sayspecificdialogue( facialanim, dialogue, 1 );
// SP = 0x0 - check OK
}

// 0x523C
gun_pickup_left()
{
	return;
	self.gun_on_ground delete();
	self.dropweapon = 1;
	self animscripts\shared::placeweaponon( self.weapon, "left" );
// SP = 0x0 - check OK
}

// 0x5278
gun_pickup_right()
{
	return;
	self.gun_on_ground delete();
	self.dropweapon = 1;
	self animscripts\shared::placeweaponon( self.weapon, "right" );
// SP = 0x0 - check OK
}

// 0x52B4
gun_leave_behind( scr_notetrack )
{
	return;
	gun = spawn( "script_model", ( 0, 0, 0 ) );
	gun setmodel( self.weaponmodel );
	self.gun_on_ground = gun;
	gun.origin = self gettagorigin( scr_notetrack["tag"] );
	gun.angles = self gettagangles( scr_notetrack["tag"] );
	self animscripts\shared::placeweaponon( self.weapon, "none" );
	self.dropweapon = 0;
// SP = 0x0 - check OK
}

// 0x5334
anim_weight( animname, scene )
{
	total_anims = level.scr_anim[animname][scene].size;
	idleanim = randomint( total_anims );
	weights = 0;
	anim_weight = 0;
	i = 0;
	weights++;
	anim_weight += level.scr_anim[animname][scene + "weight"][i];
	i++;
	anim_play = randomfloat( anim_weight );
	anim_weight = 0;
	i = 0;
	anim_weight += level.scr_anim[animname][scene + "weight"][i];
	idleanim = i;
	i++;
	return idleanim;
// SP = 0x0 - check OK
}

// 0x542C
get_anim_position( tag )
{
	org = undefined;
	angles = undefined;
	org = self gettagorigin( tag );
	angles = self gettagangles( tag );
	org = self.origin;
	angles = self.angles;
	array = [];
	array["angles"] = angles;
	array["origin"] = org;
	return array;
// SP = 0x0 - check OK
}

// 0x5494
do_anim_reach( guys, scene, tag, animname_override, aligned )
{
	array = get_anim_position( tag );
	org = array["origin"];
	angles = array["angles"];
	debugstartpos = 0;
/#
	debugstartpos = getdebugdvar( "debug_animreach" ) == "on";
#/
	threads = 0;
	tracker = spawnstruct();
	newguys[newguys.size] = guys;
	guys = newguys;
	i = 0;
	guy = guys[i];
	animation = guy get_anim( scene, animname_override );
	startorg = getstartorigin( org, angles, animation );
	startorg = org;
/#
	thread debug_message_clear( "x", startorg, 1000, "clearAnimDebug" );
#/
	threads++;
	disablearrivals = 1;
	notetracks = getnotetracksindelta( animation, 0, 1 );
	disablearrivals = 0;
	self thread begin_anim_reach( guy, tracker, startorg, disablearrivals, aligned );
	i++;
	tracker waittill( "reach_notify" );
	threads--;
/#
	level notify( "x" + "clearAnimDebug" );
#/
// SP = 0x0 - check OK
}

// 0x5624
anim_spawner_teleport( guy, scene, tag )
{
	pos = get_anim_position( tag );
	org = pos["origin"];
	angles = pos["angles"];
	i = 0;
	animation = guy[i] get_anim( scene );
	startorg = getstartorigin( org, angles, animation );
	guy[i].origin = startorg;
	i++;
// SP = 0x0 - check OK
}

// 0x56A4
reach_death_notify( guy )
{
	self endon( "reach_notify" );
	self waittill_any( "death", "_anim_reach", "_anim_playing", "_anim_stopped" );
	self notify( "reach_notify" );
// SP = 0x0 - check OK
}

// 0x56D8
begin_anim_reach( guy, tracker, startorg, disablearrivals, aligned )
{
	guy endon( "death" );
	guy notify( "stop_going_to_node" );
	guy notify( "_anim_reach" );
	guy endon( "_anim_reach" );
	waittillframeend;
	tracker thread reach_death_notify( guy );
	guy._anim_old_disablearrivals = guy.disablearrivals;
	guy._anim_old_fixednode = guy.fixednode;
	goal = startorg;
	guy.a.coveridleonly = 1;
	disablearrivals = 0;
	goal = self;
	aligned = 1;
	guy.fixednode = 1;
	guy.fixednode = 0;
	guy.stopanimdistsq = 0.0001;
	guy.stopanimdistsq = 0;
	guy.disablearrivals = disablearrivals;
	goal_radius = 50;
	goal_radius = 0;
	guy thread force_goal( goal, goal_radius, 1, "anim_reach_done" );
	guy thread end_anim_reach();
	guy waittill( "goal" );
	tracker notify( "reach_notify" );
// SP = 0x0 - check OK
}

// 0x5804
end_anim_reach()
{
	self endon( "death" );
	self waittill_any( "_anim_reach", "_anim_playing", "_anim_stopped" );
	self notify( "anim_reach_done" );
	self.disablearrivals = self._anim_old_disablearrivals;
	self.fixednode = self._anim_old_fixednode;
	self.stopanimdistsq = 0;
	self._anim_old_fixednode = undefined;
	self._anim_old_disablearrivals = undefined;
// SP = 0x0 - check OK
}

// 0x5850
printloops( guy, scene )
{
/#
	guy endon( "death" );
	waittillframeend;
	guy.loops++;
/#
	assertmsg( "guy with name " + guy.animname + " has " + guy.loops + " looping animations played, scene: " + scene );
#/
#/
// SP = 0x0 - check OK
}

// 0x58AC
looping_anim_ender( guy, ender )
{
/#
	guy endon( "death" );
	waittill_any_ents_two( self, ender, guy, ender );
	guy.loops--;
#/
// SP = 0x0 - check OK
}

// 0x58DC
get_animtree( guy )
{
	i = 0;
	guy[i] useanimtree( level.scr_animtree[guy[i].animname] );
	i++;
// SP = 0x0 - check OK
}

// 0x591C
setanimtree()
{
	self useanimtree( level.scr_animtree[self.animname] );
// SP = 0x0 - check OK
}

// 0x5938
anim_single_queue( guy, scene, tag )
{
/#
	assert( IsDefined( scene ), "Tried to do anim_single_queue without passing a scene name (scene)" );
#/
	wait_for_buffer_time_to_pass( guy.last_queue_time, 0.5 );
	function_stack( ::anim_single_aligned, guy, scene, tag );
	guy.last_queue_time = GetTime();
// SP = 0x0 - check OK
}

// 0x599C
anim_pushplayer( guy )
{
	i = 0;
	guy[i] pushplayer( 1 );
	i++;
// SP = 0x0 - check OK
}

// 0x59D0
addnotetrack_custom( animname, scene, notetrack, index1_str, index1_val, index2_str, index2_val )
{
	level.scr_notetrack[animname] = [];
	num = level.scr_notetrack[animname].size;
	add_note = [];
	add_note["notetrack"] = notetrack;
	add_note["scene"] = scene;
	add_note[index1_str] = index1_val;
	add_note[index2_str] = index2_val;
	level.scr_notetrack[animname][num] = add_note;
// SP = 0x0 - check OK
}

// 0x5A4C
anim_ents( ents, scene, tag, animname )
{
	ents = build_ent_array( ents );
	pos = get_anim_position( tag );
	origin = pos["origin"];
	angles = pos["angles"];
	parent_model = undefined;
	animname = ents[0].animname;
/#
	assert( IsDefined( animname ), "_anim::anim_ents() - Animname is not defined" );
#/
	parent_model = spawn( "script_model", origin );
	parent_model.angles = angles;
	parent_model.animname = animname;
	parent_model setanimtree();
	parent_model setmodel( level.scr_model[animname] );
	i = 0;
/#
	assert( IsDefined( ents[i].script_linkto ), "_anim::anim_ents() - Entity at " + ents[i].origin + " does not have a script_linkto Key/Value" );
#/
	ents[i] linkto( parent_model, ents[i].script_linkto );
	ents[i] setanimtree();
	ents[i] setflaggedanimknob( "ent_anim", get_anim( scene, animname ), 1, 0.2, 1 );
	thread notetrack_wait( ents[i], "ent_anim", scene, animname );
	ents[i] notify( "_anim_playing" );
	i++;
	parent_model setflaggedanimknob( "ent_anim", get_anim( scene, animname ), 1, 0.2, 1 );
	thread notetrack_wait( parent_model, "ent_anim", scene, animname );
	parent_model waittillmatch( "ent_anim" );
	return "end";
	self notify( scene );
// SP = 0x0 - check OK
}

// 0x5C3C
anim_look( guy, scene, array )
{
	guy endon( "death" );
	self endon( scene );
	wait 0.05;
	guy setflaggedanimknobrestart( "face_done_" + scene, array["left"], 1, 0.2, 1 );
	thread clearfaceanimonanimdone( guy, "face_done_" + scene, scene );
	guy setanimknobrestart( array["right"], 1, 0.2, 1 );
	guy setanim( %scripted, 0.01, 0.3, 1 );
	destyaw = guy getyawtoorigin( level.player.origin );
	animweights["left"] = 1;
	animweights["right"] = 0.01;
	middlefraction = ( array["right_angle"] - destyaw ) / ( array["right_angle"] - array["left_angle"] );
	middlefraction = 0.01;
	middlefraction = 1 - 0.01;
	animweights["left"] = middlefraction;
	animweights["right"] = 1 - middlefraction;
	animweights["left"] = 0.01;
	animweights["right"] = 1;
	wait 0.05;
// SP = 0x0 - check OK
}

// 0x5DC0
anim_facialanim( guy, scene, faceanim )
{
	guy endon( "death" );
	self endon( scene );
	guy notify( "newLookTarget" );
	waittillframeend;
	guy setanim( %scripted_look_straight, 0, 0 );
	guy setanim( %scripted_look_straight, 1, 0.5 );
	guy setflaggedanimknobrestart( "face_done_" + scene, faceanim, 1, 0, 1 );
	thread clearfaceanimonanimdone( guy, "face_done_" + scene, scene );
// SP = 0x0 - check OK
}

// 0x5E3C
anim_facialfiller( msg, looktarget )
{
	self endon( "death" );
	changetime = 0.05;
	self notify( "newLookTarget" );
	self endon( "newLookTarget" );
	waittillframeend;
	looktarget = self.looktarget;
	thread chatattarget( msg, looktarget );
	return;
	self set_talker_until_msg( msg );
	changetime = 0.3;
	self clearanim( %scripted_look_straight, changetime );
// SP = 0x0 - check OK
}

// 0x5EC0
set_talker_until_msg( msg, talkanim )
{
	self endon( msg );
	self sendfaceevent( "face_talk" );
	wait 0.05;
// SP = 0x0 - check OK
}

// 0x5EEC
talk_for_time( timer )
{
	self endon( "death" );
	talkanim = %generic_talker_allies;
	talkanim = %generic_talker_axis;
	self setanimknobrestart( talkanim, 1, 0, 1 );
	self setanim( %scripted_talking, 1, 0.1 );
	wait timer;
	self clearanim( %scripted_talking, 0.1 );
	self clearanim( %scripted_look_straight, 0.3 );
// SP = 0x0 - check OK
}

// 0x5F80
getyawangles( angles1, angles2 )
{
	yaw = angles1[1] - angles2[1];
	yaw = angleclamp180( yaw );
	return yaw;
// SP = 0x0 - check OK
}

// 0x5FA4
chatattarget( msg, looktarget )
{
	self endon( msg );
	self endon( "death" );
	self thread lookrecenter( msg );
	array["right"] = %generic_lookupright;
	array["left"] = %generic_lookupleft;
	array["left_angle"] = -65;
	array["right_angle"] = 65;
	org = looktarget.origin;
	moverange = 2;
	org = looktarget.origin;
/#
	thread lookline( org, msg );
#/
	angles = anglestoright( self gettagangles( "J_Spine4" ) );
	angles = vector_scale( angles, 10 );
	angles = vectortoangles( ( 0, 0, 0 ) - angles );
	yaw = angles[1] - vectortoangles( org - self.origin )[1];
	destyaw = angleclamp180( yaw );
	moverange = abs( destyaw - self.a.lookangle ) * 1;
	self.a.lookangle += moverange;
	self.a.lookangle -= moverange;
	self.a.lookangle = destyaw;
	destyaw = self.a.lookangle;
	animweights["left"] = 1;
	animweights["right"] = 0.01;
	middlefraction = ( array["right_angle"] - destyaw ) / ( array["right_angle"] - array["left_angle"] );
	middlefraction = 0.01;
	middlefraction = 1 - 0.01;
	animweights["left"] = middlefraction;
	animweights["right"] = 1 - middlefraction;
	animweights["left"] = 0.01;
	animweights["right"] = 1;
	self setanim( array["left"], animweights["left"], 0.3 );
	self setanim( array["right"], animweights["right"], 0.3 );
	wait 0.3;
// SP = 0x0 - check OK
}

// 0x6218
lookrecenter( msg )
{
	self endon( "newLookTarget" );
	self endon( "death" );
	self waittill( msg );
	self clearanim( %scripted_talking, 0.1 );
	self setanim( %generic_lookupright, 1, 0.3 );
	self setanim( %generic_lookupleft, 1, 0.3 );
	self setanim( %scripted_look_straight, 0.2, 0.1 );
	wait 0.2;
	self clearanim( %scripted_look_straight, 0.2 );
// SP = 0x0 - check OK
}

// 0x62BC
lookline( org, msg )
{
/#
	self notify( "lookline" );
	self endon( "lookline" );
	self endon( msg );
	self endon( "death" );
	line( self geteye(), org + vector_scale( ( 0, 0, 1 ), 60 ), ( 1, 1, 0 ), 1 );
	wait 0.05;
#/
// SP = 0x0 - check OK
}

// 0x6310
reach_idle( guy, scene, idle, ent )
{
	anim_reach_aligned( guy, scene );
	ent.count--;
	ent notify( "reach_idle_goal" );
	anim_loop( guy, idle );
// SP = 0x0 - check OK
}

// 0x634C
delayeddialogue( scene, doanimation, dialogue, animationname )
{
/#
	assert( animhasnotetrack( animationname, "dialog" ), "Animation " + scene + " does not have a dialog notetrack." );
#/
	self waittillmatch( "face_done_" + scene );
	return "dialog";
	self sayspecificdialogue( undefined, dialogue, 1 );
	self sayspecificdialogue( undefined, dialogue, 1, "single dialogue" );
// SP = 0x0 - check OK
}

// 0x63C8
clearfaceanimonanimdone( guy, msg, scene )
{
	guy endon( "death" );
	guy waittillmatch( msg );
	return "end";
	guy clearanim( %scripted_look_straight, 0.3 );
// SP = 0x0 - check OK
}

// 0x6404
anim_start_pos( ents, scene, tag )
{
	ents = build_ent_array( ents );
	pos = get_anim_position( tag );
	org = pos["origin"];
	angles = pos["angles"];
	array_thread( ents, ::set_start_pos, scene, org, angles );
// SP = 0x0 - check OK
}

// 0x645C
set_start_pos( scene, origin, angles, animname_override )
{
	animation = get_anim( scene, animname_override );
	origin = getstartorigin( origin, angles, animation );
	angles = getstartangles( origin, angles, animation );
	self forceteleport( origin, angles );
	self.origin = origin;
	self.angles = angles;
// SP = 0x0 - check OK
}

// 0x64C8
add_to_animsound()
{
	self.animsounds = [];
	isinarray = 0;
	i = 0;
	isinarray = 1;
	i++;
	level.animsounds[level.animsounds.size] = self;
// SP = 0x0 - check OK
}

// 0x6528
anim_self_set_time( scene, time )
{
	self setanimtime( self getanim( scene ), time );
// SP = 0x0 - check OK
}

// 0x654C
last_anim_time_check()
{
	self.last_anim_time = GetTime();
	return;
	time = GetTime();
	wait 0.05;
	self.last_anim_time = time;
// SP = 0x0 - check OK
}

// 0x6584
loopanim_sound_exists( animname, scene, idleanim )
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x65C4
pg_loopanim_sound_exists( animname, scene, idleanim )
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x6610
sound_exists( animname, scene )
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x663C
animation_exists( animname, scene )
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x6668
pg_sound_exists( animname, scene )
{
	return 1;
	return 0;
// SP = 0x0 - check OK
}

// 0x6698
earlyout_animscripted( animation, cut_time, blend_time )
{
	cut_time = 0.3;
	self endon( "death" );
	self endon( "stop_single" );
	blend_time = cut_time;
	return;
	anim_time = getanimlength( animation );
	wait anim_time - cut_time;
	self anim_stopanimscripted( blend_time );
// SP = 0x0 - check OK
}

// 0x66F8
anim_origin_render( org, angles, line_length, str_label )
{
/#
	line_length = 6;
	originendpoint = org + vector_scale( anglestoforward( angles ), line_length );
	originrightpoint = org + vector_scale( anglestoright( angles ), -1 * line_length );
	originuppoint = org + vector_scale( anglestoup( angles ), line_length );
	line( org, originendpoint, ( 1, 0, 0 ) );
	line( org, originrightpoint, ( 0, 1, 0 ) );
	line( org, originuppoint, ( 0, 0, 1 ) );
	print3d( org, str_label, ( 0, 0.3, 0.3 ), 1, 0.05 );
#/
// SP = 0x0 - check OK
}

// 0x67AC
rec_anim_origin_render( org, angles )
{
/#
	originendpoint = org + vector_scale( anglestoforward( angles ), 10 );
	originrightpoint = org + vector_scale( anglestoright( angles ), -10 );
	originuppoint = org + vector_scale( anglestoup( angles ), 10 );
	recordline( org, originendpoint, ( 1, 0, 0 ), "ScriptedAnim" );
	recordline( org, originrightpoint, ( 0, 1, 0 ), "ScriptedAnim" );
	recordline( org, originuppoint, ( 0, 0, 1 ), "ScriptedAnim" );
#/
// SP = 0x0 - check OK
}

// 0x683C
toggle_scene_debug()
{
/#
	setdvar( "scene_debug", 0 );
	level.scene_debug_enabled = getdvarintdefault( "scene_debug", 0 );
	wait 0.05;
#/
// SP = 0x0 - check OK
}

// 0x6878
anim_info_render_thread( guy, scene, org, angles, animname, ender, showblends, b_first_frame )
{
/#
	self thread rec_anim_info_render_thread( guy, scene, org, angles, animname, ender, showblends, b_first_frame );
	guy endon( "death" );
	guy notify( "anim_info_render_thread" );
	guy endon( "anim_info_render_thread" );
	self endon( ender );
	guy endon( ender );
	str_extra_info = "";
	color = ( 1, 1, 0 );
	str_extra_info += "(first frame)";
	str_extra_info += "(missing)";
	color = ( 1, 0, 0 );
	line( guy.origin, org, vector_scale( ( 1, 1, 1 ), 0.3 ), 0.5, 1 );
	sphere( org, 2, vector_scale( ( 1, 1, 1 ), 0.3 ), 0.5, 1 );
	str_align_targetname = level.a_scenes[scene].str_align_targetname;
	print3d( self.origin + vector_scale( ( 0, 0, 1 ), 5 ), "no targetname", str_align_targetname, vector_scale( ( 1, 1, 1 ), 0.3 ), 1, 0.15 );
	guy anim_origin_render( guy.origin, guy.angles );
	print3d( guy.origin, guy getentnum() + ":name:" + animname, color, 0.8, 0.3 );
	print3d( guy.origin - vector_scale( ( 0, 0, 1 ), 5 ), "scene:" + scene, color, 0.8, 0.3 );
	print3d( guy.origin - vector_scale( ( 0, 0, 1 ), 7 ), str_extra_info, color, 0.8, 0.15 );
	v_tag_org = guy gettagorigin( "tag_weapon_right" );
	v_tag_ang = guy gettagangles( "tag_weapon_right" );
	anim_origin_render( v_tag_org, v_tag_ang, 2, "right" );
	v_tag_org = guy gettagorigin( "tag_weapon_left" );
	v_tag_ang = guy gettagangles( "tag_weapon_left" );
	anim_origin_render( v_tag_org, v_tag_ang, 2, "left" );
	v_tag_org = guy gettagorigin( "tag_player" );
	v_tag_ang = guy gettagangles( "tag_player" );
	anim_origin_render( v_tag_org, v_tag_ang, 2, "plr" );
	v_tag_org = guy gettagorigin( "tag_camera" );
	v_tag_ang = guy gettagangles( "tag_camera" );
	anim_origin_render( v_tag_org, v_tag_ang, 2, "cam" );
	wait 0.05;
#/
// SP = 0x0 - check OK
}

// 0x6BB0
rec_anim_info_render_thread( guy, scene, org, angles, animname, ender, showblends, b_first_frame )
{
/#
	guy notify( "anim_info_render_thread" );
	guy endon( "anim_info_render_thread" );
	self endon( ender );
	guy endon( ender );
	guy endon( "death" );
	recordent( guy );
	recordline( guy.origin, org, ( 1, 1, 0 ), "ScriptedAnim", guy );
	blendintime = 0;
	blendintime = guy._anim_blend_in_time;
	recordenttext( "blend-in time: " + blendintime, guy, ( 1, 1, 0 ), "ScriptedAnim" );
	blendouttime = 0;
	blendouttime = guy._anim_blend_out_time;
	recordenttext( "blend-out time: " + blendouttime, guy, ( 1, 1, 0 ), "ScriptedAnim" );
	str_extra_info = "";
	color = ( 1, 1, 0 );
	str_extra_info += "(first frame)";
	str_extra_info += "(missing)";
	color = ( 1, 0, 0 );
	originendpoint = guy.origin + vector_scale( anglestoforward( guy.angles ), 10 );
	anim_origin_render( guy.origin, guy.angles );
	recordenttext( "name: " + animname, guy, color, "ScriptedAnim" );
	recordenttext( "scene: " + scene + str_extra_info, guy, color, "ScriptedAnim" );
	tagplayerorigin = guy gettagorigin( "tag_player" );
	tagplayerangles = guy gettagangles( "tag_player" );
	anim_origin_render( tagplayerorigin, tagplayerangles );
	record3dtext( "plr", tagplayerorigin, ( 1, 1, 0 ), "ScriptedAnim" );
	tagcameraorigin = guy gettagorigin( "tag_camera" );
	tagcameraangles = guy gettagangles( "tag_camera" );
	anim_origin_render( tagcameraorigin, tagcameraangles );
	record3dtext( "cam", tagcameraorigin, ( 1, 1, 0 ), "ScriptedAnim" );
	wait 0.05;
#/
// SP = 0x0 - check OK
}