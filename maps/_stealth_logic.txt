// maps/_stealth_logic.gsc

#include maps\_stealth_behavior;
#include maps\_stealth_logic;
#include maps\_foliage_cover;
#include maps\_anim;
#include maps\_utility;
#include common_scripts\utility;


// 0x1C50
stealth_init( enviroment )
{
	system_init( enviroment );
	thread system_message_loop();
	switch ( enviroment )
	{
		case "foliage":
			level._stealth.enviroment[level._stealth.enviroment.size] = "foliage";
			maps\_foliage_cover::init_foliage_cover();
			break;
	}
	array_thread( getentarray( "stealth_clipbrush", "targetname" ), ::system_handle_clipbrush );
/#
	level thread debug_stealth();
#/
// SP = 0x0 - check OK
}

// 0x1CE0
system_set_detect_ranges( hidden, alert, spotted )
{
	level._stealth.logic.detect_range["hidden"]["prone"] = hidden["prone"];
	level._stealth.logic.detect_range["hidden"]["crouch"] = hidden["crouch"];
	level._stealth.logic.detect_range["hidden"]["stand"] = hidden["stand"];
	level._stealth.logic.detect_range["alert"]["prone"] = alert["prone"];
	level._stealth.logic.detect_range["alert"]["crouch"] = alert["crouch"];
	level._stealth.logic.detect_range["alert"]["stand"] = alert["stand"];
	level._stealth.logic.detect_range["spotted"]["prone"] = spotted["prone"];
	level._stealth.logic.detect_range["spotted"]["crouch"] = spotted["crouch"];
	level._stealth.logic.detect_range["spotted"]["stand"] = spotted["stand"];
// SP = 0x0 - check OK
}

// 0x1E00
system_default_detect_ranges()
{
	hidden = [];
	hidden["prone"] = 70;
	hidden["crouch"] = 600;
	hidden["stand"] = 1024;
	alert = [];
	alert["prone"] = 140;
	alert["crouch"] = 900;
	alert["stand"] = 1500;
	spotted = [];
	spotted["prone"] = 512;
	spotted["crouch"] = 5000;
	spotted["stand"] = 8000;
	system_set_detect_ranges( hidden, alert, spotted );
// SP = 0x0 - check OK
}

// 0x1E94
friendly_default_movespeed_scale()
{
	hidden = [];
	hidden["prone"] = 3;
	hidden["crouch"] = 2;
	hidden["stand"] = 2;
	alert = [];
	alert["prone"] = 2;
	alert["crouch"] = 2;
	alert["stand"] = 2;
	spotted = [];
	spotted["prone"] = 2;
	spotted["crouch"] = 2;
	spotted["stand"] = 2;
	self friendly_set_movespeed_scale( hidden, alert, spotted );
// SP = 0x0 - check OK
}

// 0x1F18
friendly_set_movespeed_scale( hidden, alert, spotted )
{
	self._stealth.logic.movespeed_scale["hidden"]["prone"] = hidden["prone"];
	self._stealth.logic.movespeed_scale["hidden"]["crouch"] = hidden["crouch"];
	self._stealth.logic.movespeed_scale["hidden"]["stand"] = hidden["stand"];
	self._stealth.logic.movespeed_scale["alert"]["prone"] = alert["prone"];
	self._stealth.logic.movespeed_scale["alert"]["crouch"] = alert["crouch"];
	self._stealth.logic.movespeed_scale["alert"]["stand"] = alert["stand"];
	self._stealth.logic.movespeed_scale["spotted"]["prone"] = spotted["prone"];
	self._stealth.logic.movespeed_scale["spotted"]["crouch"] = spotted["crouch"];
	self._stealth.logic.movespeed_scale["spotted"]["stand"] = spotted["stand"];
// SP = 0x0 - check OK
}

// 0x2038
system_init( enviroment )
{
	flag_init( "_stealth_hidden" );
	flag_init( "_stealth_alert" );
	flag_init( "_stealth_spotted" );
	flag_init( "_stealth_found_corpse" );
	flag_set( "_stealth_hidden" );
	level._stealth = spawnstruct();
	level._stealth.logic = spawnstruct();
	enviroment = "default";
	level._stealth.enviroment = [];
	level._stealth.environment[0] = enviroment;
	level._stealth.logic.detection_level = "hidden";
	level._stealth.logic.detect_range = [];
	level._stealth.logic.detect_range["alert"] = [];
	level._stealth.logic.detect_range["hidden"] = [];
	level._stealth.logic.detect_range["spotted"] = [];
	system_default_detect_ranges();
	system_default_corpse_detect_ranges();
	level._stealth.logic.ai_event = [];
	level._stealth.logic.ai_event["ai_eventDistDeath"] = [];
	level._stealth.logic.ai_event["ai_eventDistDeath"]["spotted"] = GetDvar( #"0x2FC7A90A" );
	level._stealth.logic.ai_event["ai_eventDistDeath"]["alert"] = 512;
	level._stealth.logic.ai_event["ai_eventDistDeath"]["hidden"] = 256;
	level._stealth.logic.ai_event["ai_eventDistPain"] = [];
	level._stealth.logic.ai_event["ai_eventDistPain"]["spotted"] = GetDvar( #"0x474AA0EC" );
	level._stealth.logic.ai_event["ai_eventDistPain"]["alert"] = 384;
	level._stealth.logic.ai_event["ai_eventDistPain"]["hidden"] = 256;
	level._stealth.logic.ai_event["ai_eventDistExplosion"] = [];
	level._stealth.logic.ai_event["ai_eventDistExplosion"]["spotted"] = 4000;
	level._stealth.logic.ai_event["ai_eventDistExplosion"]["alert"] = 4000;
	level._stealth.logic.ai_event["ai_eventDistExplosion"]["hidden"] = 4000;
	level._stealth.logic.ai_event["ai_eventDistBullet"] = [];
	level._stealth.logic.ai_event["ai_eventDistBullet"]["spotted"] = GetDvar( #"0x2539E74C" );
	level._stealth.logic.ai_event["ai_eventDistBullet"]["alert"] = 64;
	level._stealth.logic.ai_event["ai_eventDistBullet"]["hidden"] = 64;
	level._stealth.logic.ai_event["ai_eventDistFootstep"] = [];
	level._stealth.logic.ai_event["ai_eventDistFootstep"]["spotted"] = GetDvar( #"0x4612C9F8" );
	level._stealth.logic.ai_event["ai_eventDistFootstep"]["alert"] = 64;
	level._stealth.logic.ai_event["ai_eventDistFootstep"]["hidden"] = 64;
	level._stealth.logic.ai_event["ai_eventDistFootstepLite"] = [];
	level._stealth.logic.ai_event["ai_eventDistFootstepLite"]["spotted"] = GetDvar( #"0x46140CE6" );
	level._stealth.logic.ai_event["ai_eventDistFootstepLite"]["alert"] = 32;
	level._stealth.logic.ai_event["ai_eventDistFootstepLite"]["hidden"] = 32;
	level._stealth.logic.system_state_functions = [];
	level._stealth.logic.system_state_functions["hidden"] = ::system_state_hidden;
	level._stealth.logic.system_state_functions["alert"] = ::system_state_alert;
	level._stealth.logic.system_state_functions["spotted"] = ::system_state_spotted;
	anim.eventactionminwait["threat"]["self"] = 20000;
	anim.eventactionminwait["threat"]["squad"] = 30000;
	system_init_shadows();
// SP = 0x0 - check OK
}

// 0x2408
system_default_corpse_detect_ranges()
{
	level._stealth.logic.corpse = spawnstruct();
	level._stealth.logic.corpse.array = [];
	level._stealth.logic.corpse.last_pos = undefined;
	level._stealth.logic.corpse.max_num = int( GetDvar( #"0x4EED8183" ) );
	level._stealth.logic.corpse.sight_dist = 256;
	level._stealth.logic.corpse.detect_dist = 128;
	level._stealth.logic.corpse.found_dist = 64;
	level._stealth.logic.corpse.sight_distsqrd = level._stealth.logic.corpse.sight_dist * level._stealth.logic.corpse.sight_dist;
	level._stealth.logic.corpse.detect_distsqrd = level._stealth.logic.corpse.detect_dist * level._stealth.logic.corpse.detect_dist;
	level._stealth.logic.corpse.found_distsqrd = level._stealth.logic.corpse.found_dist * level._stealth.logic.corpse.found_dist;
	level._stealth.logic.corpse.corpse_height = [];
	level._stealth.logic.corpse.corpse_height["spotted"] = 10;
	level._stealth.logic.corpse.corpse_height["alert"] = 10;
	level._stealth.logic.corpse.corpse_height["hidden"] = 6;
// SP = 0x0 - check OK
}

// 0x2598
system_init_shadows()
{
	array_thread( getentarray( "_stealth_shadow", "targetname" ), ::stealth_shadow_volumes );
	array_thread( getentarray( "stealth_shadow", "targetname" ), ::stealth_shadow_volumes );
// SP = 0x0 - check OK
}

// 0x25E0
stealth_shadow_volumes()
{
	level endon( "_stealth_stop_stealth_logic" );
	self endon( "_stealth_stop_stealth_logic" );
	self endon( "death" );
	self waittill( "trigger", other );
	other thread stealth_shadow_ai_in_volume( self );
// SP = 0x0 - check OK
}

// 0x2644
system_message_loop()
{
	funcs = level._stealth.logic.system_state_functions;
	thread system_message_handler( "_stealth_hidden", "hidden", funcs["hidden"] );
	thread system_message_handler( "_stealth_alert", "alert", funcs["alert"] );
	thread system_message_handler( "_stealth_spotted", "spotted", funcs["spotted"] );
// SP = 0x0 - check OK
}

// 0x26A4
system_message_handler( _flag, detection_level, function )
{
	level endon( "_stealth_stop_stealth_logic" );
	flag_wait( _flag );
	system_event_change( detection_level );
	level._stealth.logic.detection_level = detection_level;
	level notify( "_stealth_detection_level_change" );
	thread [[function]]();
	flag_waitopen( _flag );
// SP = 0x0 - check OK
}

// 0x2704
system_event_change( name )
{
	keys = getarraykeys( level._stealth.logic.ai_event );
	i = 0;
	key = keys[i];
	setsaveddvar( key, level._stealth.logic.ai_event[key][name] );
	i++;
// SP = 0x0 - check OK
}

// 0x2768
system_state_spotted()
{
	flag_clear( "_stealth_hidden" );
	flag_clear( "_stealth_alert" );
	level endon( "_stealth_detection_level_change" );
	level endon( "_stealth_stop_stealth_logic" );
	waittillframeend;
	ai = getaispeciesarray( "axis", "all" );
	clear = 1;
	ai = getaispeciesarray( "axis", "all" );
	i = 0;
	clear = 0;
	i++;
	wait 1;
	ai = getaispeciesarray( "axis", "all" );
	i = 0;
	clear = 0;
	i++;
	wait 0.1;
	ai = getaispeciesarray( "axis", "all" );
	flag_clear( "_stealth_spotted" );
	flag_set( "_stealth_alert" );
// SP = 0x0 - check OK
}

// 0x2888
system_state_alert()
{
	flag_clear( "_stealth_hidden" );
	level endon( "_stealth_detection_level_change" );
	level endon( "_stealth_stop_stealth_logic" );
	waittillframeend;
	count = 15;
	ai = getaispeciesarray( "axis", "all" );
	wait 0.1;
	count -= 0.1;
	flag_waitopen( "_stealth_found_corpse" );
	flag_clear( "_stealth_spotted" );
	flag_clear( "_stealth_alert" );
	flag_set( "_stealth_hidden" );
// SP = 0x0 - check OK
}

// 0x2920
system_state_hidden()
{
	level endon( "_stealth_detection_level_change" );
	level endon( "_stealth_stop_stealth_logic" );
// SP = 0x0 - check OK
}

// 0x2934
friendly_logic()
{
	self endon( "death" );
	self endon( "pain_death" );
	level endon( "_stealth_stop_stealth_logic" );
	self endon( "_stealth_stop_stealth_logic" );
	self friendly_init();
	current_stance_func = self._stealth.logic.current_stance_func;
	self thread friendly_movespeed_calc_loop();
	self [[current_stance_func]]();
	self.maxvisibledist = self friendly_compute_score();
	wait 0.05;
// SP = 0x0 - check OK
}

// 0x29B0
friendly_init()
{
/#
	assert( !(IsDefined( self._stealth )), "you called maps_stealth_logic::friendly_init() twice on the same ai or player" );
#/
	self._stealth = spawnstruct();
	self._stealth.logic = spawnstruct();
	self._stealth.logic.getstance_func = ::friendly_getstance_player;
	self._stealth.logic.getangles_func = ::friendly_getangles_player;
	self._stealth.logic.getvelocity_func = ::friendly_getvelocity;
	self._stealth.logic.getvelocity_func = ::player_getvelocity_pc;
	self._stealth.logic.player_pc_velocity = 0;
	self._stealth.logic.current_stance_func = ::friendly_compute_stances_player;
	self._stealth.logic.getstance_func = ::friendly_getstance_ai;
	self._stealth.logic.getangles_func = ::friendly_getangles_ai;
	self._stealth.logic.getvelocity_func = ::friendly_getvelocity;
	self._stealth.logic.current_stance_func = ::friendly_compute_stances_ai;
	self._stealth.logic.stance_change_time = 0.2;
	self._stealth.logic.stance_change = 0;
	self._stealth.logic.oldstance = self [[self._stealth.logic.getstance_func]]();
	self._stealth.logic.stance = self [[self._stealth.logic.getstance_func]]();
	self._stealth.logic.spotted_list = [];
	self._stealth.logic.movespeed_multiplier = [];
	self._stealth.logic.movespeed_scale = [];
	self._stealth.logic.movespeed_multiplier["hidden"] = [];
	self._stealth.logic.movespeed_multiplier["hidden"]["prone"] = 0;
	self._stealth.logic.movespeed_multiplier["hidden"]["crouch"] = 0;
	self._stealth.logic.movespeed_multiplier["hidden"]["stand"] = 0;
	self._stealth.logic.movespeed_multiplier["alert"] = [];
	self._stealth.logic.movespeed_multiplier["alert"]["prone"] = 0;
	self._stealth.logic.movespeed_multiplier["alert"]["crouch"] = 0;
	self._stealth.logic.movespeed_multiplier["alert"]["stand"] = 0;
	self._stealth.logic.movespeed_multiplier["spotted"] = [];
	self._stealth.logic.movespeed_multiplier["spotted"]["prone"] = 0;
	self._stealth.logic.movespeed_multiplier["spotted"]["crouch"] = 0;
	self._stealth.logic.movespeed_multiplier["spotted"]["stand"] = 0;
	friendly_default_movespeed_scale();
	self ent_flag_clear( "_stealth_in_shadow" );
	self ent_flag_init( "_stealth_in_shadow" );
	self ent_flag_clear( "_stealth_in_foliage" );
	self ent_flag_init( "_stealth_in_foliage" );
// SP = 0x0 - check OK
}

// 0x2CC8
friendly_getvelocity()
{
	return length( self getvelocity() );
// SP = 0x0 - check OK
}

// 0x2CE4
player_getvelocity_pc()
{
	velocity = length( self getvelocity() );
	stance = self._stealth.logic.stance;
	add = [];
	add["stand"] = 30;
	add["crouch"] = 15;
	add["prone"] = 4;
	sub = [];
	sub["stand"] = 40;
	sub["crouch"] = 25;
	sub["prone"] = 10;
	self._stealth.logic.player_pc_velocity = 0;
	self._stealth.logic.player_pc_velocity += add[stance];
	self._stealth.logic.player_pc_velocity = velocity;
	self._stealth.logic.player_pc_velocity -= sub[stance];
	self._stealth.logic.player_pc_velocity = 0;
	return self._stealth.logic.player_pc_velocity;
// SP = 0x0 - check OK
}

// 0x2E2C
friendly_movespeed_calc_loop()
{
	self endon( "death" );
	self endon( "pain_death" );
	level endon( "_stealth_stop_stealth_logic" );
	self endon( "_stealth_stop_stealth_logic" );
	angles_func = self._stealth.logic.getangles_func;
	velocity_func = self._stealth.logic.getvelocity_func;
	oldangles = self [[angles_func]]();
	score = undefined;
	score = 0;
	score_move = self [[velocity_func]]();
	score_turn = length( oldangles - self [[angles_func]]() );
	score_turn = 30;
	score = score_move + score_turn;
	self._stealth.logic.movespeed_multiplier["hidden"]["prone"] = score * self._stealth.logic.movespeed_scale["hidden"]["prone"];
	self._stealth.logic.movespeed_multiplier["spotted"]["prone"] = score * self._stealth.logic.movespeed_scale["spotted"]["prone"];
	self._stealth.logic.movespeed_multiplier["alert"]["prone"] = score * self._stealth.logic.movespeed_scale["alert"]["prone"];
	self._stealth.logic.movespeed_multiplier["hidden"]["crouch"] = score * self._stealth.logic.movespeed_scale["hidden"]["crouch"];
	self._stealth.logic.movespeed_multiplier["spotted"]["crouch"] = score * self._stealth.logic.movespeed_scale["spotted"]["crouch"];
	self._stealth.logic.movespeed_multiplier["alert"]["crouch"] = score * self._stealth.logic.movespeed_scale["alert"]["crouch"];
	self._stealth.logic.movespeed_multiplier["hidden"]["stand"] = score * self._stealth.logic.movespeed_scale["hidden"]["stand"];
	self._stealth.logic.movespeed_multiplier["spotted"]["stand"] = score * self._stealth.logic.movespeed_scale["spotted"]["stand"];
	self._stealth.logic.movespeed_multiplier["alert"]["stand"] = score * self._stealth.logic.movespeed_scale["alert"]["stand"];
	oldangles = self [[angles_func]]();
	wait 0.1;
// SP = 0x0 - check OK
}

// 0x308C
friendly_compute_score( stance )
{
	stance = self._stealth.logic.stance;
	detection_level = level._stealth.logic.detection_level;
	score_range = level._stealth.logic.detect_range[detection_level][stance];
	score_range *= 0.5;
	score_range = level._stealth.logic.detect_range["hidden"]["prone"];
	score_range = [[maps\_foliage_cover::calculate_foliage_cover]]( stance );
	score_move = self._stealth.logic.movespeed_multiplier[detection_level][stance];
	score_move = self._stealth_move_detection_cap;
	return score_range + score_move;
// SP = 0x0 - check OK
}

// 0x3198
friendly_getstance_ai()
{
	return self.a.pose;
// SP = 0x0 - check OK
}

// 0x31A8
friendly_getstance_player()
{
	players = get_players();
	return players[0] getstance();
// SP = 0x0 - check OK
}

// 0x31CC
friendly_getangles_ai()
{
	return self.angles;
// SP = 0x0 - check OK
}

// 0x31D8
friendly_getangles_player()
{
	return self getplayerangles();
// SP = 0x0 - check OK
}

// 0x31EC
friendly_compute_stances_ai()
{
	self._stealth.logic.stance = self [[self._stealth.logic.getstance_func]]();
	self._stealth.logic.oldstance = self._stealth.logic.stance;
// SP = 0x0 - check OK
}

// 0x322C
friendly_compute_stances_player()
{
	stance = self [[self._stealth.logic.getstance_func]]();
	switch ( stance )
	{
		case "crouch":
			self._stealth.logic.stance_change = self._stealth.logic.stance_change_time;
			break;
		case "prone":
			self._stealth.logic.stance_change = self._stealth.logic.stance_change_time;
			break;
	}
	self._stealth.logic.stance = self._stealth.logic.oldstance;
	self._stealth.logic.stance_change -= 0.05;
	self._stealth.logic.stance_change = 0;
	self._stealth.logic.stance = stance;
	self._stealth.logic.oldstance = stance;
	self._stealth.logic.stance = stance;
	self._stealth.logic.oldstance = stance;
// SP = 0x0 - check OK
}

// 0x3390
enemy_logic()
{
	self enemy_init();
	self thread enemy_threat_logic();
	self thread enemy_corpse_logic();
	self thread enemy_corpse_death();
// SP = 0x0 - check OK
}

// 0x33D0
enemy_init()
{
/#
	assert( !(IsDefined( self._stealth )), "you called maps_stealth_logic::enemy_init() twice on the same ai" );
#/
	self clearenemy();
	self._stealth = spawnstruct();
	self._stealth.logic = spawnstruct();
	self._stealth.logic.dog = 0;
	self._stealth.logic.dog = 1;
	self._stealth.logic.alert_level = spawnstruct();
	self._stealth.logic.alert_level.lvl = undefined;
	self._stealth.logic.alert_level.enemy = undefined;
	self._stealth.logic.stoptime = 0;
	self._stealth.logic.corpse = spawnstruct();
	self._stealth.logic.corpse.corpse_entity = undefined;
	self ent_flag_init( "_stealth_saw_corpse" );
	self ent_flag_init( "_stealth_found_corpse" );
	self enemy_event_listeners_init();
	self ent_flag_init( "_stealth_in_shadow" );
	self ent_flag_init( "_stealth_in_foliage" );
// SP = 0x0 - check OK
}

// 0x34FC
enemy_event_listeners_init()
{
	self ent_flag_init( "_stealth_bad_event_listener" );
	self._stealth.logic.event = spawnstruct();
	self._stealth.logic.event.listener = [];
	self._stealth.logic.event.listener[self._stealth.logic.event.listener.size] = "grenade danger";
	self._stealth.logic.event.listener[self._stealth.logic.event.listener.size] = "gunshot";
	self._stealth.logic.event.listener[self._stealth.logic.event.listener.size] = "silenced_shot";
	self._stealth.logic.event.listener[self._stealth.logic.event.listener.size] = "projectile_impact";
	self._stealth.logic.event.listener[self._stealth.logic.event.listener.size] = "bulletwhizby";
	i = 0;
	self addaieventlistener( self._stealth.logic.event.listener[i] );
	i++;
	self._stealth.logic.event.listener[self._stealth.logic.event.listener.size] = "explode";
	self._stealth.logic.event.listener[self._stealth.logic.event.listener.size] = "doFlashBanged";
	i = 0;
	self thread enemy_event_listeners_logic( self._stealth.logic.event.listener[i] );
	i++;
	self thread enemy_event_declare_to_team( "damage", "ai_eventDistPain" );
	self thread enemy_event_declare_to_team( "death", "ai_eventDistDeath" );
	self thread enemy_event_listeners_proc();
	self._stealth.logic.event.awareness = [];
	self thread enemy_event_awareness( "reset" );
	self thread enemy_event_awareness( "alerted_once" );
	self thread enemy_event_awareness( "alerted_again" );
	self thread enemy_event_awareness( "attack" );
	self thread enemy_event_awareness( "heard_scream" );
	self thread enemy_event_awareness( "heard_corpse" );
	self thread enemy_event_awareness( "saw_corpse" );
	self thread enemy_event_awareness( "found_corpse" );
	self thread enemy_event_awareness( "explode" );
	self thread enemy_event_awareness( "doFlashBanged" );
	self thread enemy_event_awareness( "bulletwhizby" );
	self thread enemy_event_awareness( "projectile_impact" );
// SP = 0x0 - check OK
}

// 0x37F4
enemy_event_listeners_logic( type )
{
	self endon( "death" );
	self endon( "pain_death" );
	level endon( "_stealth_stop_stealth_logic" );
	self endon( "_stealth_stop_stealth_logic" );
	self waittill( type );
	self ent_flag_set( "_stealth_bad_event_listener" );
// SP = 0x0 - check OK
}

// 0x3834
enemy_event_listeners_proc()
{
	self endon( "death" );
	self endon( "pain_death" );
	level endon( "_stealth_stop_stealth_logic" );
	self endon( "_stealth_stop_stealth_logic" );
	self ent_flag_wait( "_stealth_bad_event_listener" );
	wait 0.65;
	self ent_flag_clear( "_stealth_bad_event_listener" );
// SP = 0x0 - check OK
}

// 0x3884
enemy_event_awareness( type )
{
	self endon( "death" );
	self endon( "pain_death" );
	level endon( "_stealth_stop_stealth_logic" );
	self endon( "_stealth_stop_stealth_logic" );
	self._stealth.logic.event.awareness[type] = 1;
	var = undefined;
	self waittill( type, var1, var2 );
	switch ( type )
	{
		case "projectile_impact":
			var = var2;
			break;
		default:
			var = var1;
			break;
	}
	self._stealth.logic.event.awareness[type] = var;
	self notify( "event_awareness", type );
	level notify( "event_awareness", type );
	waittillframeend;
	flag_set( "_stealth_alert" );
// SP = 0x0 - check OK
}

// 0x398C
enemy_event_declare_to_team( type, name )
{
	level endon( "_stealth_stop_stealth_logic" );
	self endon( "_stealth_stop_stealth_logic" );
	other = undefined;
	team = self.team;
	return;
	self waittill( type, var1, var2 );
	switch ( type )
	{
		case "damage":
			other = var1;
			break;
		case "death":
			other = var2;
			break;
	}
	return;
	ai = getaispeciesarray( "axis", "all" );
	check = int( level._stealth.logic.ai_event[name][level._stealth.logic.detection_level] );
	i = 0;
	ai[i] ent_flag_set( "_stealth_bad_event_listener" );
	i++;
// SP = 0x0 - check OK
}

// 0x3AF4
enemy_threat_logic()
{
	self endon( "death" );
	self endon( "pain_death" );
	level endon( "_stealth_stop_stealth_logic" );
	self endon( "_stealth_stop_stealth_logic" );
	self waittill( "enemy" );
	enemy_in_foliage = IsDefined( self.enemy maps\_foliage_cover::get_current_foliage_trigger() );
	self clearenemy();
	wait 0.25;
	self enemy_alert_level_change( "attack", self.enemy );
	self thread enemy_threat_set_spotted();
	wait 20;
	self clearenemy();
	wait 0.25;
	enemy_alert_level_change( "reset", undefined );
// SP = 0x0 - check OK
}

// 0x3C58
enemy_threat_set_spotted()
{
	self endon( "death" );
	self endon( "pain_death" );
	level endon( "_stealth_stop_stealth_logic" );
	self endon( "_stealth_stop_stealth_logic" );
	wait randomfloatrange( 0.25, 0.5 );
	flag_set( "_stealth_spotted" );
// SP = 0x0 - check OK
}

// 0x3C9C
enemy_alert_level_logic( enemy )
{
	return 1;
	enemy._stealth.logic.spotted_list[self.ai_number] = 0;
	enemy._stealth.logic.spotted_list[self.ai_number]++;
	self enemy_alert_level_change( "attack", enemy );
	return 1;
	self clearenemy();
	return 0;
	switch ( enemy._stealth.logic.spotted_list[self.ai_number] )
	{
		case 1:
			self enemy_alert_level_change( "alerted_once", enemy );
			break;
		case 2:
			self enemy_alert_level_change( "alerted_again", enemy );
			break;
	}
	self thread enemy_alert_level_forget( enemy );
	self thread enemy_alert_level_waittime( enemy );
	return 0;
// SP = 0x0 - check OK
}

// 0x3DD0
enemy_alert_level_forget( enemy )
{
	self endon( "death" );
	self endon( "pain_death" );
	level endon( "_stealth_stop_stealth_logic" );
	self endon( "_stealth_stop_stealth_logic" );
	wait 60;
/#
	assert( enemy._stealth.logic.spotted_list[self.ai_number], "enemy._stealth.spotted_list[ self.ai_number ] is already 0 but being told to forget" );
#/
	enemy._stealth.logic.spotted_list[self.ai_number]--;
// SP = 0x0 - check OK
}

// 0x3E2C
enemy_alert_level_waittime( enemy )
{
	self endon( "death" );
	timefrac = distance( self.origin, enemy.origin ) * 0.0005;
	self._stealth.logic.stoptime = 0.25 + timefrac;
	flag_wait_or_timeout( "_stealth_spotted", self._stealth.logic.stoptime );
	self._stealth.logic.stoptime = 0;
// SP = 0x0 - check OK
}

// 0x3E9C
enemy_alert_level_change( type, enemy )
{
	level notify( "_stealth_enemy_alert_level_change" );
	self notify( "_stealth_enemy_alert_level_change" );
	self notify( type, enemy );
	self._stealth.logic.alert_level.lvl = type;
	self._stealth.logic.alert_level.enemy = enemy;
// SP = 0x0 - check OK
}

// 0x3EE4
enemy_corpse_logic()
{
	return;
	self endon( "death" );
	self endon( "pain_death" );
	level endon( "_stealth_stop_stealth_logic" );
	self endon( "_stealth_stop_stealth_logic" );
	self thread enemy_corpse_found_loop();
	found = 0;
	saw = 0;
	corpse = undefined;
	i = 0;
	corpse = level._stealth.logic.corpse.array[i];
	distsqrd = distancesquared( self.origin, corpse.origin );
	found_distsqrd = level._stealth.logic.corpse.foliage_found_distsqrd;
	sight_distsqrd = level._stealth.logic.corpse.foliage_sight_distsqrd;
	detect_distsqrd = level._stealth.logic.corpse.foliage_detect_distsqrd;
	found_distsqrd = level._stealth.logic.corpse.found_distsqrd;
	sight_distsqrd = level._stealth.logic.corpse.sight_distsqrd;
	detect_distsqrd = level._stealth.logic.corpse.detect_distsqrd;
	found = 1;
	distsqrd2 = distancesquared( self.origin, self._stealth.logic.corpse.corpse_entity.origin );
	saw = 1;
	angles = self gettagangles( "tag_eye" );
	origin = self gettagorigin( "tag_eye" );
	sight = anglestoforward( angles );
	vec_to_corpse = vectornormalize( corpse.origin - origin );
	saw = 1;
	i++;
	self ent_flag_set( "_stealth_found_corpse" );
	self notify( "_stealth_found_corpse" );
	self ent_flag_clear( "_stealth_saw_corpse" );
	self thread enemy_corpse_found( corpse );
	self notify( "found_corpse", corpse );
	self._stealth.logic.corpse.corpse_entity = corpse;
	self ent_flag_set( "_stealth_saw_corpse" );
	self notify( "_stealth_saw_corpse" );
	level notify( "_stealth_saw_corpse" );
	self notify( "saw_corpse", corpse );
	wait 0.05;
	flag_waitopen( "_stealth_spotted" );
// SP = 0x0 - check OK
}

// 0x4208
enemy_corpse_death()
{
	level endon( "_stealth_stop_stealth_logic" );
	self endon( "_stealth_stop_stealth_logic" );
	self endon( "_stealth_stop_corpse_logic" );
	id = self.ai_number;
	self waittill( "death" );
	return;
	height = level._stealth.logic.corpse.corpse_height[level._stealth.logic.detection_level];
	offset = ( 0, 0, height );
	corpse = spawn( "script_origin", self.origin + offset );
	corpse.targetname = "corpse";
	corpse.ai_number = id;
	corpse.script_noteworthy = corpse.targetname + "_" + corpse.ai_number;
	corpse.hidden_in_foliage = 1;
	corpse.hidden_in_foliage = 0;
	corpse endon( "death" );
	corpse.origin = self.origin + offset;
	wait 0.01;
	wait 0.25;
	corpse enemy_corpse_add_to_stack();
// SP = 0x0 - check OK
}

// 0x4334
enemy_corpse_add_to_stack()
{
	enemy_corpse_shorten_stack();
	level._stealth.logic.corpse.array[level._stealth.logic.corpse.array.size] = self;
// SP = 0x0 - check OK
}

// 0x4390
enemy_corpse_shorten_stack()
{
	array1 = [];
	array2 = level._stealth.logic.corpse.array;
	remove = level._stealth.logic.corpse.array[0];
	i = 1;
	array1[array1.size] = array2[i];
	i++;
	level._stealth.logic.corpse.array = array1;
	remove delete();
// SP = 0x0 - check OK
}

// 0x4418
enemy_corpse_found( corpse )
{
	level._stealth.logic.corpse.last_pos = corpse.origin;
	arrayremovevalue( level._stealth.logic.corpse.array, corpse );
	level notify( "_stealth_no_corpse_announce" );
	self notify( "event_awareness", "found_corpse" );
	return;
	wait randomfloatrange( 0.25, 0.5 );
	flag_set( "_stealth_found_corpse" );
	level notify( "_stealth_found_corpse" );
	thread enemy_corpse_clear();
// SP = 0x0 - check OK
}

// 0x44B8
enemy_corpse_found_loop()
{
	self endon( "death" );
	self endon( "pain_death" );
	level endon( "_stealth_stop_stealth_logic" );
	self endon( "_stealth_stop_stealth_logic" );
	level waittill( "_stealth_found_corpse" );
	self enemy_corpse_alert_level();
// SP = 0x0 - check OK
}

// 0x4504
enemy_corpse_alert_level()
{
	enemy = undefined;
	enemy = self.enemy;
	enemy = get_closest_player( self.origin );
	enemy._stealth.logic.spotted_list[self.ai_number] = 0;
	switch ( enemy._stealth.logic.spotted_list[self.ai_number] )
	{
		case 0:
			enemy._stealth.logic.spotted_list[self.ai_number]++;
			self thread enemy_alert_level_forget( enemy );
			break;
		case 1:
			enemy._stealth.logic.spotted_list[self.ai_number]++;
			self thread enemy_alert_level_forget( enemy );
			break;
		case 2:
			enemy._stealth.logic.spotted_list[self.ai_number]++;
			self thread enemy_alert_level_forget( enemy );
			break;
	}
	flag_set( "_stealth_alert" );
// SP = 0x0 - check OK
}

// 0x4618
enemy_corpse_clear()
{
	level endon( "_stealth_found_corpse" );
	level endon( "_stealth_stop_stealth_logic" );
	waittill_dead_or_dying( getaiarray( "axis" ), undefined, 90 );
	flag_clear( "_stealth_found_corpse" );
// SP = 0x0 - check OK
}

// 0x4650
stealth_shadow_ai_in_volume( volume )
{
	self endon( "death" );
	level endon( "_stealth_stop_stealth_logic" );
	self endon( "_stealth_stop_stealth_logic" );
	self ent_flag_set( "_stealth_in_shadow" );
	wait 0.05;
	self ent_flag_clear( "_stealth_in_shadow" );
// SP = 0x0 - check OK
}

// 0x46A4
system_handle_clipbrush()
{
	self endon( "death" );
	flag_wait( self.script_flag_wait );
	waittillframeend;
	spotted_flag = "_stealth_spotted";
	corpse_flag = "_stealth_found_corpse";
	event_flag = "_stealth_event";
	self setcandamage( 1 );
	self add_wait( ::waittill_msg, "damage" );
	level add_wait( ::flag_wait, spotted_flag );
	level add_wait( ::flag_wait, corpse_flag );
	level add_wait( ::flag_wait, event_flag );
	do_wait_any();
	self connectpaths();
	self delete();
// SP = 0x0 - check OK
}

// 0x4768
stealth_ai( state_functions, alert_functions, corpse_functions, awareness_functions )
{
	return;
/#
	assert( IsDefined( level._stealth.logic ), "call maps_stealth_logic::main() before calling stealth_ai()" );
#/
	self stealth_ai_logic();
	self stealth_ai_behavior( state_functions, alert_functions, corpse_functions, awareness_functions );
// SP = 0x0 - check OK
}

// 0x47BC
stealth_ai_logic()
{
/#
	assert( IsDefined( level._stealth.logic ), "call maps_stealth_logic::main() before calling stealth_ai_logic()" );
#/
	switch ( self.team )
	{
		case "allies":
			self thread maps\_stealth_logic::friendly_logic();
			break;
		case "axis":
			self thread maps\_stealth_logic::enemy_logic();
			break;
	}
// SP = 0x0 - check OK
}

// 0x4818
stealth_ai_behavior( state_functions, alert_functions, corpse_functions, awareness_functions )
{
/#
	assert( IsDefined( level._stealth.behavior ), "call maps_stealth_behavior::main() before calling stealth_ai_behavior()" );
#/
	return;
	switch ( self.team )
	{
		case "allies":
			self thread maps\_stealth_behavior::friendly_logic( state_functions );
			break;
		case "axis":
			self thread maps\_stealth_behavior::enemy_logic( state_functions, alert_functions, corpse_functions, awareness_functions );
			break;
	}
// SP = 0x0 - check OK
}

// 0x489C
stealth_enemy_waittill_alert()
{
	return;
	level endon( "_stealth_spotted" );
	return;
	level endon( "_stealth_found_corpse" );
	self endon( "_stealth_enemy_alert_level_change" );
	waittillframeend;
	return;
	self endon( "_stealth_saw_corpse" );
	self waittill( "event_awareness", type );
// SP = 0x0 - check OK
}

// 0x48F8
stealth_enemy_endon_alert()
{
	stealth_enemy_waittill_alert();
	waittillframeend;
	self notify( "stealth_enemy_endon_alert" );
// SP = 0x0 - check OK
}

// 0x4910
stealth_detect_ranges_set( hidden, alert, spotted )
{
	maps\_stealth_logic::system_set_detect_ranges( hidden, alert, spotted );
// SP = 0x0 - check OK
}

// 0x4930
stealth_detect_ranges_default()
{
	maps\_stealth_logic::system_default_detect_ranges();
// SP = 0x0 - check OK
}

// 0x4940
stealth_detect_corpse_range_set( sight_dist, detect_dist, found_dist )
{
	level._stealth.logic.corpse.sight_dist = sight_dist;
	level._stealth.logic.corpse.detect_dist = detect_dist;
	level._stealth.logic.corpse.found_dist = found_dist;
	level._stealth.logic.corpse.sight_distsqrd = level._stealth.logic.corpse.sight_dist * level._stealth.logic.corpse.sight_dist;
	level._stealth.logic.corpse.detect_distsqrd = level._stealth.logic.corpse.detect_dist * level._stealth.logic.corpse.detect_dist;
	level._stealth.logic.corpse.found_distsqrd = level._stealth.logic.corpse.found_dist * level._stealth.logic.corpse.found_dist;
// SP = 0x0 - check OK
}

// 0x4A24
stealth_detect_corpse_range_default()
{
	maps\_stealth_logic::system_default_corpse_detect_ranges();
// SP = 0x0 - check OK
}

// 0x4A34
stealth_friendly_movespeed_scale_set( hidden, alert, spotted )
{
	self maps\_stealth_logic::friendly_set_movespeed_scale( hidden, alert, spotted );
// SP = 0x0 - check OK
}

// 0x4A54
stealth_friendly_movespeed_scale_default()
{
	self maps\_stealth_logic::friendly_default_movespeed_scale();
// SP = 0x0 - check OK
}

// 0x4A68
stealth_friendly_stance_handler_distances_set( hidden, alert )
{
	self maps\_stealth_behavior::friendly_set_stance_handler_distances( hidden, alert );
// SP = 0x0 - check OK
}

// 0x4A84
stealth_friendly_stance_handler_distances_default()
{
	self maps\_stealth_behavior::friendly_default_stance_handler_distances();
// SP = 0x0 - check OK
}

// 0x4A98
stealth_ai_state_functions_set( state_functions )
{
	switch ( self.team )
	{
		case "allies":
			self maps\_stealth_behavior::ai_change_ai_functions( "state", state_functions );
		case "axis":
			self maps\_stealth_behavior::ai_change_ai_functions( "state", state_functions );
	}
// SP = 0x0 - check OK
}

// 0x4AE8
stealth_ai_state_functions_default()
{
	switch ( self.team )
	{
		case "allies":
			self maps\_stealth_behavior::friendly_default_ai_functions( "state" );
		case "axis":
			self maps\_stealth_behavior::enemy_default_ai_functions( "state" );
	}
// SP = 0x0 - check OK
}

// 0x4B30
stealth_ai_alert_functions_set( alert_functions )
{
/#
	assertmsg( "stealth_ai_alert_functions_set should only be called on enemies" );
#/
	return;
	self maps\_stealth_behavior::ai_change_ai_functions( "alert", alert_functions );
// SP = 0x0 - check OK
}

// 0x4B68
stealth_ai_alert_functions_default()
{
/#
	assertmsg( "stealth_ai_alert_functions_default should only be called on enemies" );
#/
	return;
	self maps\_stealth_behavior::enemy_default_ai_functions( "alert" );
// SP = 0x0 - check OK
}

// 0x4B9C
stealth_ai_corpse_functions_set( corpse_functions )
{
/#
	assertmsg( "stealth_ai_corpse_functions_set should only be called on enemies" );
#/
	return;
	self maps\_stealth_behavior::ai_change_ai_functions( "corpse", corpse_functions );
// SP = 0x0 - check OK
}

// 0x4BD4
stealth_ai_corpse_functions_default()
{
/#
	assertmsg( "stealth_ai_corpse_functions_default should only be called on enemies" );
#/
	return;
	self maps\_stealth_behavior::enemy_default_ai_functions( "corpse" );
// SP = 0x0 - check OK
}

// 0x4C08
stealth_ai_awareness_functions_set( awareness_functions )
{
/#
	assertmsg( "stealth_ai_awareness_functions_set should only be called on enemies" );
#/
	return;
	self maps\_stealth_behavior::ai_change_ai_functions( "awareness", awareness_functions );
// SP = 0x0 - check OK
}

// 0x4C40
stealth_ai_awareness_functions_default()
{
/#
	assertmsg( "stealth_ai_awareness_functions_default should only be called on enemies" );
#/
	return;
	self maps\_stealth_behavior::enemy_default_ai_functions( "awareness" );
// SP = 0x0 - check OK
}

// 0x4C74
stealth_ai_clear_custom_idle_and_react()
{
	self maps\_stealth_behavior::ai_clear_custom_animation_reaction_and_idle();
// SP = 0x0 - check OK
}

// 0x4C88
stealth_ai_clear_custom_react()
{
	self maps\_stealth_behavior::ai_clear_custom_animation_reaction();
// SP = 0x0 - check OK
}

// 0x4C9C
stealth_ai_idle_and_react( guy, idle_anim, reaction_anim, tag )
{
	return;
	ender = "stop_loop";
	guy.allowdeath = 1;
	guy stealth_insure_enabled();
	self thread maps\_anim::anim_generic_loop( guy, idle_anim, ender );
	guy maps\_stealth_behavior::ai_set_custom_animation_reaction( self, reaction_anim, tag, ender );
// SP = 0x0 - check OK
}

// 0x4D00
stealth_ai_reach_idle_and_react( guy, reach_anim, idle_anim, reaction_anim )
{
	guy stealth_insure_enabled();
	self thread stealth_ai_reach_idle_and_react_proc( guy, reach_anim, idle_anim, reaction_anim );
// SP = 0x0 - check OK
}

// 0x4D30
stealth_ai_reach_idle_and_react_proc( guy, reach_anim, idle_anim, reaction_anim )
{
	guy thread stealth_enemy_endon_alert();
	guy endon( "stealth_enemy_endon_alert" );
	guy endon( "death" );
	guy stealth_insure_enabled();
	self maps\_anim::anim_generic_reach( guy, reach_anim );
	stealth_ai_idle_and_react( guy, idle_anim, reaction_anim );
// SP = 0x0 - check OK
}

// 0x4D84
stealth_ai_reach_and_arrive_idle_and_react( guy, reach_anim, idle_anim, reaction_anim )
{
	guy stealth_insure_enabled();
	self thread stealth_ai_reach_and_arrive_idle_and_react_proc( guy, reach_anim, idle_anim, reaction_anim );
// SP = 0x0 - check OK
}

// 0x4DB4
stealth_ai_reach_and_arrive_idle_and_react_proc( guy, reach_anim, idle_anim, reaction_anim )
{
	guy thread stealth_enemy_endon_alert();
	guy endon( "stealth_enemy_endon_alert" );
	guy endon( "death" );
	guy stealth_insure_enabled();
	self maps\_anim::anim_generic_reach_aligned( guy, reach_anim );
	stealth_ai_idle_and_react( guy, idle_anim, reaction_anim );
// SP = 0x0 - check OK
}

// 0x4E08
stealth_insure_enabled()
{
	return;
	self thread stealth_ai();
// SP = 0x0 - check OK
}

// 0x4E24
debug_stealth()
{
/#
	wait_for_all_players();
	level.player = getplayers()[0];
	create_debug_hud_elemets();
	level thread debug_level_stealth();
	level thread debug_ai_stealth();
#/
// SP = 0x0 - check OK
}

// 0x4E6C
debug_level_stealth()
{
/#
	level endon( "_stealth_stop_stealth_logic" );
/#
	assert( IsDefined( level.stealth_hud_hidden ) );
#/
	destroy_debug_hud_elemets();
	wait 0.5;
	create_debug_hud_elemets();
	level.stealth_hud_hidden settext( "Hidden - " );
	level.stealth_hud_hidden_value setvalue( flag( "_stealth_hidden" ) );
	level.stealth_hud_alert settext( "Alert - " );
	level.stealth_hud_alert_value setvalue( flag( "_stealth_alert" ) );
	level.stealth_hud_spotted settext( "Spotted - " );
	level.stealth_hud_spotted_value setvalue( flag( "_stealth_spotted" ) );
	level.stealth_hud_corpse settext( "Found Corpse - " );
	level.stealth_hud_corpse_value setvalue( flag( "_stealth_found_corpse" ) );
	level.stealth_visibility_hud_value setvalue( level.player.maxvisibledist );
	circle( level.player.origin, level.player.maxvisibledist, ( 0, 1, 0 ), 0, 1, 1 );
	recordcircle( level.player.origin, level.player.maxvisibledist, ( 0, 1, 0 ), "Script", level.player );
	wait 0.05;
#/
// SP = 0x0 - check OK
}

// 0x4FD0
debug_ai_stealth()
{
/#
	array_thread( getspawnerteamarray( "axis" ), ::add_spawn_function, ::debug_ai_stealth_draw_stealth_info );
	array_thread( getaiarray( "axis" ), ::debug_ai_stealth_draw_stealth_info );
#/
// SP = 0x0 - check OK
}

// 0x501C
debug_ai_stealth_draw_stealth_info()
{
/#
	self endon( "death" );
	wait 0.5;
	wait 0.5;
	enemy = self._stealth.logic.alert_level.enemy getentitynumber();
	print3d_on_ent( "alert level - " + self._stealth.logic.alert_level.lvl + " current enemy - " + enemy, 70 );
	print3d_on_ent( "Saw a Corpse - " + ent_flag( "_stealth_saw_corpse" ) + " Found a Corpse - " + ent_flag( "_stealth_found_corpse" ), 85 );
	print3d_on_ent( "Hidden - " + flag( "_stealth_hidden" ) + " Alert - " + flag( "_stealth_alert" ) + " Spotted - " + flag( "_stealth_spotted" ) + " Found Corpse - " + flag( "_stealth_found_corpse" ) + " GoalRadius - " + self.goalradius, 100 );
	recordline( self.origin, self.goalpos, ( 1, 1, 1 ), "Script", self );
	wait 0.05;
#/
// SP = 0x0 - check OK
}

// 0x519C
create_debug_hud_elemets()
{
/#
	level.stealth_hud_hidden = newdebughudelem();
	level.stealth_hud_hidden.location = 0;
	level.stealth_hud_hidden.alignx = "left";
	level.stealth_hud_hidden.fontscale = 1.3;
	level.stealth_hud_hidden.x = -75;
	level.stealth_hud_hidden.y = 40;
	level.stealth_hud_hidden.color = ( 1, 1, 1 );
	level.stealth_hud_hidden_value = newdebughudelem();
	level.stealth_hud_hidden_value.location = 0;
	level.stealth_hud_hidden_value.alignx = "left";
	level.stealth_hud_hidden_value.fontscale = 1.3;
	level.stealth_hud_hidden_value.x = -10;
	level.stealth_hud_hidden_value.y = 40;
	level.stealth_hud_hidden_value.color = ( 1, 1, 1 );
	level.stealth_hud_alert = newdebughudelem();
	level.stealth_hud_alert.location = 0;
	level.stealth_hud_alert.alignx = "left";
	level.stealth_hud_alert.fontscale = 1.3;
	level.stealth_hud_alert.x = -75;
	level.stealth_hud_alert.y = 55;
	level.stealth_hud_alert.color = ( 1, 1, 1 );
	level.stealth_hud_alert_value = newdebughudelem();
	level.stealth_hud_alert_value.location = 0;
	level.stealth_hud_alert_value.alignx = "left";
	level.stealth_hud_alert_value.fontscale = 1.3;
	level.stealth_hud_alert_value.x = -10;
	level.stealth_hud_alert_value.y = 55;
	level.stealth_hud_alert_value.color = ( 1, 1, 1 );
	level.stealth_hud_spotted = newdebughudelem();
	level.stealth_hud_spotted.location = 0;
	level.stealth_hud_spotted.alignx = "left";
	level.stealth_hud_spotted.fontscale = 1.3;
	level.stealth_hud_spotted.x = -75;
	level.stealth_hud_spotted.y = 70;
	level.stealth_hud_spotted.color = ( 1, 1, 1 );
	level.stealth_hud_spotted_value = newdebughudelem();
	level.stealth_hud_spotted_value.location = 0;
	level.stealth_hud_spotted_value.alignx = "left";
	level.stealth_hud_spotted_value.fontscale = 1.3;
	level.stealth_hud_spotted_value.x = -10;
	level.stealth_hud_spotted_value.y = 70;
	level.stealth_hud_spotted_value.color = ( 1, 1, 1 );
	level.stealth_hud_corpse = newdebughudelem();
	level.stealth_hud_corpse.location = 0;
	level.stealth_hud_corpse.alignx = "left";
	level.stealth_hud_corpse.fontscale = 1.3;
	level.stealth_hud_corpse.x = -75;
	level.stealth_hud_corpse.y = 85;
	level.stealth_hud_corpse.color = ( 1, 1, 1 );
	level.stealth_hud_corpse_value = newdebughudelem();
	level.stealth_hud_corpse_value.location = 0;
	level.stealth_hud_corpse_value.alignx = "left";
	level.stealth_hud_corpse_value.fontscale = 1.3;
	level.stealth_hud_corpse_value.x = 10;
	level.stealth_hud_corpse_value.y = 85;
	level.stealth_hud_corpse_value.color = ( 1, 1, 1 );
	level.stealth_visibility_hud = newdebughudelem();
	level.stealth_visibility_hud.location = 0;
	level.stealth_visibility_hud.alignx = "left";
	level.stealth_visibility_hud.fontscale = 1.3;
	level.stealth_visibility_hud.x = -75;
	level.stealth_visibility_hud.y = 100;
	level.stealth_visibility_hud.color = ( 1, 1, 1 );
	level.stealth_visibility_hud_value = newdebughudelem();
	level.stealth_visibility_hud_value.location = 0;
	level.stealth_visibility_hud_value.alignx = "left";
	level.stealth_visibility_hud_value.fontscale = 1.3;
	level.stealth_visibility_hud_value.x = 0;
	level.stealth_visibility_hud_value.y = 100;
	level.stealth_visibility_hud_value.color = ( 1, 1, 1 );
	level.stealth_foliage_hud = newdebughudelem();
	level.stealth_foliage_hud.location = 0;
	level.stealth_foliage_hud.alignx = "left";
	level.stealth_foliage_hud.fontscale = 1.3;
	level.stealth_foliage_hud.x = -75;
	level.stealth_foliage_hud.y = 115;
	level.stealth_foliage_hud.color = ( 1, 1, 1 );
	level.stealth_foliage_hud_value = newdebughudelem();
	level.stealth_foliage_hud_value.location = 0;
	level.stealth_foliage_hud_value.alignx = "left";
	level.stealth_foliage_hud_value.fontscale = 1.3;
	level.stealth_foliage_hud_value.x = -10;
	level.stealth_foliage_hud_value.y = 115;
	level.stealth_foliage_hud_value.color = ( 1, 1, 1 );
#/
// SP = 0x0 - check OK
}

// 0x55A0
destroy_debug_hud_elemets()
{
/#
	level.stealth_hud_hidden destroy();
	level.stealth_hud_hidden_value destroy();
	level.stealth_hud_alert destroy();
	level.stealth_hud_alert_value destroy();
	level.stealth_hud_spotted destroy();
	level.stealth_hud_spotted_value destroy();
	level.stealth_hud_corpse destroy();
	level.stealth_hud_corpse_value destroy();
	level.stealth_visibility_hud_value destroy();
#/
// SP = 0x0 - check OK
}

// 0x5620
print3d_on_ent( msg, offset )
{
/#
	record3dtext( msg, self.origin + ( 0, 0, offset ), ( 1, 1, 1 ), "Script" );
#/
// SP = 0x0 - check OK
}